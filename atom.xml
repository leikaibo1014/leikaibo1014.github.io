<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雷凯博的博客</title>
  
  <subtitle>记录学习中的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-16T11:04:06.712Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>雷凯博</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树操作</title>
    <link href="http://yoursite.com/2020/06/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-12T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况"><a href="#1-给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况" class="headerlink" title="1. 给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况"></a>1. 给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况</h3><p>例如 abcd 这个字符串，求这四个字符的全排列我们可以这样的进行思考，首先固定第一位的字符，然后把后序的字符依次与第一个位置的字符进行数据位置交换，依次，对于后序的字符我们采用这样方法依次进行交换。按照这种规律，我们可以想到递归的思想。</p><a id="more"></a><p>递归求全排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String array = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = array.toCharArray();</span><br><span class="line">    allSort(chars,<span class="number">0</span>,array.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allSort</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                swap(array, start, i);</span><br><span class="line">                allSort(array,start+<span class="number">1</span>,end);</span><br><span class="line">                swap(array, i, start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = array[start];</span><br><span class="line">        array[start] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除了这种方法外，这个题的递归代码还可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String array = <span class="string">"abc"</span>;</span><br><span class="line">    allZuHe(<span class="string">""</span>, array);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allZuHe</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length() == <span class="number">3</span>) &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); i++) &#123;</span><br><span class="line">        String atemp = a;</span><br><span class="line">        String btemp = b;</span><br><span class="line">        StringBuffer temp = <span class="keyword">new</span> StringBuffer(b);</span><br><span class="line">        allZuHe(a+temp.charAt(i),temp.deleteCharAt(i).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-求一个连续整数数组中的连续子序列和的最大值"><a href="#2-求一个连续整数数组中的连续子序列和的最大值" class="headerlink" title="2.求一个连续整数数组中的连续子序列和的最大值"></a>2.求一个连续整数数组中的连续子序列和的最大值</h3><p>例如在 {-2,-1,6,-3,-2,7,-15,1,2,2} 中连续子序列的最大是8 即是由数组中的  6 -3 -2 7 构成的连续子序列的和最大</p><p>我们可以采用 前i项和与第i项进行比较，取前i项和与第i项的最大值。由于我们每一步的最大值都会变，所以我们需要使用一个变量并记录当前计算或者上一步计算中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">6</span>,-<span class="number">3</span>,-<span class="number">2</span>,<span class="number">7</span>,-<span class="number">15</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = FindGreatestSumOfSubArray(array);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//max就是上面的dp[i]</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//因为这个dp[i]老是变，所以比如你dp[4]是8 dp[5]就变成-7了，所以需要res保存一下</span></span><br><span class="line">        <span class="keyword">int</span> res = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max = Math.max(max + array[i], array[i]);</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3. 二叉树"></a>3. 二叉树</h3><h5 id="给定数组构建二叉树"><a href="#给定数组构建二叉树" class="headerlink" title="给定数组构建二叉树"></a>给定数组构建二叉树</h5><p>由数组构建二叉树，主要是按照数组中的数据顺序，把数组中的数据插入到二叉树中。</p><p>最重要的就是先找出非叶子节点的节点序号，需要为每个序号建立他们的左右孩子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatTreeByArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; treeNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        treeNodeList.add(<span class="keyword">new</span> TreeNode(array[i]));<span class="comment">//把数组转换为树中的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> countNode = array.length; <span class="comment">//节点个数</span></span><br><span class="line">    <span class="comment">//为每个父节点添加左右孩子节点</span></span><br><span class="line">    <span class="comment">//父节点的个数为countNode/2   父节点的下标为 countNode - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNode / <span class="number">2</span> - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">        treeNodeList.get(i).left = treeNodeList.get(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        treeNodeList.get(i).right = treeNodeList.get(i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lastTreeNode = countNode / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果节点数量为奇数则最后一个父节点有右孩子</span></span><br><span class="line">    treeNodeList.get(lastTreeNode).left = treeNodeList.get(lastTreeNode * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (countNode % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        treeNodeList.get(lastTreeNode).right = treeNodeList.get(lastTreeNode * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> treeNodeList.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历的递归与非递归"><a href="#前序遍历的递归与非递归" class="headerlink" title="前序遍历的递归与非递归"></a>前序遍历的递归与非递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//前序的非递归与递归</span><br><span class="line">    public static void preePrintNode(TreeNode treeNode) &#123;</span><br><span class="line">        TreeNode node = treeNode;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack();</span><br><span class="line">        while(node!=null || !stack.empty())&#123;</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                System.out.print(node.value+&quot;-&gt;&quot;);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                TreeNode pop = stack.pop();</span><br><span class="line">                node = pop.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void prePrintNodeDiGui(TreeNode treeNode) &#123;</span><br><span class="line">        if (treeNode == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(treeNode.value+&quot;-&gt;&quot;);</span><br><span class="line">        preePrintNode(treeNode.left);</span><br><span class="line">        preePrintNode(treeNode.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="把-前序遍历的结果存放在集合中"><a href="#把-前序遍历的结果存放在集合中" class="headerlink" title="把 前序遍历的结果存放在集合中"></a>把 前序遍历的结果存放在集合中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//前序遍历存集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    preorderTree(root,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTree</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(root.value);</span><br><span class="line">    preorderTree(root.left,list);</span><br><span class="line">    preorderTree(root.right,list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历非递归集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderList</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(node.value);</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            node = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历的递归与非递归"><a href="#中序遍历的递归与非递归" class="headerlink" title="中序遍历的递归与非递归"></a>中序遍历的递归与非递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//中序的非递归与递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middlePrintNode</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    TreeNode node = treeNode;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            System.out.print(pop.value+<span class="string">"-&gt;"</span>);</span><br><span class="line">            node = pop.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middlePrintNodeDiGui</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    middlePrintNodeDiGui(treeNode.left);</span><br><span class="line">    System.out.print(treeNode.value+<span class="string">"-&gt;"</span>);</span><br><span class="line">    middlePrintNodeDiGui(treeNode.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的递归与非递归"><a href="#后序遍历的递归与非递归" class="headerlink" title="后序遍历的递归与非递归"></a>后序遍历的递归与非递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//后序遍历的非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">houPrintNode</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    TreeNode node = treeNode;</span><br><span class="line">    TreeNode curnode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack1.push(node);</span><br><span class="line">    <span class="comment">//stack2 按照根右左的顺序进栈</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        curnode = stack1.pop();</span><br><span class="line">        stack2.push(curnode);</span><br><span class="line">        <span class="keyword">if</span> (curnode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(curnode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curnode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(curnode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">        System.out.print(stack2.pop().value+<span class="string">"-&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序非递归集合---把结果存放在集合中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">houPrintTreeList</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    TreeNode node = treeNode;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack1.push(node);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        TreeNode curNode = stack1.pop();</span><br><span class="line">        stack2.push(curNode);</span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(curNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">        result.add(stack2.pop().value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">houPrintNodeDiGui</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    houPrintNodeDiGui(treeNode.left);</span><br><span class="line">    houPrintNodeDiGui(treeNode.right);</span><br><span class="line">    System.out.print(treeNode.value+<span class="string">"-&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定二叉树，返回层次遍历得到的节点"><a href="#给定二叉树，返回层次遍历得到的节点" class="headerlink" title="给定二叉树，返回层次遍历得到的节点"></a>给定二叉树，返回层次遍历得到的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//层次[[],[],[]]</span></span><br><span class="line"><span class="comment">//给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; cengciPrintNode(TreeNode treeNode) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">//Queue&lt;TreeNode&gt; queue2 = new ArrayDeque&lt;&gt;();</span></span><br><span class="line">    queue.offer(treeNode);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        count = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            TreeNode poll = queue.poll();</span><br><span class="line">            list.add(poll.value);</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二叉树，从最底层向上，依次层次遍历"><a href="#二叉树，从最底层向上，依次层次遍历" class="headerlink" title="二叉树，从最底层向上，依次层次遍历"></a>二叉树，从最底层向上，依次层次遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//从底向上遍历</span></span><br><span class="line"><span class="comment">//给定一个二叉树，返回其节点值自底向上的层次遍历。</span></span><br><span class="line"><span class="comment">// （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; downToUpCengCiPrint(TreeNode root)&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        count = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            list.add(temp.value);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.addFirst(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求树的路径的和"><a href="#求树的路径的和" class="headerlink" title="求树的路径的和"></a>求树的路径的和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSumPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeDemo treeDemo = <span class="keyword">new</span> TreeDemo();</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">12</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">18</span>&#125;;</span><br><span class="line">        TreeNode treeNode = treeDemo.creatBinTree(array);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; path = findPath(treeNode, <span class="number">36</span>);</span><br><span class="line">        System.out.println(path.toString());</span><br><span class="line">        <span class="keyword">int</span> pathSum = findPathSum(treeNode);</span><br><span class="line">        System.out.println(pathSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找二叉树中存在目标值得节点，并打印出路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treesumPath</span><span class="params">(TreeNode treeNode,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        printPath(treeNode, target, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPath</span><span class="params">(TreeNode treeNode, <span class="keyword">int</span> target, ArrayList list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(treeNode.value);</span><br><span class="line">        target = target - treeNode.value;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; treeNode.left == <span class="keyword">null</span> &amp;&amp; treeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object integer : list) &#123;</span><br><span class="line">                System.out.print(integer + <span class="string">" -&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printPath(treeNode.left, target, list);</span><br><span class="line">            printPath(treeNode.right, target, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，"><a href="#给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，" class="headerlink" title="给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，"></a>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，</span></span><br><span class="line"><span class="comment">// 这条路径上所有节点值相加等于目标和。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum - root.value;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum == <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum) || hasPathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这条路径上所有节点值相加等于目标的目标路径-返回List-lt-List-gt"><a href="#这条路径上所有节点值相加等于目标的目标路径-返回List-lt-List-gt" class="headerlink" title="这条路径上所有节点值相加等于目标的目标路径 返回List&lt;List&gt;"></a>这条路径上所有节点值相加等于目标的目标路径 返回List&lt;List<Integer>&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，</span></span><br><span class="line"><span class="comment">// 这条路径上所有节点值相加等于目标的目标路径 返回List&lt;List&lt;Integer&gt;。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findPath(TreeNode root,<span class="keyword">int</span> target)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root, target, result, temp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode treeNode, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = target - treeNode.value;</span><br><span class="line">    <span class="keyword">if</span> (treeNode.left == <span class="keyword">null</span> &amp;&amp; treeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            temp.add(treeNode.value);</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.add(treeNode.value);</span><br><span class="line">            getPath(treeNode.left,target,result,temp);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.add(treeNode.value);</span><br><span class="line">            getPath(treeNode.right, target, result, temp);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定一个二叉树，它的每个结点都存放一个-0-9-的数字，每条从根到叶子节点的路径都代表一个数字。"><a href="#给定一个二叉树，它的每个结点都存放一个-0-9-的数字，每条从根到叶子节点的路径都代表一个数字。" class="headerlink" title="给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。"></a>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">//给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</span></span><br><span class="line">    <span class="comment">//首先找出所有的从根节点带叶子节点的所有路径</span></span><br><span class="line">    <span class="comment">//求所有路径组成的数字并求和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPathSum</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        findPathList(treeNode, resultList, temp);</span><br><span class="line">        System.out.println(resultList.toString());</span><br><span class="line">        <span class="keyword">for</span> (List list: resultList) &#123;</span><br><span class="line">            StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                stringBuffer.append(list.get(i).toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = Integer.parseInt(stringBuffer.toString());</span><br><span class="line">            result += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPathList</span><span class="params">(TreeNode treeNode, List&lt;List&lt;Integer&gt;&gt; resultList, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.left == <span class="keyword">null</span> &amp;&amp; treeNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.add(treeNode.value);</span><br><span class="line">            resultList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.add(treeNode.value);</span><br><span class="line">                findPathList(treeNode.left, resultList, temp);</span><br><span class="line">                temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.add(treeNode.value);</span><br><span class="line">                findPathList(treeNode.right, resultList, temp);</span><br><span class="line">                temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。"><a href="#将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。" class="headerlink" title="将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。"></a>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.data.treeDemo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.data.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的中序遍历就是升序排列的</span></span><br><span class="line"><span class="comment"> * 所以升序数组是树的中序遍历</span></span><br><span class="line"><span class="comment"> * 用二分法加递归就可以构建二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从定义我们知道，二叉搜索树的中序遍历为一个递增序列，给定的数组其实就是中序遍历结果</span></span><br><span class="line"><span class="comment"> * 取有序数组的中间值做根，左边部分做左树，右边部分做右树如此循环迭代去二分就可还原这棵BST树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tranSearchTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">createSearchTree</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算中间节点</span></span><br><span class="line">        <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(array[middle]);</span><br><span class="line">        root.left = createSearchTree(array, start, middle);</span><br><span class="line">        root.right = createSearchTree(array, middle, end);</span><br><span class="line">        <span class="keyword">return</span>  root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况&quot;&gt;&lt;a href=&quot;#1-给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况&quot; class=&quot;headerlink&quot; title=&quot;1. 给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况&quot;&gt;&lt;/a&gt;1. 给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况&lt;/h3&gt;&lt;p&gt;例如 abcd 这个字符串，求这四个字符的全排列我们可以这样的进行思考，首先固定第一位的字符，然后把后序的字符依次与第一个位置的字符进行数据位置交换，依次，对于后序的字符我们采用这样方法依次进行交换。按照这种规律，我们可以想到递归的思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>回溯问题</title>
    <link href="http://yoursite.com/2020/06/12/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/12/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-12T12:26:32.000Z</published>
    <updated>2021-05-16T11:07:29.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><p>从网格中寻找单词</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.data.stringDemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个二维网格和一个单词，找出该单词是否存在于网格中。</span></span><br><span class="line"><span class="comment"> * 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。</span></span><br><span class="line"><span class="comment"> * 同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * board =</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *   ['A','B','C','E'],</span></span><br><span class="line"><span class="comment"> *   ['S','F','C','S'],</span></span><br><span class="line"><span class="comment"> *   ['A','D','E','E']</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定 word = "ABCCED", 返回 true</span></span><br><span class="line"><span class="comment"> * 给定 word = "SEE", 返回 true</span></span><br><span class="line"><span class="comment"> * 给定 word = "ABCB", 返回 false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路使用递归回溯的方法</span></span><br><span class="line"><span class="comment"> * 需要定义一个二维boolean类型的数组，用来存储当前位置是否能走通</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">searchWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] array = &#123;&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>&#125;,&#123;<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>&#125;&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">boolean</span> result = solution.exist(array, <span class="string">"ABCCED"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.charAt(<span class="number">0</span>) == board[i][j] &amp;&amp; backtrack2(i, j, <span class="number">0</span>, word, visited, board))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> idx, String word, <span class="keyword">boolean</span>[][] visited, <span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word.charAt(idx) || visited[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下找</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack2(i + <span class="number">1</span>, j, idx + <span class="number">1</span>, word, visited, board)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向上找</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack2(i - <span class="number">1</span>, j, idx + <span class="number">1</span>, word, visited, board)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack2(i, j + <span class="number">1</span>, idx + <span class="number">1</span>, word, visited, board)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左</span></span><br><span class="line">        <span class="keyword">if</span> (backtrack2(i, j - <span class="number">1</span>, idx + <span class="number">1</span>, word, visited, board)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;回溯问题&quot;&gt;&lt;a href=&quot;#回溯问题&quot; class=&quot;headerlink&quot; title=&quot;回溯问题&quot;&gt;&lt;/a&gt;回溯问题&lt;/h3&gt;&lt;p&gt;从网格中寻找单词&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归回溯" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>链表操作</title>
    <link href="http://yoursite.com/2020/06/12/%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/12/%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-12T12:24:32.000Z</published>
    <updated>2021-05-16T11:04:06.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><h3 id="判断单链表是否有环"><a href="#判断单链表是否有环" class="headerlink" title="判断单链表是否有环"></a>判断单链表是否有环</h3><p>第一种方式，我们可以使用快慢指针的形式</p><a id="more"></a><pre><code>* 开始，快慢指针都指向头结点，快指针每次都两步，慢指针每次走一步     * 如果存在环，则在运行中，无论运行了几圈，快慢指针肯定会相等，也就是指向同一个位置     * 除此之外，还有另一种解题方式</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.data.LinkListDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断一个单链表中是否有环</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种方式，我们可以使用快慢指针的形式</span></span><br><span class="line"><span class="comment">     * 开始，快慢指针都指向头结点，快指针每次都两步，慢指针每次走一步</span></span><br><span class="line"><span class="comment">     * 如果存在环，则在运行中，无论运行了几圈，快慢指针肯定会相等，也就是指向同一个位置</span></span><br><span class="line"><span class="comment">     * 除此之外，还有另一种解题方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span> &amp;&amp; first.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (first == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以使用一个set集合，存放遍历过的节点，如果下次遍历时存在同样的节点，则证明该单链表中存在环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="判断链表有环，并找出入环的第一个节点"><a href="#判断链表有环，并找出入环的第一个节点" class="headerlink" title="判断链表有环，并找出入环的第一个节点"></a>判断链表有环，并找出入环的第一个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">//判断链表有环，并找出入环的第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span></span><br><span class="line"><span class="comment">     * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。</span></span><br><span class="line"><span class="comment">     * 如果 pos 是 -1，则在该链表中没有环。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输入：head = [3,2,0,-4], pos = 1</span></span><br><span class="line"><span class="comment">     * 输出：tail connects to node index 1</span></span><br><span class="line"><span class="comment">     * 解释：链表中有一个环，其尾部连接到第二个节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 主要解题思路</span></span><br><span class="line"><span class="comment">     * 1，首先是使用快慢指针找出链表中存在环的指针位置</span></span><br><span class="line"><span class="comment">     * 2，指针执行当前快慢指针相交的位置  cur</span></span><br><span class="line"><span class="comment">     * 3. 另一个mo指针从头结点开始向后遍历  mo</span></span><br><span class="line"><span class="comment">     * 4. 当 cur与mo相等，即当前位置为入环的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">hasCyclePlace</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode first = listNode;</span><br><span class="line">        ListNode slow = listNode;</span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        ListNode mo = listNode;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span> &amp;&amp; first.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (first == slow) &#123;</span><br><span class="line">                cur = slow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != mo) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                mo = mo.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数组是不是二叉树的后序遍历"><a href="#判断一个数组是不是二叉树的后序遍历" class="headerlink" title="判断一个数组是不是二叉树的后序遍历"></a>判断一个数组是不是二叉树的后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">verifySquenceBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]  array = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> b = verfySequenceofBST(array, array.length);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给定一个数组，判断这个数组是不是二叉搜索树的后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verfySequenceofBST</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = array[length - <span class="number">1</span>];<span class="comment">//树的根节点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left =<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            left = verfySequenceofBST(array, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> right = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;length-<span class="number">1</span>)&#123;</span><br><span class="line">            right = verfySequenceofBST(array, length - i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.data.sheji;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingleInstance <span class="title">getSingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.data.sheji;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance2 singleInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingleInstance2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleInstance2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重验证"><a href="#双重验证" class="headerlink" title="双重验证"></a>双重验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.data.sheji;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双重验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance3 singleInstance3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SingleInstance3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance3 <span class="title">getInstance3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleInstance3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SingleInstance3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInastance4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SingleInastance4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingleInastance4 singleInastance = <span class="keyword">new</span> SingleInastance4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInastance4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHolder.singleInastance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表操作&quot;&gt;&lt;a href=&quot;#链表操作&quot; class=&quot;headerlink&quot; title=&quot;链表操作&quot;&gt;&lt;/a&gt;链表操作&lt;/h2&gt;&lt;h3 id=&quot;判断单链表是否有环&quot;&gt;&lt;a href=&quot;#判断单链表是否有环&quot; class=&quot;headerlink&quot; title=&quot;判断单链表是否有环&quot;&gt;&lt;/a&gt;判断单链表是否有环&lt;/h3&gt;&lt;p&gt;第一种方式，我们可以使用快慢指针的形式&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-11T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h5 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h5><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.data.sheji;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingleInstance <span class="title">getSingleInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.data.sheji;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance2 singleInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SingleInstance2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleInstance2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重验证"><a href="#双重验证" class="headerlink" title="双重验证"></a>双重验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.data.sheji;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双重验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance3 singleInstance3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SingleInstance3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance3 <span class="title">getInstance3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleInstance3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleInstance3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleInstance3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SingleInstance3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInastance4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SingleInastance4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingleInastance4 singleInastance = <span class="keyword">new</span> SingleInastance4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInastance4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHolder.singleInastance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;h5 id=&quot;单例模式-1&quot;&gt;&lt;a href=&quot;#单例模式-1&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h5&gt;&lt;h5 id=&quot;饿汉式&quot;&gt;&lt;a href=&quot;#饿汉式&quot; class=&quot;headerlink&quot; title=&quot;饿汉式&quot;&gt;&lt;/a&gt;饿汉式&lt;/h5&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2020/06/10/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/06/10/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-06-10T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p> <a id="more"></a><p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p><p>java代码实现堆排序的过程</p><p>首先，我们需要先交换每一个非叶子结点和他们的左右孩子节点，构造这三个节点为一个大顶堆.</p><p>以下代码的思想就是，交换结点以及他们左右孩子节点，找到最大值并交换位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数说明   arr 表示待构建数组</span></span><br><span class="line"><span class="comment">    * n：表示堆的元素个数</span></span><br><span class="line"><span class="comment">    * i: 表示每一个小堆的父节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_step</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> c1 = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">//i结点的左孩子</span></span><br><span class="line">       <span class="keyword">int</span> c2 = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">//i结点的右孩子</span></span><br><span class="line">       <span class="keyword">int</span> max = i;   <span class="comment">//这三个元素最大值的下标指向</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//定义递归出口</span></span><br><span class="line">       <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max])&#123;</span><br><span class="line">           max = c1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123;</span><br><span class="line">           max = c2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">           swap(arr, max, i);<span class="comment">//交换两个位置的元素</span></span><br><span class="line">           heap_step(arr, n, max);<span class="comment">//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       两个元素交换位置的函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">       arr[i] = arr[j];</span><br><span class="line">       arr[j] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的方法是构建结点以及孩子节点元素的交换步骤</p><p>下面我们需要，对数组中也就是完全二叉树中所有的非叶子结点，逐次遍历，对每一个非叶子结点都需要进行构造大顶堆的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆</span></span><br><span class="line"><span class="comment">     * 从最后一个非叶子结点开始</span></span><br><span class="line"><span class="comment">     * 最后一个叶子结点数组下标为：  last_node = arr.length-1</span></span><br><span class="line"><span class="comment">     * 则最后一个非叶子结点为   last_parent = (last_node-1)/2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last_node = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last_parent = (last_node-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last_parent; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            heap_step(arr,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上方法执行完，我们的数组完全二叉树就完全变成了一个大顶堆。每一个根节点都大于他们的左右孩子节点</p><p>构造完大顶堆之后，我们需要把大顶堆的根元素与最后一个位置的元素进行位置的交换。</p><p>交换代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    build_heap(arr, arr.length);   <span class="comment">//把数组先构造成为一个大顶堆</span></span><br><span class="line">    <span class="comment">// 这个时候数组已经是一个大顶堆了</span></span><br><span class="line">    <span class="comment">//交换数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, i, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            因为这个时候完全二叉树已经是一个大顶堆了，</span></span><br><span class="line"><span class="comment">            所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        heap_step(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是对排序中的各个步骤逐一的记录，下面是完整代码：</p><p>完整的堆排序算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>&#125;;</span><br><span class="line">        heap_sort(array, array.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数说明   arr 表示待构建数组</span></span><br><span class="line"><span class="comment">     * n：表示堆的元素个数</span></span><br><span class="line"><span class="comment">     * i: 表示每一个小堆的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_step</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">//i结点的左孩子</span></span><br><span class="line">        <span class="keyword">int</span> c2 = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">//i结点的右孩子</span></span><br><span class="line">        <span class="keyword">int</span> max = i;   <span class="comment">//这三个元素最大值的下标指向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max])&#123;</span><br><span class="line">            max = c1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123;</span><br><span class="line">            max = c2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">            swap(arr, max, i);<span class="comment">//交换两个位置的元素</span></span><br><span class="line">            heap_step(arr, n, max);<span class="comment">//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆</span></span><br><span class="line"><span class="comment">     * 从最后一个非叶子结点开始</span></span><br><span class="line"><span class="comment">     * 最后一个叶子结点数组下标为：  last_node = arr.length-1</span></span><br><span class="line"><span class="comment">     * 则最后一个非叶子结点为   last_parent = (last_node-1)/2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last_node = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last_parent = (last_node-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last_parent; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            heap_step(arr,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        build_heap(arr, arr.length);   <span class="comment">//把数组先构造成为一个大顶堆</span></span><br><span class="line">        <span class="comment">// 这个时候数组已经是一个大顶堆了</span></span><br><span class="line">        <span class="comment">//交换数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                因为这个时候完全二叉树已经是一个大顶堆了，</span></span><br><span class="line"><span class="comment">                所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            heap_step(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个元素交换位置的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> study.Sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortArray</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> low,<span class="keyword">int</span> hight)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i,j,temp,t;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; hight) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = hight;</span><br><span class="line">        temp = array[low];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (temp&lt;=array[j] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (temp&gt;=array[i] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                t = array[j];</span><br><span class="line">                array[j] = array[i];</span><br><span class="line">                array[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array[low] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        quickSortArray(array,low,j-<span class="number">1</span>);</span><br><span class="line">        quickSortArray(array,j+<span class="number">1</span>,hight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array =&#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">15</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        quickSortArray(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSortArr</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] =temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = array[i];</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; array[j]) &#123;</span><br><span class="line">                min = array[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p&gt;
&lt;p&gt;堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>作业帮面试整理</title>
    <link href="http://yoursite.com/2020/06/09/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/09/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</id>
    <published>2020-06-09T14:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2>  <a id="more"></a><h2 id="一面："><a href="#一面：" class="headerlink" title="一面："></a>一面：</h2><ul><li><p>1.自我介绍 </p></li><li><p>2.讲讲之前实习是做了什么工作 </p></li><li><p>3.项目做了什么，为什么做这个项目，有什么困难，如何解决，结果是什么。 </p></li><li><p>看你项目中遇到的困难在缓存和数据库，那你项目的后端框架用的是什么，数据库的底层数据结构是什么，磁盘的数据结构是什么？ </p></li><li><p>. B+树的结构是什么，和B树有什么区别，红黑树结构是什么？</p></li><li><p>红黑树的应用有哪些？AVL树是什么，平衡二叉树的条件是什么？ </p></li></ul><h4 id="一、B树的应用"><a href="#一、B树的应用" class="headerlink" title="一、B树的应用"></a>一、B树的应用</h4><h3 id="1、B树大量应用在数据库和文件系统当中。"><a href="#1、B树大量应用在数据库和文件系统当中。" class="headerlink" title="1、B树大量应用在数据库和文件系统当中。"></a>1、B树大量应用在数据库和文件系统当中。</h3><p>它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。</p><p>假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。</p><p>如mongoDB数据库使用，单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）</p><h4 id="二、B-树的应用"><a href="#二、B-树的应用" class="headerlink" title="二、B+树的应用"></a>二、B+树的应用</h4><p>mysql使用B+树作为索引：</p><p>B+树相对B树的优点：</p><p>①B+树的所有Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串联起来，遍历叶子节点就能获取全部数据，这样就能进行区间访问了。</p><p>②IO一次读数据是从磁盘上读的，磁盘容量是固定的，取数据量大小是固定的，非叶子节点不存储数据，节点小，磁盘IO次数就少。</p><p>InnoDB索引和MyISAM最大的区别是它只有一个数据文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点数据域保存了完整的数据记录。所以我们又把它的主索引叫做聚集索引。而它的辅助索引和MyISAM也会有所不同，它的辅助索引都是将主键作为数据域。所以，这样当我们查找的时候通过辅助索引要先找到主键，然后通过主索引再找到对于的主键，得到信息。</p><p>MyISAM表索引在处理文本索引时更具优势，而INNODB表索引在其它类型上更具效率优势，同时MySQL高并发需要事务场景时，只能使用INNODB表</p><h3 id="三、红黑树"><a href="#三、红黑树" class="headerlink" title="三、红黑树"></a>三、红黑树</h3><p>红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。</p><p>如linux中进程的调度用的是红黑树。</p><p>反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。</p><h3 id="哈希表用什么解决冲突的？"><a href="#哈希表用什么解决冲突的？" class="headerlink" title="哈希表用什么解决冲突的？"></a>哈希表用什么解决冲突的？</h3><p>拉链法</p><ol start="8"><li><ul><li>拉链法解决冲突可以，但是如果链表变长，如何优化呢？</li></ul></li></ol><p>HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）,时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>一直到JDK7为止，HashMap的结构都是这么简单，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。</p><p>这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。再最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。</p><h2 id="如果优化为树结构，数据量依旧很大，如何进一步优化？"><a href="#如果优化为树结构，数据量依旧很大，如何进一步优化？" class="headerlink" title="如果优化为树结构，数据量依旧很大，如何进一步优化？"></a>如果优化为树结构，数据量依旧很大，如何进一步优化？</h2><h3 id="10-数据库读写分离机制，如何做分库分表的？用的什么中间件去分库分表？"><a href="#10-数据库读写分离机制，如何做分库分表的？用的什么中间件去分库分表？" class="headerlink" title="10 数据库读写分离机制，如何做分库分表的？用的什么中间件去分库分表？"></a>10 数据库读写分离机制，如何做分库分表的？用的什么中间件去分库分表？</h3><p>11.如何确保数据库的稳定性 </p><p>12.算法：链表反转 </p><p>13.有什么要问我的？</p><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h3><h3 id="2-做过哪些项目，给自己印象最深的项目是什么"><a href="#2-做过哪些项目，给自己印象最深的项目是什么" class="headerlink" title="2.做过哪些项目，给自己印象最深的项目是什么"></a>2.做过哪些项目，给自己印象最深的项目是什么</h3><h3 id="3-用redis做二级缓存的时候如何确保高并发数据的一致性，如果有一张订单表，我要你找到对应用户所拥有的订单，怎么找？"><a href="#3-用redis做二级缓存的时候如何确保高并发数据的一致性，如果有一张订单表，我要你找到对应用户所拥有的订单，怎么找？" class="headerlink" title="3.用redis做二级缓存的时候如何确保高并发数据的一致性，如果有一张订单表，我要你找到对应用户所拥有的订单，怎么找？"></a>3.用redis做二级缓存的时候如何确保高并发数据的一致性，如果有一张订单表，我要你找到对应用户所拥有的订单，怎么找？</h3><p>数据库的几种事务隔离机制是什么，有哪些？有什么用？ </p><p>mysql支持事务的常用引擎是InnoDB</p><p>第一种：读未提交（read uncommitted）</p><p>　　　　　　第一个事务未提交更新的数据，第二个事务可以读到，这是读未提                交。</p><p>　　　　　　第一个事务未提交更新的数据回滚，第二个事务读到回滚的数据，                这是脏读。故读未提交，可能会出现脏读。</p><p>第二种：读已提交（read committed），也称不可重复读</p><p>　　　　　　第一个事务未提交更新的数据，第二个事务读不到；</p><p>　　　　　　第一个事务提交更新的数据，第二个事务可以读到；这是读已提交。</p><p>　　　　　　第一个事务提交更新小明同学年龄12岁，第二个事务读到小明12                岁；</p><p>第三个事务再次提交更新小明同学年龄14岁，第二个事务再读到小明14岁；这是不可重复读（同一个事务内读取的数据结果不一致）。</p><p>　　　　　　故读已提交，会出现不可重复读（同一个事务内读取的数据结果不            一致），不可重复读也会造成幻读（同一个事务内读取的数据结果            不一致）。</p><p>第三种：可重复读（repeatable read），mysql默认事务隔离级别</p><p>第一个事务提交更新小明同学年龄12岁，第二个事务读到小明12岁；</p><p>第三个事务再次提交更新小明同学年龄14岁，第二个事务再读到小明12岁；这是可重复读（同一个事务内读取的数据结果一致）。</p><p>第四个事务提交插入同学小马数据记录，第二个事务再读不仅读到小明12    岁数据，还会读到小马同学数据，这是幻读。</p><p>故可重复读，会出现幻读（同一个事务内读取的数据结果不一致）。</p><p>第四种：串行化（serializable）</p><p>隔离级别最高，解决了脏读、不可重复无、幻读问题。</p><p>　　　　　　同一个事务内，不管读取多少次，结果集永远一致。</p><h3 id="Str1-“a”-str2-new-string-“a”-区别，虚拟机内存空间上如何体现这两个区别，这区别具体在开发中会造成什么问题，如何解决？"><a href="#Str1-“a”-str2-new-string-“a”-区别，虚拟机内存空间上如何体现这两个区别，这区别具体在开发中会造成什么问题，如何解决？" class="headerlink" title="Str1=“a” str2=new string(“a”)区别，虚拟机内存空间上如何体现这两个区别，这区别具体在开发中会造成什么问题，如何解决？"></a>Str1=“a” str2=new string(“a”)区别，虚拟机内存空间上如何体现这两个区别，这区别具体在开发中会造成什么问题，如何解决？</h3><ul><li><p>==:比较引用类型比较的是地址值是否相同</p></li><li><p>equals:比较引用类型默认也是比较地址值是否相同，注意:<strong><em>\</em>String类重写了equals()方法**</strong>，比较的是内容是否相同。</p></li></ul><p>String A = “ABC”;内存会去查找永久代(常量池) ，如果没有的话，在永久代中中开辟一块儿内存空间，把地址付给栈指针，如果已经有了”ABC”的内存，直接把地址赋给栈指针；****</p><p><strong><em>\</em>而String str = new String(“a”);是根据”a”这个String对象再次构造一个String对象;在堆中从新new一块儿内存，把指针赋给栈，**</strong></p><p>堆  栈  变量的存放位置</p><h3 id="Java和C-在内存处理上有什么区别？虚拟机的常用垃圾回收机制有什么？"><a href="#Java和C-在内存处理上有什么区别？虚拟机的常用垃圾回收机制有什么？" class="headerlink" title="Java和C++在内存处理上有什么区别？虚拟机的常用垃圾回收机制有什么？"></a>Java和C++在内存处理上有什么区别？虚拟机的常用垃圾回收机制有什么？</h3><h3 id="什么时候会发生OOM错误（内存溢出错误）"><a href="#什么时候会发生OOM错误（内存溢出错误）" class="headerlink" title="什么时候会发生OOM错误（内存溢出错误）"></a>什么时候会发生OOM错误（内存溢出错误）</h3><p>栈溢出，堆溢出</p><p>栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）</p><p>所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。</p><p>heap space表示堆空间，堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出</p><h3 id="Redis的基本数据结构是什么？"><a href="#Redis的基本数据结构是什么？" class="headerlink" title="Redis的基本数据结构是什么？"></a>Redis的基本数据结构是什么？</h3><h3 id="redis如何做持久化的？"><a href="#redis如何做持久化的？" class="headerlink" title="redis如何做持久化的？"></a>redis如何做持久化的？</h3><h3 id="给你一个场景，设计秒杀系统，假设有10件商品，-先用redis去get数量，数量-1，然后用set更新redis的数据，如果get数据为0就表示商品卖完了，这种情况安全么，有问题的话如何解决"><a href="#给你一个场景，设计秒杀系统，假设有10件商品，-先用redis去get数量，数量-1，然后用set更新redis的数据，如果get数据为0就表示商品卖完了，这种情况安全么，有问题的话如何解决" class="headerlink" title="给你一个场景，设计秒杀系统，假设有10件商品， 先用redis去get数量，数量-1，然后用set更新redis的数据，如果get数据为0就表示商品卖完了，这种情况安全么，有问题的话如何解决"></a>给你一个场景，设计秒杀系统，假设有10件商品， 先用redis去get数量，数量-1，然后用set更新redis的数据，如果get数据为0就表示商品卖完了，这种情况安全么，有问题的话如何解决</h3><h3 id="redis加锁上锁的命令是什么"><a href="#redis加锁上锁的命令是什么" class="headerlink" title="redis加锁上锁的命令是什么"></a>redis加锁上锁的命令是什么</h3><h4 id="Linux-awk-grep命令是什么，如何用正则表达式匹配AxxxxAxxx？（正则还是用的比较少-生疏了。。。）"><a href="#Linux-awk-grep命令是什么，如何用正则表达式匹配AxxxxAxxx？（正则还是用的比较少-生疏了。。。）" class="headerlink" title="Linux awk grep命令是什么，如何用正则表达式匹配AxxxxAxxx？（正则还是用的比较少 生疏了。。。）"></a>Linux awk grep命令是什么，如何用正则表达式匹配AxxxxAxxx？（正则还是用的比较少 生疏了。。。）</h4><h3 id="讲一下在浏览器输入URL之后到浏览器出现界面的全过程，系统后面用了哪些协议"><a href="#讲一下在浏览器输入URL之后到浏览器出现界面的全过程，系统后面用了哪些协议" class="headerlink" title="讲一下在浏览器输入URL之后到浏览器出现界面的全过程，系统后面用了哪些协议"></a>讲一下在浏览器输入URL之后到浏览器出现界面的全过程，系统后面用了哪些协议</h3><ul><li><p>首先进行域名解析，域名解析具体过程讲一下：</p></li><li><p>浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p></li><li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li><li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：</p></li><li><p>本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；</p></li><li><p>本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；</p></li><li><p>本地域名服务器向权限域名服务器发起请求，得到IP地址；</p></li></ul><ul><li><p>本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；</p></li><li><p>操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；</p></li><li><p>至此，浏览器已经得到了域名对应的IP地址。</p></li></ul><ol start="2"><li>浏览器发起HTTP请求；</li></ol><ol start="3"><li><p>接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息–三次握手建立连接–四次挥手断开连接；</p></li><li><p>然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；</p></li><li><p>接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；</p></li><li><p>服务器响应请求并请求客户端要的资源，传回给客户端；</p></li><li><p>断开TCP连接，浏览器对页面进行渲染呈现给客户端。</p></li></ol><h4 id="如果你有很多IP地址，如何找到出现次数最多的前三个IP地址？（hashMap-heap）"><a href="#如果你有很多IP地址，如何找到出现次数最多的前三个IP地址？（hashMap-heap）" class="headerlink" title="如果你有很多IP地址，如何找到出现次数最多的前三个IP地址？（hashMap + heap）"></a>如果你有很多IP地址，如何找到出现次数最多的前三个IP地址？（hashMap + heap）</h4><ul><li><p>1.直接排序</p></li><li><p>2.使用hashTable  我们的算法就有了：维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。</p></li><li><p>本方法相比算法1：在时间复杂度上提高了一个数量级，为O（N），但不仅仅是时间复杂度上的优化，该方法只需要IO数据文件一次，而算法1的IO次数较多的，因此该算法2比算法1在工程上有更好的可操作性。</p></li></ul><h3 id="如果你有一个100G的IP地址文件，你的机器只有5G存储空间，如何找到出现次数最多的前三IP地址？"><a href="#如果你有一个100G的IP地址文件，你的机器只有5G存储空间，如何找到出现次数最多的前三IP地址？" class="headerlink" title="如果你有一个100G的IP地址文件，你的机器只有5G存储空间，如何找到出现次数最多的前三IP地址？"></a>如果你有一个100G的IP地址文件，你的机器只有5G存储空间，如何找到出现次数最多的前三IP地址？</h3><h3 id="如果一张订单表特别大，你会如何处理这个表格，如何优化它？"><a href="#如果一张订单表特别大，你会如何处理这个表格，如何优化它？" class="headerlink" title="如果一张订单表特别大，你会如何处理这个表格，如何优化它？"></a>如果一张订单表特别大，你会如何处理这个表格，如何优化它？</h3><h3 id="我们一般都是把历史数据定期转存其他表（一样的表名后加年月例如TABLE201205）归档"><a href="#我们一般都是把历史数据定期转存其他表（一样的表名后加年月例如TABLE201205）归档" class="headerlink" title="我们一般都是把历史数据定期转存其他表（一样的表名后加年月例如TABLE201205）归档~"></a>我们一般都是把历史数据定期转存其他表（一样的表名后加年月例如TABLE201205）归档~</h3><p>这样该表本年度的查询的压力也小点（90%查询量集中在本年度）,即使查询历史数据也不影响性能，强力推荐！</p><h4 id="算法题：字符串切分-反转"><a href="#算法题：字符串切分-反转" class="headerlink" title="算法题：字符串切分+反转"></a>算法题：字符串切分+反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i am a student</span></span><br><span class="line">        String string = <span class="string">"i am a student"</span>;</span><br><span class="line">        String s = reverseDemo(string);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseDemo</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">        String[] strArr = string.split(<span class="string">" "</span>);</span><br><span class="line">        String[] resultArr = <span class="keyword">new</span> String[strArr.length];</span><br><span class="line"></span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strArr.length;i++)&#123;</span><br><span class="line">            resultArr[i] = strArr[strArr.length - i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i != strArr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                stringBuffer.append(resultArr[i]);</span><br><span class="line">                stringBuffer.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuffer.append(resultArr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-盲人有10双袜子，两双黑的，8双白的，如何在没人帮助下找出黑的（在太阳下晒一晒黑色更吸热）"><a href="#16-盲人有10双袜子，两双黑的，8双白的，如何在没人帮助下找出黑的（在太阳下晒一晒黑色更吸热）" class="headerlink" title="16.盲人有10双袜子，两双黑的，8双白的，如何在没人帮助下找出黑的（在太阳下晒一晒黑色更吸热）"></a>16.盲人有10双袜子，两双黑的，8双白的，如何在没人帮助下找出黑的（在太阳下晒一晒黑色更吸热）</h3><h3 id="17-你有什么问题想问我的？"><a href="#17-你有什么问题想问我的？" class="headerlink" title="17.你有什么问题想问我的？"></a>17.你有什么问题想问我的？</h3><h3 id="MYSQL日志分为几种"><a href="#MYSQL日志分为几种" class="headerlink" title="MYSQL日志分为几种"></a>MYSQL日志分为几种</h3><p><a href="https://blog.csdn.net/xiamiflying/article/details/80960598" target="_blank" rel="noopener">https://blog.csdn.net/xiamiflying/article/details/80960598</a></p><p>如何保证回滚</p><p>数据库中事务到底是mvcc回滚还是日志回滚</p><h3 id="socket有几种状态"><a href="#socket有几种状态" class="headerlink" title="socket有几种状态"></a>socket有几种状态</h3><h5 id="Socket-11种状态"><a href="#Socket-11种状态" class="headerlink" title="Socket 11种状态"></a>Socket 11种状态</h5><ul><li>1、SOCKET状态介绍</li></ul><p>socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口;HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。</p><p>  1、客户端独有的：（1）SYN_SENT （2）FIN_WAIT1 （3）FIN_WAIT2 （4）CLOSING （5）TIME_WAIT 。</p><p>  2、服务器独有的：（1）LISTEN （2）SYN_RCVD （3）CLOSE_WAIT （4）LAST_ACK 。</p><p>  3、共有的：（1）CLOSED （2）ESTABLISHED 。</p><h5 id="mysql更新了数据日志文件有什么改变"><a href="#mysql更新了数据日志文件有什么改变" class="headerlink" title="mysql更新了数据日志文件有什么改变"></a>mysql更新了数据日志文件有什么改变</h5><h5 id="它的意思是服务器崩了，你访问服务器应该是什么样"><a href="#它的意思是服务器崩了，你访问服务器应该是什么样" class="headerlink" title="它的意思是服务器崩了，你访问服务器应该是什么样"></a>它的意思是服务器崩了，你访问服务器应该是什么样</h5><p>服务器崩了发送什么错误码，崩了情况下500是谁发的<br>开发环境和生产环境不一样，配置环境应该有什么不同配置数据库<br>ACID<br>死锁以及解决措施</p><p>rabbitmq中各种模式<br>堆栈区别<br>GC回收算法<br>点击按钮这个过程详解一下</p><h3 id="算法题："><a href="#算法题：" class="headerlink" title="算法题："></a>算法题：</h3><p>长字符串相加<br>nums[] = {1,-1,0,2,-2,1,3} 找到所有不重复a + b + c = 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">暴力解法，而且重复</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zifuJia</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        List list = stringSum(array);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">stringSum</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; array[i] == array[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; array.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] + array[j] + array[k] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                       list.add(Arrays.asList(array[i], array[j], array[k]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).equals(list.get(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                list.remove(list.get(i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>&#125;;</span><br><span class="line">        heap_sort(array, array.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数说明   arr 表示待构建数组</span></span><br><span class="line"><span class="comment">     * n：表示堆的元素个数</span></span><br><span class="line"><span class="comment">     * i: 表示每一个小堆的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_step</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c1 = <span class="number">2</span> * i + <span class="number">1</span>;    <span class="comment">//i结点的左孩子</span></span><br><span class="line">        <span class="keyword">int</span> c2 = <span class="number">2</span> * i + <span class="number">2</span>;   <span class="comment">//i结点的右孩子</span></span><br><span class="line">        <span class="keyword">int</span> max = i;   <span class="comment">//这三个元素最大值的下标指向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max])&#123;</span><br><span class="line">            max = c1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123;</span><br><span class="line">            max = c2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">            swap(arr, max, i);<span class="comment">//交换两个位置的元素</span></span><br><span class="line">            heap_step(arr, n, max);<span class="comment">//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆</span></span><br><span class="line"><span class="comment">     * 从最后一个非叶子结点开始</span></span><br><span class="line"><span class="comment">     * 最后一个叶子结点数组下标为：  last_node = arr.length-1</span></span><br><span class="line"><span class="comment">     * 则最后一个非叶子结点为   last_parent = (last_node-1)/2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last_node = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last_parent = (last_node-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last_parent; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            heap_step(arr,n,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        build_heap(arr, arr.length);   <span class="comment">//把数组先构造成为一个大顶堆</span></span><br><span class="line">        <span class="comment">// 这个时候数组已经是一个大顶堆了</span></span><br><span class="line">        <span class="comment">//交换数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                因为这个时候完全二叉树已经是一个大顶堆了，</span></span><br><span class="line"><span class="comment">                所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            heap_step(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个元素交换位置的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序;"></a>快速排序;</h5><p>问了项目，单点登录实现 </p><p>如何解决分布式session </p><p>redis集群怎么做的，主从复制流程 </p><p>RDB和AOF，如果AOF文件很大怎么办，AOF重做，还是特别大怎么办，分片复制 </p><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>三次挥手行不行，为什么 </p><h4 id="状态码301与302的区别"><a href="#状态码301与302的区别" class="headerlink" title="状态码301与302的区别"></a>状态码301与302的区别</h4><p>详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了）</p><p>301 redirect: 301 代表永久性转移(Permanently Moved)</p><p>302 redirect: 302 代表暂时性转移(Temporarily Moved )</p><h4 id="Linux找到文件夹下包含某个字符的所有记录"><a href="#Linux找到文件夹下包含某个字符的所有记录" class="headerlink" title="Linux找到文件夹下包含某个字符的所有记录"></a>Linux找到文件夹下包含某个字符的所有记录</h4><p>grep -r message ./</p><p>示例解释：在当前目录下递归查找含有字符串message的文件</p><p>-r 是递归查找</p><p>-n 是显示行号</p><p>-R 查找所有文件包含子目录</p><p>-i 忽略大小写</p><h3 id="分页查询页数很大效率低怎么办，join-连接主键优化"><a href="#分页查询页数很大效率低怎么办，join-连接主键优化" class="headerlink" title="分页查询页数很大效率低怎么办，join 连接主键优化"></a>分页查询页数很大效率低怎么办，join 连接主键优化</h3><p>select * from orders_history where type=8 limit 100000,100;</p><p><strong><em>\</em>这种分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。**</strong></p><p><strong>(1)</strong> <strong><em>\</em>使用子查询优化–**</strong>这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。</p><p><strong>(2)</strong> <strong><em>\</em>使用 id 限定优化*****</strong>*—****这种方式假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询</p><p>(3) 当然还可以使用 in 的方式来进行查询，这种方式经常用在多表关联的时候进行查询，使用其他表查询的id集合，来进行查询</p><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>(1) 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</p><p>(2) 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</p><p>一个包含查询所需字段的索引称为“覆盖索引”</p><p>MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少IO，提高了效率</p><h3 id="算法：下一个排列"><a href="#算法：下一个排列" class="headerlink" title="算法：下一个排列"></a>算法：下一个排列</h3><p>solr怎么用的，zookeeper怎么用的 </p><p>如何保证solr与数据库一致性 </p><h3 id="DNS递归和迭代"><a href="#DNS递归和迭代" class="headerlink" title="DNS递归和迭代"></a>DNS递归和迭代</h3><p>一、主机向本地域名服务器的查询一般都是采用递归查询。</p><p>​    所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，</p><p>​    向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。</p><p>​    因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p><h4 id="二、本地域名服务器向根域名服务器的查询的迭代查询。"><a href="#二、本地域名服务器向根域名服务器的查询的迭代查询。" class="headerlink" title="二、本地域名服务器向根域名服务器的查询的迭代查询。"></a>二、本地域名服务器向根域名服务器的查询的迭代查询。</h4><p>​    迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p><p>​    然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。</p><p>​    顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。</p><p>​    最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机</p><h2 id="CAS原理，ABA问题，解决方法"><a href="#CAS原理，ABA问题，解决方法" class="headerlink" title="CAS原理，ABA问题，解决方法"></a>CAS原理，ABA问题，解决方法</h2><p>volatile只能保证可见性，不能保证原子性。</p><p>但原子类（AtomicInteger等可以保证原子性），原子类利用volatile+CAS来保证原子性</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><h4 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h4><p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p><h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><h5 id="CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作"><a href="#CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作" class="headerlink" title="CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作"></a>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</h5><ol><li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li></ol><p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><ol start="2"><li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率</li></ol><ol start="3"><li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li></ol><h3 id="Dubbo原理"><a href="#Dubbo原理" class="headerlink" title="Dubbo原理"></a>Dubbo原理</h3><h4 id="注册中心宕机怎么办"><a href="#注册中心宕机怎么办" class="headerlink" title="注册中心宕机怎么办"></a>注册中心宕机怎么办</h4><h3 id="RPC分为哪几部分"><a href="#RPC分为哪几部分" class="headerlink" title="RPC分为哪几部分"></a>RPC分为哪几部分</h3><h4 id="Linux常用命令，让我按要求查日志，就是grep，cut，啥的"><a href="#Linux常用命令，让我按要求查日志，就是grep，cut，啥的" class="headerlink" title="Linux常用命令，让我按要求查日志，就是grep，cut，啥的"></a>Linux常用命令，让我按要求查日志，就是grep，cut，啥的</h4><p>cat 查看文件  cat 文件名 ——一次显示整个文件的内容</p><p>将几个文件合并为一个文件</p><p>$cat file1 file2 &gt; file</p><p>grep 搜索</p><p>用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><p>ps -ef | grep redis   查找指定进程</p><p>从文件中查找关键词</p><p>Grep “cat” 文件名</p><p>搜索log目录下卡号为：“4563513600036385540”,在哪个文件的具体位置及行数</p><p>grep -rin “4563513600036385540” log/</p><p>Cut 剪切文件</p><p>cut命令是一个选取命令，其功能是将文件中的每一行”字节” ”字符” ”字段” 进行剪切，选取我们需要的，并将这些选取好的数据输出至标准输出</p><p>Cut  -c 文件名  以字符为单位进行分割</p><p>Cut -d 文件名   默认制表符分割</p><p>ES倒排索引 </p><p>算法： </p><p>\1. 一个字符串数组，按长度大小，相同长度按字典顺序 </p><p>字符数组排序</p><p>public static void sortString(String[] arr) {<br>  for (int i = 0; i &lt; arr.length - 1; i++) {<br>    for (int j = i + 1; j &lt; arr.length; j++) {<br>      if (arr[i].compareTo(arr[j]) &gt; 0)  //字符串比较  arr[i].compareTo(arr[j])<br>      <strong>swap</strong>(arr, i, j);<br>    }<br>  }<br>}</p><p>2.EXCEL数字转字母</p><p>生活中你是怎样的人</p><p>举个例子</p><p>了解作业帮吗</p><p>说说你的缺点</p><p>说说你觉得经历过比较困难的时间</p><p>有看非技术的书吗，推荐下，</p><p>介绍下*本书讲了什么</p><p>对未来的规划</p><p>想来北京发展吗等等</p><p>一面： </p><h3 id="一棵m阶的B-tree-m叉树-：树中每个结点至多-个孩子，除根结点和叶子结点外，其它每个结点至少有-个孩子-B-树又叫平衡多路查找树。一棵m阶的B-树-m叉树-的特性如下："><a href="#一棵m阶的B-tree-m叉树-：树中每个结点至多-个孩子，除根结点和叶子结点外，其它每个结点至少有-个孩子-B-树又叫平衡多路查找树。一棵m阶的B-树-m叉树-的特性如下：" class="headerlink" title="一棵m阶的B-tree(m叉树)：树中每个结点至多()个孩子，除根结点和叶子结点外，其它每个结点至少有()个孩子 B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下："></a>一棵m阶的B-tree(m叉树)：树中每个结点至多()个孩子，除根结点和叶子结点外，其它每个结点至少有()个孩子 B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下：</h3><ol><li><p>树中每个结点最多含有m个孩子（m&gt;=2）；</p></li><li><p>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</p></li><li><p>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p></li><li><p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；</p></li><li><p>每个非终端结点中包含有n个关键字信息： (P1，K1，P2，K2，P3，……，Kn，Pn+1)。其中：</p></li></ol><p>​    a)  Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 </p><p>​    b)  Pi为指向子树根的接点，且指针P(i)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 </p><p>​    c)  关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</p><h3 id="二进制1101-01转化成十进制"><a href="#二进制1101-01转化成十进制" class="headerlink" title="二进制1101.01转化成十进制"></a>二进制1101.01转化成十进制</h3><h2 id="快速排序的平均时间复杂度和最坏时间复杂度是多少"><a href="#快速排序的平均时间复杂度和最坏时间复杂度是多少" class="headerlink" title="快速排序的平均时间复杂度和最坏时间复杂度是多少"></a>快速排序的平均时间复杂度和最坏时间复杂度是多少</h2><h3 id="排序算法的时间复杂度"><a href="#排序算法的时间复杂度" class="headerlink" title="排序算法的时间复杂度"></a>排序算法的时间复杂度</h3><h3 id="7-lt-lt-1-amp-15运算后的结果是"><a href="#7-lt-lt-1-amp-15运算后的结果是" class="headerlink" title="(7&lt;&lt;1)&amp;15运算后的结果是"></a>(7&lt;&lt;1)&amp;15运算后的结果是</h3><h3 id="TCP-IP协议栈-说的越多越好"><a href="#TCP-IP协议栈-说的越多越好" class="headerlink" title="TCP/IP协议栈(说的越多越好)"></a>TCP/IP协议栈(说的越多越好)</h3><p>那为什么要叫TCP/IP协议栈内，这些协议和栈有什么关系呢，大家应该都知道栈是一种先进后出的数据结构，那这和TCP/IP协议有什么关系呢？我们就拿一个HTTP报文来说吧，HTTP报文属于应用层协议的报文，我们输入网址，首先会调用到DNS协议（域名协议，后面会讲到），然后把我们输入的网址转换为IP地址，这个IP地址大致就相当于现实生活中每个人的身份证一样，是每个网页唯一的标识，关于IP地址，后续我会详细介绍，IP协议属于网络层的协议。我们先将HTTP报文压入一个栈中（就好像是在分装报文），然后是IP，不对，我们貌似漏了一个传输层啊，别急别介，HTTP报文在传输层用的是TCP协议，好，我们把TCP压入栈中，再讲IP层也压入栈中，至于链路层的话，就用最常见的以太网就OK了，好了，现在我们的栈里面从头至尾依次是以太帧头-IP协议-TCP协议-HTTP协议，然后我们先忽略最底层的物理层，假设这个封装好的栈一样的报文漂洋过海，来到了它的目的地（至于怎么过来的，我们后续也会讲到），当对端收到这个报文以后，也就是我们封装好的这个栈一样的东西以后该怎么办呢？会不会也是先拿HTTP呢？因为这个报文是我们构造的一个栈，所以说它的顺序肯定也是栈，因此拿取的顺序就是以太帧头-IP协议-TCP协议-HTTP协议，发现没，最先被封装入的HTTP报文是最后才被拿出来的，这中间的细节如果能全部掌握，那基本商就算是入门了，关于这部分东西，我会在后面详细介绍，现在有这个概念就可以了。</p><h3 id="二面："><a href="#二面：" class="headerlink" title="二面："></a>二面：</h3><h4 id="说一下你项目中遇到的最大的问题，如何解决的（再次把我毫不相关的科研项目扯了一通）"><a href="#说一下你项目中遇到的最大的问题，如何解决的（再次把我毫不相关的科研项目扯了一通）" class="headerlink" title="说一下你项目中遇到的最大的问题，如何解决的（再次把我毫不相关的科研项目扯了一通）"></a>说一下你项目中遇到的最大的问题，如何解决的（再次把我毫不相关的科研项目扯了一通）</h4><p>堆和栈 </p><h3 id="const和define的区别"><a href="#const和define的区别" class="headerlink" title="const和define的区别"></a>const和define的区别</h3><h3 id="Linux用过吗"><a href="#Linux用过吗" class="headerlink" title="Linux用过吗"></a>Linux用过吗</h3><h4 id="一个文件里面有很多ip地址，如何用grep命令查看出现次数最多的三个？用awk呢？"><a href="#一个文件里面有很多ip地址，如何用grep命令查看出现次数最多的三个？用awk呢？" class="headerlink" title="一个文件里面有很多ip地址，如何用grep命令查看出现次数最多的三个？用awk呢？"></a>一个文件里面有很多ip地址，如何用grep命令查看出现次数最多的三个？用awk呢？</h4><p>awk  wk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><p>awk ‘BEGIN{ commands } pattern{ commands } END{ commands }’</p><ul><li><p>第一步：运行BEGIN{ commands }语句块中的语句。</p></li><li><p>第二步：从文件或标准输入(stdin)读取一行。然后运行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行反复这个过程。直到文件所有被读取完成。</p></li><li><p>第三步：当读至输入流末尾时，运行END{ commands }语句块。</p></li></ul><p>BEGIN语句块在awk開始从输入流中读取行之前被运行，这是一个可选的语句块，比方变量初始化、打印输出表格的表头等语句通常能够写在BEGIN语句块中。</p><p>END语句块在awk从输入流中读取全然部的行之后即被运行。比方打印全部行的分析结果这类信息汇总都是在END语句块中完毕，它也是一个可选语句块。</p><p>可用awk来统计固定格式日志里的一些数据，如日志中出现过所有不同的IP</p><p>awk ‘{i=$1;count[i]++}END{for(i in count)print(i,count[i])}’ /var/log/httpd/access_log</p><p>awk对文件进行流处理，每次读取一行。$1就是IP，count[i]++是将IP作为一个数组的下标，并且使得统计这个IP所对应的数组元素自增</p><p>也可以用来找出访问次数最多的ip。</p><p>awk ‘{a[$1] += 1;} END {for (i in a) printf(“%d %s\n”, a[i], i);}’ 日志文件 | sort -n | tail -n 10 <strong>#用tail显示最后10行</strong></p><p>有一个文件ip.txt，每行一条ip记录，共若干行，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？</p><p>sort ip.txt | uniq -c | sort -rn | head -n 3</p><p>root用户如何修改文件的所属人？谈到了chmod命令 </p><p>chmod作用：修改文件、目录的权限</p><p>有两种方式修改权限</p><p>（1）+ 、-、= 变更权限 </p><p> u：所有者 g:所在组 o：其他组 a：所有人(u、g、o的总和) </p><p>① chmod  u=rwx, g=rx, o=x  文件目录名 </p><p>② chmod  o+w  文件目录名 给其他组的用户增加写的权限</p><p>③ chmod  a-x   文件目录名 给所有人去掉可执行文件的权限</p><h3 id="算法题：-1"><a href="#算法题：-1" class="headerlink" title="算法题："></a>算法题：</h3><p>面试官说有一道简单的，一道难一点的，让我自己选择，因为前面linux命令那块答得不太好，就选了难的那道 </p><p>给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于”niuniu”<br>子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niuniuString</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于"niuniu"</span></span><br><span class="line"><span class="comment">     * 子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"yrabbbit"</span>;</span><br><span class="line">        String str2 = <span class="string">"rabbit"</span>;</span><br><span class="line">        <span class="keyword">int</span> i = numDistinct(str, str2);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S==<span class="keyword">null</span>&amp;&amp;T==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(S==<span class="keyword">null</span>&amp;&amp;T!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(S!=<span class="keyword">null</span>&amp;&amp;T==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][]dp=<span class="keyword">new</span> <span class="keyword">int</span>[S.length()+<span class="number">1</span>][T.length()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T.length();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=T.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i-<span class="number">1</span>)!=T.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[S.length()][T.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求子串的长度算法"><a href="#求子串的长度算法" class="headerlink" title="求子串的长度算法"></a>求子串的长度算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"vrabbbit"</span>;</span><br><span class="line">        String str2 = <span class="string">"rabbit"</span>;</span><br><span class="line">        <span class="keyword">int</span> i = childString(str, str2);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">childString</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> &amp;&amp; s2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> &amp;&amp; s2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()+<span class="number">1</span>][s2.length()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(result[i][j]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; result[<span class="number">1</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    result[i][j] = result[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (result[i][j - <span class="number">1</span>] &gt;= result[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                        result[i][j] = result[i][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        result[i][j] = result[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、linux命令（我平时不太用linux就只知道哪些情况用什么命令但是具体参数不太知道；问了查找文件里关键词最多的怎么查，还有查找进程名为live的进程等等"><a href="#3、linux命令（我平时不太用linux就只知道哪些情况用什么命令但是具体参数不太知道；问了查找文件里关键词最多的怎么查，还有查找进程名为live的进程等等" class="headerlink" title="3、linux命令（我平时不太用linux就只知道哪些情况用什么命令但是具体参数不太知道；问了查找文件里关键词最多的怎么查，还有查找进程名为live的进程等等"></a>3、linux命令（我平时不太用linux就只知道哪些情况用什么命令但是具体参数不太知道；问了查找文件里关键词最多的怎么查，还有查找进程名为live的进程等等</h3><p>grep -count 文件名称   | tail 10</p><h3 id="4、数据库查找stu表内名字为lily，住址包含北京的信息，按年龄降序排序；我开始是select-然后要求只查住址列怎么办？然后问我修改包含北京的列里北京两个字为上海怎么办（replace我没用过…"><a href="#4、数据库查找stu表内名字为lily，住址包含北京的信息，按年龄降序排序；我开始是select-然后要求只查住址列怎么办？然后问我修改包含北京的列里北京两个字为上海怎么办（replace我没用过…" class="headerlink" title="4、数据库查找stu表内名字为lily，住址包含北京的信息，按年龄降序排序；我开始是select *然后要求只查住址列怎么办？然后问我修改包含北京的列里北京两个字为上海怎么办（replace我没用过…"></a>4、数据库查找stu表内名字为lily，住址包含北京的信息，按年龄降序排序；我开始是select *然后要求只查住址列怎么办？然后问我修改包含北京的列里北京两个字为上海怎么办（replace我没用过…</h3><h3 id="int和Integer的区别，为什么有了int还需要Integer"><a href="#int和Integer的区别，为什么有了int还需要Integer" class="headerlink" title="int和Integer的区别，为什么有了int还需要Integer"></a>int和Integer的区别，为什么有了int还需要Integer</h3><h3 id="ArrayList和LinkedList区别，各有什么特点"><a href="#ArrayList和LinkedList区别，各有什么特点" class="headerlink" title="ArrayList和LinkedList区别，各有什么特点"></a>ArrayList和LinkedList区别，各有什么特点</h3><h3 id="进程和线程的区别，联系"><a href="#进程和线程的区别，联系" class="headerlink" title="进程和线程的区别，联系"></a>进程和线程的区别，联系</h3><h3 id="多线程编程，死锁检测与预防，死锁的检测手段，怎样避免死锁"><a href="#多线程编程，死锁检测与预防，死锁的检测手段，怎样避免死锁" class="headerlink" title="多线程编程，死锁检测与预防，死锁的检测手段，怎样避免死锁"></a>多线程编程，死锁检测与预防，死锁的检测手段，怎样避免死锁</h3><h3 id="讲一讲线程池，讲讲为什么很多公司对于线程池的使用非常谨慎"><a href="#讲一讲线程池，讲讲为什么很多公司对于线程池的使用非常谨慎" class="headerlink" title="讲一讲线程池，讲讲为什么很多公司对于线程池的使用非常谨慎"></a>讲一讲线程池，讲讲为什么很多公司对于线程池的使用非常谨慎</h3><h3 id="SQL代码书写：有一个学生信息表包含id，学号，选修课程和该课程的成绩，写一个SQL语句来查找总分最高的前十名同学。"><a href="#SQL代码书写：有一个学生信息表包含id，学号，选修课程和该课程的成绩，写一个SQL语句来查找总分最高的前十名同学。" class="headerlink" title="SQL代码书写：有一个学生信息表包含id，学号，选修课程和该课程的成绩，写一个SQL语句来查找总分最高的前十名同学。"></a>SQL代码书写：有一个学生信息表包含id，学号，选修课程和该课程的成绩，写一个SQL语句来查找总分最高的前十名同学。</h3><h3 id="建表过程中索引添加的规范"><a href="#建表过程中索引添加的规范" class="headerlink" title="建表过程中索引添加的规范"></a>建表过程中索引添加的规范</h3><h3 id="InnoDB的4种事务隔离级别"><a href="#InnoDB的4种事务隔离级别" class="headerlink" title="InnoDB的4种事务隔离级别"></a>InnoDB的4种事务隔离级别</h3><h3 id="SSM和Spring-Boot的比较，Spring-Boot的缺点-没答上来，面试官的解释是Spring-Boot封装层数过多导致的性能问题"><a href="#SSM和Spring-Boot的比较，Spring-Boot的缺点-没答上来，面试官的解释是Spring-Boot封装层数过多导致的性能问题" class="headerlink" title="SSM和Spring Boot的比较，Spring Boot的缺点(没答上来，面试官的解释是Spring Boot封装层数过多导致的性能问题)"></a>SSM和Spring Boot的比较，Spring Boot的缺点(没答上来，面试官的解释是Spring Boot封装层数过多导致的性能问题)</h3><h3 id="假如有10亿个手机号，怎么样快速判断一个手机号是否在其中-一开始没什么好的思路，面试官一步一步从hash，二分，布隆过滤器引导到位图"><a href="#假如有10亿个手机号，怎么样快速判断一个手机号是否在其中-一开始没什么好的思路，面试官一步一步从hash，二分，布隆过滤器引导到位图" class="headerlink" title="假如有10亿个手机号，怎么样快速判断一个手机号是否在其中(一开始没什么好的思路，面试官一步一步从hash，二分，布隆过滤器引导到位图)"></a>假如有10亿个手机号，怎么样快速判断一个手机号是否在其中(一开始没什么好的思路，面试官一步一步从hash，二分，布隆过滤器引导到位图)</h3><h3 id="机智题：烧完一整根香需要30分钟，怎么样得到15分钟的计时，怎么样得到7-5分钟的计时"><a href="#机智题：烧完一整根香需要30分钟，怎么样得到15分钟的计时，怎么样得到7-5分钟的计时" class="headerlink" title="机智题：烧完一整根香需要30分钟，怎么样得到15分钟的计时，怎么样得到7.5分钟的计时"></a>机智题：烧完一整根香需要30分钟，怎么样得到15分钟的计时，怎么样得到7.5分钟的计时</h3><h3 id="算法题：把数组中奇数放在前面，偶数放在后面，并且奇数偶数都要保证从小到大，要求空间复杂度O-1"><a href="#算法题：把数组中奇数放在前面，偶数放在后面，并且奇数偶数都要保证从小到大，要求空间复杂度O-1" class="headerlink" title="算法题：把数组中奇数放在前面，偶数放在后面，并且奇数偶数都要保证从小到大，要求空间复杂度O(1)"></a>算法题：把数组中奇数放在前面，偶数放在后面，并且奇数偶数都要保证从小到大，要求空间复杂度O(1)</h3><h3 id="MySQL索引结构，说说B树和B-树的区别"><a href="#MySQL索引结构，说说B树和B-树的区别" class="headerlink" title="MySQL索引结构，说说B树和B+树的区别"></a>MySQL索引结构，说说B树和B+树的区别</h3><h3 id="MySQL索引什么时候失效，联合索引，聚集索引"><a href="#MySQL索引什么时候失效，联合索引，聚集索引" class="headerlink" title="MySQL索引什么时候失效，联合索引，聚集索引"></a>MySQL索引什么时候失效，联合索引，聚集索引</h3><h3 id="聚集索引："><a href="#聚集索引：" class="headerlink" title="聚集索引："></a>聚集索引：</h3><p>聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。聚集索引的叶子节点称为数据页，每个数据页通过一个双向链表来进行链接，而且数据页按照主键的顺序进行排列。</p><h2 id="辅助索引："><a href="#辅助索引：" class="headerlink" title="辅助索引："></a>辅助索引：</h2><p>辅助索引(二级索引)：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。</p><p>覆盖索引：</p><p>当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。</p><h4 id="写一个单例模式"><a href="#写一个单例模式" class="headerlink" title="写一个单例模式"></a>写一个单例模式</h4><p>Redis数据结构，场景题</p><p>讲讲Java的堆内存、GC</p><p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存，有着不同的作用。栈内存用来存储局部变量和方法调用。<br>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。<br>而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p><p>引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，<strong><em>\</em>数**</strong>组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p><h3 id="说说抽象类和接口的区别"><a href="#说说抽象类和接口的区别" class="headerlink" title="说说抽象类和接口的区别"></a>说说抽象类和接口的区别</h3><ul><li><p>相同点：都不能被实例化</p></li><li><p>区别一，两者表达的概念不一样。抽象类是一类事物的高度聚合，那么对于继承抽象类的子类来说，对于抽象类来说，属于“是”的关系；而接口是定义行为规范，因此对于实现接口的子类来说，相对于接口来说，是“行为需要按照接口来完成”。</p></li></ul><ul><li>区别二，抽象类在定义类型方法的时候，可以给出方法的实现部分，也可以不给出；而对于接口来说，其中所定义的方法都不能给出实现部分。</li></ul><ul><li>区别三，继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，可以不用重写，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中必须要给出相应的方法和属性实现。</li></ul><ul><li>区别四，在抽象类中，新增一个方法的话，继承类中可以不用作任何处理；而对于接口来说，则需要修改继承类，提供新定义的方法。</li></ul><p>写程序。排序。要求奇数放到前面，偶数放到后面(空间复杂度o(1)) </p><p>一次http请求过程发生了什么 </p><p>springmvc处理过程(http请求服务端发生了那些) </p><p>（1）我们应该都知道在启动一个Spring MVC项目的时候，我们要在web.xml配置文件中声明DispatcherServlet。如下图的web.xml所示，这个Servlet监听的URL是*模式，这意味着所有的请求都能通过DispatcherServlet。</p><p>URL匹配模式是非常重要的，如果请求符合DispatcherServlet配置的URL模式,那么这个请求就会被处理，否则就不会。DispatcherServlet根据URL请求的地址把请求传给指定的controller。那么DispatcherServlet是如何知道请求要传给哪个controller的呢？ </p><p>使用@RequestMapping注解或者Spring MVC配置文件，可以找到URL请求的controller。当然也可以用特定的请求注解，比如@GetMapping或PostMapping。controller文件必须使用@Controller或@RestController(Restful风格)注解进行标记。</p><p>最后，总结一下Spring MVC处理HTTP请求的过程 </p><p>1.客户端发送HTTP请求到指定的URL。 </p><p>2.Spring MVC的DispatcherServlet接收到请求 </p><p>3.DispatcherServlet把请求传到用@Controller和@RequestMapping注解的controller </p><p>4.Spring MVC返回逻辑视图的名称和模型给DispatcherServlet </p><p>5.DispatcherServlet咨询视图处理器直到有实际的视图来展示数据为止 </p><p>6.DispatcherServlet使用模型数据联系所选的视图，例如Thymeleaf,Freemarker,JSP,并根据数据模型呈现输出。 </p><p>7.呈现的输出作为响应返回给客户端 </p><p>以上就是Spring MVC的工作流程或者说Spring MVC处理HTTP请求的过程。</p><p>mybatis执行过程，原理 </p><p>怎么转换成html了。(没怎么写过前端，都是传json数据) </p><p>为什么握手是三次 </p><p>数据库索引用的什么结构。b 树比b树有什么优势 </p><p>最左前缀(数据库自己的优化) </p><p>单例模式 </p><p>session和cookie </p><p>JAVA垃圾回收 </p><p>二面 </p><p>分享一个你觉得比较有的讲得实习经历(五分钟) </p><p>怼项目(十分钟) </p><p>JAVA是自学的还是开的课程 </p><p>学习JAVA你怎么学习的 </p><p>JAVA虚拟机内存模型 </p><p>syn和lock </p><p>可重入锁实现原理</p><p>事务用来做什么 </p><p>lru </p><p>网络方面TCP断开time_wait(什么时候进入这种状态，为什么要有这种状态) </p><p>快排 </p><p>对工作的方向对语言有要求吗 </p><p>看你学JAVA很多，是因为这方面需求比较大吗 </p><p>平时得工作环境在Linux吗</p><p>统计某个字符串的行数统计用什么命令 </p><p>Grep -count “字符串” 文件名称</p><p>统计某个文件的行数</p><p>Wc 文件名   显示行数  字数  字节数</p><p>有什么要问我的吗？</p><p>MYSQL日志分为几种</p><p>如何保证回滚</p><p>数据库中事务到底是mvcc回滚还是日志回滚<br>socket有几种状态<br>mysql更新了数据日志文件有什么改变<br>它的意思是服务器崩了，你访问服务器应该是什么样<br>服务器崩了发送什么错误码，崩了情况下500是谁发的<br>开发环境和生产环境不一样，配置环境应该有什么不同配置数据库<br>ACID<br>死锁以及解决措施<br>rabbitmq中各种模式<br>堆栈区别<br>GC回收算法<br>点击按钮这个过程详解一下</p><p>算法题：<br>长字符串相加<br>nums[] = {1,-1,0,2,-2,1,3} 找到所有不重复a + b + c = 0</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h2&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试，作业帮" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E4%BD%9C%E4%B8%9A%E5%B8%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java常见面试题整理</title>
    <link href="http://yoursite.com/2020/06/09/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/09/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2020-06-09T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.708Z</updated>
    
    <content type="html"><![CDATA[ <a id="more"></a><h2 id="java相关："><a href="#java相关：" class="headerlink" title="java相关："></a>java相关：</h2><h3 id="Java中线程安全的集合类？"><a href="#Java中线程安全的集合类？" class="headerlink" title="Java中线程安全的集合类？"></a>Java中线程安全的集合类？</h3><p>java中的线程安全是什么：</p><p>就是线程同步的意思，就是当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问</p><p>什么叫线程安全：</p><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 </p><p>或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。</p><p>线程安全问题都是由全局变量及静态变量引起的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</p><p>看过vector源码的同学就会知道他的许多操作都是加了synchronized修饰的比如他的添加元素。</p><p>而HashMap的所有操作都没有加synchronized修饰 </p><h3 id="HashMap和hashtable的区别？"><a href="#HashMap和hashtable的区别？" class="headerlink" title="HashMap和hashtable的区别？"></a>HashMap和hashtable的区别？</h3><p>（1）HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p><p> HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。</p><h5 id="HashMap存数据的过程是："><a href="#HashMap存数据的过程是：" class="headerlink" title="HashMap存数据的过程是："></a>HashMap存数据的过程是：</h5><p>   HashMap内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。</p><p>   HashMap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。</p><p> Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</p><p>Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。</p><p>   Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</p><h6 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h6><p>hashtable是线程安全的，hashMap是非线程安全的集合类</p><p>Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。</p><p>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p><h3 id="3-Java继承中子类父类函数的调用问题？"><a href="#3-Java继承中子类父类函数的调用问题？" class="headerlink" title="3.Java继承中子类父类函数的调用问题？"></a>3.Java继承中子类父类函数的调用问题？</h3><p>在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。</p><h3 id="4-类和对象的区别-？-请说明类和对象的区别"><a href="#4-类和对象的区别-？-请说明类和对象的区别" class="headerlink" title="4. 类和对象的区别**  **？****请说明类和对象的区别****"></a>4. 类和对象的区别*<strong>*  *</strong>*？*<strong>**</strong>*请说明类和对象的区别****</h3><p>类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。</p><p>对象是具有类类型的变量。类和对象是面向对象编程技术中的最基本的概念。</p><p>类是一个静态的概念，类本身不携带任何数据。当没有为类创建任何数据时，类本身不存在于内存空间  </p><p>对象是一个动e68a847a6431333366306464态的概念，每一个对象都存在着有别于其它对象的属于自己的独特的属性和行为，属性可以随着它自己的行为而发生改变。</p><h3 id="5-Overload和Override的区别。Overloaded的方法是否可…"><a href="#5-Overload和Override的区别。Overloaded的方法是否可…" class="headerlink" title="5. Overload和Override的区别。Overloaded的方法是否可…"></a>5. Overload和Override的区别。Overloaded的方法是否可…</h3><p><strong><em>\</em>请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?**</strong></p><p>Overload是重载的意思，Override是覆盖的意思，也就是重写。</p><p>重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p><p>重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。</p><h3 id="6-用两个栈实现队列-？-用两个栈来实现一个队列，完成队列的Push和Pop操作。-队列中的元素为int类型。"><a href="#6-用两个栈实现队列-？-用两个栈来实现一个队列，完成队列的Push和Pop操作。-队列中的元素为int类型。" class="headerlink" title="6. 用两个栈实现队列****？****用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。"></a>6. 用两个栈实现队列*<strong>**</strong>*？*<strong>**</strong>*用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> niu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doubleStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先写入栈函数，如果想往栈中放入什么函数，直接调用放入函数就可以了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        stack1.push(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写出栈函数，因为是两个栈，所以入栈stack1之后，如果要出栈，就需要借助stack2,</span></span><br><span class="line">    <span class="comment">//先把数值从stack1中出栈放入stack2中</span></span><br><span class="line">    <span class="keyword">int</span> result =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.empty()) &#123;</span><br><span class="line">            result = stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果栈2为空，就需要把数据一个一个取出来先放入栈2中</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                temp = stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重新取出栈2中的值</span></span><br><span class="line">            <span class="keyword">if</span> (!stack2.empty()) &#123;</span><br><span class="line">                result = stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-介绍一下volatile？请你介绍一下volatile？"><a href="#7-介绍一下volatile？请你介绍一下volatile？" class="headerlink" title="# 7. 介绍一下volatile？请你介绍一下volatile？"></a># 7. 介绍一下volatile？请你介绍一下volatile？</h2><p>volatile作为java中的关键词之一，用以声明变量的值可能随时会别的线程修改，使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。volatile会禁止指令重排 volatile具有可见性、有序性，不具备原子性。 注意，volatile不具备原子性，这是volatile与java中的synchronized、java.util.concurrent.locks.Lock最大的功能差异</p><h3 id="8-编程题"><a href="#8-编程题" class="headerlink" title="8. 编程题"></a>8. 编程题</h3><p>栈的压入、弹出序列</p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="9-GCRoot可以是哪些-请问GC-Root可以是哪些？"><a href="#9-GCRoot可以是哪些-请问GC-Root可以是哪些？" class="headerlink" title="9. GCRoot可以是哪些** **请问GC Root可以是哪些？"></a>9. GCRoot可以是哪些*<strong>* *</strong>*请问GC Root可以是哪些？</h3><p>GcRoot是垃圾回收器算法中判断一个对象是否可以回收的一种算法。</p><p>就是对象到达GcRoot的路径是否还有可达，即是否有可引用链，如果有，这表明对象还存在着引用，如果没有，则表明该对象没有引用，在下一次垃圾回收时就会被回收</p><p>GcRoot的种类</p><p>（1）虚拟机栈：栈帧中的本地变量表引用的对象</p><p>（2）native方法引用的对象</p><p>（3）方法区中的静态变量和常量引用的对象</p><h3 id="10-编程题：-二叉树的深度-？-输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。"><a href="#10-编程题：-二叉树的深度-？-输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。" class="headerlink" title="10. 编程题：****二叉树的深度****？****输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。"></a>10. 编程题：*<strong>**</strong>*二叉树的深度*<strong>**</strong>*？*<strong>**</strong>*输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> leftDepth = TreeDepth(root.left);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> rightDepth = TreeDepth(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span>+((leftDepth&gt;rightDepth)?leftDepth:rightDepth);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-springIOC原理？自己实现IOC要怎么做，哪些步骤？"><a href="#11-springIOC原理？自己实现IOC要怎么做，哪些步骤？" class="headerlink" title="11. springIOC原理？自己实现IOC要怎么做，哪些步骤？"></a>11. springIOC原理？自己实现IOC要怎么做，哪些步骤？</h2><p><strong><em>\</em>请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？**</strong></p><h3 id="12-JDK和JRE有什么区别？"><a href="#12-JDK和JRE有什么区别？" class="headerlink" title="12. JDK和JRE有什么区别？"></a>12. JDK和JRE有什么区别？</h3><p>JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</p><p>JRE,是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><p>JVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><h3 id="13-和equels有什么区别？"><a href="#13-和equels有什么区别？" class="headerlink" title="13. . ==和equels有什么区别？"></a>13. . ==和equels有什么区别？</h3><p>equals源自于Object类，Object中equals方法默认比较的内容还是==比较的结果。</p><p>如果没有重写equals的话，equals和==是一样的。都是比较内存地址。</p><h3 id="14-说说final在java中的作用？"><a href="#14-说说final在java中的作用？" class="headerlink" title="14. 说说final在java中的作用？"></a>14. 说说final在java中的作用？</h3><p>final关键字可以用来修饰引用、方法、和类。</p><p>（1）如果修饰的引用为基本数据类型，则该引用为常量，该值无法修改</p><p>（2）如果修饰的引用为引用数据类型，比如对象、数组、则该对象、数组本身可以修改，但是指向该对象或者数组的地址的引用不能修改。</p><p>（3）如果引用是类的成员变量，则必须当场赋值，否则编译会报错。</p><p>当用final修饰一个方法的时候，当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p><p>当使用final修饰一个类的时候，当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。</p><h3 id="15-String类的常用方法有哪些"><a href="#15-String类的常用方法有哪些" class="headerlink" title="15.String类的常用方法有哪些?"></a>15.String类的常用方法有哪些?</h3><p>（1）equals：字符串是否相同</p><p>（2）indexof：目标字符或者是目标字符串在源字符串中的位置下标</p><p>（3）valueOf：其他类型转字符串</p><p>（4）isEmpty：字符串的长度是否为零</p><p>（5）contains：是否包含目标字符串</p><h3 id="16-java中操作字符串的类有哪些？他们之间有什么区别？"><a href="#16-java中操作字符串的类有哪些？他们之间有什么区别？" class="headerlink" title="16. java中操作字符串的类有哪些？他们之间有什么区别？"></a>16. java中操作字符串的类有哪些？他们之间有什么区别？</h3><p>（1）String</p><p>（2）StringBuilder</p><p>（3）StringBuffer</p><p>从类的继承关系上来开的话,String和StringBuffer,StringBuilder是没有任何关系的,但是StringBuffer和StringBuilder的继承关系时一样的。</p><p>java中操作字符串的类,我知道的有三个类,分别是String,StringBuffer和StringBuilder.这三个类都是以char[]的形式保存的字符串,但是String类型的字符串是不可变的,对String类型的字符床做修改操作都是相当于重新创建对象.而对StringBuffer和StringBuilder进行增删操作都是对同一个对象做操作.StringBuffer中的方法大部分都使用synchronized关键字修饰,所以StringBuffer是线程安全的,StringBuilder中的方法则没有,线程不安全,但是StringBuilder因为没有使用使用synchronized关键字修饰,所以性能更高,在单线程环境下我会选择使用StringBuilder,多线程环境下使用StringBuffer.如果生命的这个字符串几乎不做修改操作,那么我就直接使用String,因为不调用new关键字声明String类型的变量的话它不会在堆内存中创建对象,直接指向String的常量池,并且可以复用.效率更高</p><h3 id="17-如何将字符串反转？"><a href="#17-如何将字符串反转？" class="headerlink" title="17. 如何将字符串反转？"></a>17. 如何将字符串反转？</h3><p>使用StringBuffer或者StringBuilder中的reverse()方法。</p><h3 id="18-普通类和抽象类有什么区别？"><a href="#18-普通类和抽象类有什么区别？" class="headerlink" title="18. . 普通类和抽象类有什么区别？"></a>18. . 普通类和抽象类有什么区别？</h3><p>（1）抽象类不能被实例化</p><p>（2）抽象类可以有抽象方法，抽象方法只需申明，无需实现</p><p>（3）含有抽象方法的类必须申明为抽象类</p><p>（4）抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类</p><p>（5）抽象方法不能被声明为静态</p><p>（6）抽象方法不能用 private 修饰</p><p>（7）抽象方法不能用 final 修饰</p><h3 id="19-接口和抽象类有什么区别？"><a href="#19-接口和抽象类有什么区别？" class="headerlink" title="19. 接口和抽象类有什么区别？"></a>19. 接口和抽象类有什么区别？</h3><p>他们都不能实例化对象，都可以包含抽象方法，而且抽象方法必须被继承的类全部实现。</p><p>区别：</p><p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p><p>2、抽象类要被子类继承，接口要被类实现。</p><p>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</p><p>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p><p>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p><p>6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果</p><p>7、抽象类里可以没有抽象方法</p><p>8、如果一个类里有抽象方法，那么这个类只能是抽象类</p><p>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。</p><p>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p><h3 id="20-java中的IO流分为几种？"><a href="#20-java中的IO流分为几种？" class="headerlink" title="20.  java中的IO流分为几种？"></a>20.  java中的IO流分为几种？</h3><p>java 中 IO 流分为几种?</p><p>按照流的流向分，可以分为输入流和输出流；</p><p>按照操作单元划分，可以划分为字节流和字符流；</p><p>按照流的角色划分为节点流和处理流。</p><h3 id="21-List-Set-Map-之间有什么区别？"><a href="#21-List-Set-Map-之间有什么区别？" class="headerlink" title="21. List Set  Map 之间有什么区别？"></a>21. List Set  Map 之间有什么区别？</h3><p>List和set是实现了collection接口的</p><h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><ul><li><p>1.可以允许重复的对象。</p></li><li><p>2.可以插入多个null元素。</p></li><li><p>3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。</p></li><li><p>4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p></li></ul><h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><ul><li>1.不允许重复对象</li><li>无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator  或者 Comparable 维护了一个排序顺序。</li><li>只允许一个 null 元素</li><li>Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</li></ul><h4 id="Map："><a href="#Map：" class="headerlink" title="Map："></a>Map：</h4><ul><li><ol><li>Map不是collection的子接口或者实现类。Map是一个接口。</li><li>Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</li><li>TreeMap 也通过 Comparator  或者 Comparable 维护了一个排序顺序。</li><li>Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</li><li>5.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</li></ol></li></ul><h4 id="什么场景下使用list，set，map呢？"><a href="#什么场景下使用list，set，map呢？" class="headerlink" title="什么场景下使用list，set，map呢？"></a>什么场景下使用list，set，map呢？</h4><p>（为什么这里要用list、或者set、map，这里回答它们的优缺点就可以了）</p><ul><li><p>（1）如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。</p></li><li><p>（2）如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。</p></li><li><p>（3）如果你想保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。</p></li><li><p>（4）如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。</p></li></ul><h3 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1.JDK和JRE有什么区别？"></a>1.JDK和JRE有什么区别？</h3><p>JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</p><p>JRE,是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><p>JVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><h3 id="和equels有什么区别？"><a href="#和equels有什么区别？" class="headerlink" title="==和equels有什么区别？****"></a>==和equels有什么区别？****</h3><p>equals源自于Object类，Object中equals方法默认比较的内容还是==比较的结果。</p><p>如果没有重写equals的话，equals和==是一样的。都是比较内存地址。</p><h3 id="说说final在java中的作用？"><a href="#说说final在java中的作用？" class="headerlink" title="说说final在java中的作用？"></a>说说final在java中的作用？</h3><p>final关键字可以用来修饰引用、方法、和类。</p><ul><li><p>（1）如果修饰的引用为基本数据类型，则该引用为常量，该值无法修改</p></li><li><p>（2）如果修饰的引用为引用数据类型，比如对象、数组、则该对象、数组本身可以修改，但是指向该对象或者数组的地址的引用不能修改。</p></li><li><p>（3）如果引用是类的成员变量，则必须当场赋值，否则编译会报错。</p></li></ul><p>当用final修饰一个方法的时候，当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p><ul><li>当使用final修饰一个类的时候，当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。</li></ul><h3 id="4-String类的常用方法有哪些"><a href="#4-String类的常用方法有哪些" class="headerlink" title="4. String类的常用方法有哪些?"></a>4. String类的常用方法有哪些?</h3><ul><li><p>（1）equals：字符串是否相同</p></li><li><p>（2）indexof：目标字符或者是目标字符串在源字符串中的位置下标</p></li><li><p>（3）valueOf：其他类型转字符串</p></li><li><p>（4）isEmpty：字符串的长度是否为零</p></li><li><p>（5）contains：是否包含目标字符串</p></li></ul><h3 id="5-java中操作字符串的类有哪些？他们之间有什么区别？"><a href="#5-java中操作字符串的类有哪些？他们之间有什么区别？" class="headerlink" title="5. java中操作字符串的类有哪些？他们之间有什么区别？"></a>5. java中操作字符串的类有哪些？他们之间有什么区别？</h3><p>（1）String</p><p>（2）StringBuilder</p><p>（3）StringBuffer</p><p>从类的继承关系上来开的话,String和StringBuffer,StringBuilder是没有任何关系的,但是StringBuffer和StringBuilder的继承关系时一样的。</p><p>java中操作字符串的类,我知道的有三个类,分别是String,StringBuffer和StringBuilder.这三个类都是以char[]的形式保存的字符串,但是String类型的字符串是不可变的,对String类型的字符床做修改操作都是相当于重新创建对象.而对StringBuffer和StringBuilder进行增删操作都是对同一个对象做操作.StringBuffer中的方法大部分都使用synchronized关键字修饰,所以StringBuffer是线程安全的,StringBuilder中的方法则没有,线程不安全,但是StringBuilder因为没有使用使用synchronized关键字修饰,所以性能更高,在单线程环境下我会选择使用StringBuilder,多线程环境下使用StringBuffer.如果生命的这个字符串几乎不做修改操作,那么我就直接使用String,因为不调用new关键字声明String类型的变量的话它不会在堆内存中创建对象,直接指向String的常量池,并且可以复用.效率更高</p><h3 id="6-如何将字符串反转？"><a href="#6-如何将字符串反转？" class="headerlink" title="6. 如何将字符串反转？"></a>6. 如何将字符串反转？</h3><p>使用StringBuffer或者StringBuilder中的reverse()方法。</p><h3 id="7-普通类和抽象类有什么区别？"><a href="#7-普通类和抽象类有什么区别？" class="headerlink" title="7. 普通类和抽象类有什么区别？"></a>7. 普通类和抽象类有什么区别？</h3><p>（1）抽象类不能被实例化</p><p>（2）抽象类可以有抽象方法，抽象方法只需申明，无需实现</p><p>（3）含有抽象方法的类必须申明为抽象类</p><p>（4）抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类</p><p>（5）抽象方法不能被声明为静态</p><p>（6）抽象方法不能用 private 修饰</p><p>（7）抽象方法不能用 final 修饰</p><h3 id="8-接口和抽象类有什么区别？"><a href="#8-接口和抽象类有什么区别？" class="headerlink" title="8. 接口和抽象类有什么区别？"></a>8. 接口和抽象类有什么区别？</h3><h3 id="9-java中的IO流分为几种？"><a href="#9-java中的IO流分为几种？" class="headerlink" title="9. java中的IO流分为几种？"></a>9. java中的IO流分为几种？</h3><h3 id="10-List-Set-Map-之间有什么区别？"><a href="#10-List-Set-Map-之间有什么区别？" class="headerlink" title="10. List Set  Map 之间有什么区别？"></a>10. List Set  Map 之间有什么区别？</h3><h3 id="11-java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？"><a href="#11-java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？" class="headerlink" title="11. java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？\"></a>11. java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？\</h3><p>byte：8位 一个字节 </p><p>int：32位 四个字节 </p><p>long：64位 八个字节 </p><p>char：16位 两个字节 </p><p>float:32位 四个字节 </p><p>double：64位 八个字节 </p><p>boolean：8位 一个字节</p><h3 id="12-下面哪个不属于HttpServletResponse接口完成的功能？"><a href="#12-下面哪个不属于HttpServletResponse接口完成的功能？" class="headerlink" title="12. 下面哪个不属于HttpServletResponse接口完成的功能？"></a>12. 下面哪个不属于HttpServletResponse接口完成的功能？</h3><p>HttpServletResponse完成：设置http头标，设置cookie，设置返回数据类型，输出返回数据；读取路径信息是HttpServletRequest做的</p><p>HttpServletResponse 在Servlet中，当服务器响应客户端的一个请求时，就要用到HttpServletResponse接口。</p><p>设置响应的类型可以使用setContentType()方法。发送字符数据，可以使用getWriter()返回一个对象。下表是接口HttpServletResponse的常用方法。 </p><p>接口HttpServletResponse的常用方法 方 法 说 明 </p><p>addCookie(Cookie cookie) 将指定的Cookie加入到当前的响应中 </p><p>addHeader(String name,String value) 将指定的名字和值加入到响应的头信息中 </p><p>containsHeader(String name) 返回一个布尔值，判断响应的头部是否被设置 </p><p>encodeURL(String url) 编码指定的URL </p><p>sendError(int sc) 使用指定状态码发送一个错误到客户端 </p><p>sendRedirect(String location) 发送一个临时的响应到客户端 </p><p>setDateHeader(String name,long date) 将给出的名字和日期设置响应的头部 </p><p>setHeader(String name,String value) 将给出的名字和值设置响应的头部 </p><p>setStatus(int sc) 给当前响应设置状态码 </p>]]></content>
    
    <summary type="html">
    
      
      
         &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;java相关：&quot;&gt;&lt;a href=&quot;#java相关：&quot; class=&quot;headerlink&quot; title=&quot;java相关：&quot;&gt;&lt;/a&gt;java相关：&lt;/h2&gt;&lt;h3 id=&quot;Java中线程安全的集合类？&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mybatis整理</title>
    <link href="http://yoursite.com/2020/06/09/mybatis/"/>
    <id>http://yoursite.com/2020/06/09/mybatis/</id>
    <published>2020-06-09T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-mybatis的入门"><a href="#1-mybatis的入门" class="headerlink" title="1. mybatis的入门"></a>1. mybatis的入门</h2><p>mybatis的环境搭建</p><p>​            第一步：创建maven工程并导入坐标</p><p>​            第二步：创建实体类和dao的接口</p><p>​            第三步：创建Mybatis的主配置文件sqlMapConfig.xml</p><p>​            第四步：创建映射配置文件   IUseDao.xml</p> <a id="more"></a><p>mybatis的文件约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Mybatis的主配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置MySQL的环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置事务的类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据源，连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定映射数据源文件的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"config/userDao/userDao.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们编写IUserDao的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写User的实体类，注意实体类中的属性名称要和数据库中的相同</p><p>编写映射器</p><p>映射的约束文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"lei.study.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"lei.study.domain.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1590024681000.png" alt="1590024681000"></p><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> lei.study.dao.IUserDao;</span><br><span class="line"><span class="keyword">import</span> lei.study.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">"sqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//2.创建SqlSessionFactry工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory sessionFactory = builder.build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用工厂生产SQLSSession对象</span></span><br><span class="line">        SqlSession sqlSession = sessionFactory.openSession();</span><br><span class="line">        <span class="comment">//4. 使用sqlsession创建Dao接口的代理对象</span></span><br><span class="line">        IUserDao userDao = sqlSession.getMapper(IUserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; users = userDao.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上面的代码，我们发现</p><ol><li><p>创建工厂的时候，我们使用了建造者模式  SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();</p><p>SqlSessionFactory sessionFactory = builder.build(is);</p><p>我们只需要往建造者中传入字节流就可以</p><p>构建者模式：把对象的创建细节隐藏，使使用者直接调用方法即可以拿到对象</p></li></ol><ol start="2"><li><p>生产sqlsession使用了工厂模式（解耦）</p><p>SqlSession sqlSession = sessionFactory.openSession();</p></li></ol><ol start="3"><li><p>代理模式</p><p> //4. 使用sqlsession创建Dao接口的代理对象</p><pre><code>IUserDao userDao = sqlSession.getMapper(IUserDao.class);</code></pre><p>优势：就是在不改变源码的基础上对原有方法增强</p></li></ol><p>除了使用上面的xml文件形式的配置，我们还可以使用注解的方式完成数据库的查询操作</p><p>使用注解：</p><p>我们需要在接口中的方法上使用@Select() 注解，指定SQL语句，同时需要在sqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名</p><p>在主配置文件中指定接口全限定类名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指使用注解的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"lei.study.dao.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在接口中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式，不管使用XML还是注解配置，但是mybatis它是支持写dao实现类的。</p><h2 id="2-自定义mybatis框架分析"><a href="#2-自定义mybatis框架分析" class="headerlink" title="2. 自定义mybatis框架分析"></a>2. 自定义mybatis框架分析</h2><p>通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照 </p><p>mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得 </p><p>更为简单，只需要编写一个 mybatis 配置文件就够了。） </p><p>但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还 要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。 这些问题我们在自定义 mybatis 框架进行讲解。 </p><p>请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解 mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有 一个认识。</p><h2 id="mybatis中的连接池"><a href="#mybatis中的连接池" class="headerlink" title="mybatis中的连接池"></a>mybatis中的连接池</h2><ol><li>连接池，我们在实际开发中都会使用连接池，因为它可以减少我们开发的时间。</li></ol><ol start="2"><li>mybatis中的连接池 ：</li></ol><p>​        mybatis连接池提供了3中方式的配置 ：</p><p>​                    配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式</p><p>​                type属性 的取值：</p><p>​                                POOLED：采用传统的javac.sql.DataSource规范中的连接池，mybatis中有针对规范的实现</p><p>​                                UNPOOLED：采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是并没有使用池的思想</p><p>​                                JNDI：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到的DataSource是不一样的。</p><p>​                                        注意：如果不是web或者maven的war工程，是不能使用的，我们使用的是Tomcat服务器，采用的连接池就是dbcp连接池</p><p>​                            </p><h3 id="mybatis中的事务"><a href="#mybatis中的事务" class="headerlink" title="mybatis中的事务"></a>mybatis中的事务</h3><p>什么是事务</p><p>事务的四大特性</p><p>不考虑隔离性会产生的3个问题</p><p>解决办法：四种隔离级别</p><p>mybatis中是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚</p><h2 id="mybatis中的多表查询"><a href="#mybatis中的多表查询" class="headerlink" title="mybatis中的多表查询"></a>mybatis中的多表查询</h2><p>一对一的查询操作</p><p>我们使用user表和account表关联</p><p>在account表中新建主表属性  private  User  user</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br></pre></td></tr></table></figure><p>在account的配置文件中，我们编写映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"lei.study.dao.IAccountDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"accountMap"</span> <span class="attr">type</span>=<span class="string">"lei.study.domain.Account"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非主键字段的对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">javaType</span>=<span class="string">"lei.study.domain.User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userBirthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userAddress"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAllAccount"</span> <span class="attr">resultMap</span>=<span class="string">"accountMap"</span>&gt;</span></span><br><span class="line">        SELECT u.*,a.id AS aid,a.uid, a.money from account a, user u WHERE u.id = a.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一对多的关系</p><p>一个用户可能关联多张账户表</p><p>在User实体中，新建Account属性集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> Date userBirthday;</span><br><span class="line"><span class="keyword">private</span> String userSex;</span><br><span class="line"><span class="keyword">private</span> String userAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br></pre></td></tr></table></figure><p>UserDao的映射文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"lei.study.dao.IUserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userAccountMap"</span> <span class="attr">type</span>=<span class="string">"lei.study.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"userId"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--非主键字段的对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userBirthday"</span> <span class="attr">column</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">column</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userAddress"</span> <span class="attr">column</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"accounts"</span> <span class="attr">ofType</span>=<span class="string">"lei.study.domain.Account"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"uid"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"money"</span> <span class="attr">column</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultMap</span>=<span class="string">"userAccountMap"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user u LEFT OUTER JOIN account a on u.id = a.uid;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多对多的关系"><a href="#多对多的关系" class="headerlink" title="多对多的关系"></a>多对多的关系</h3><p>​    用户可以有多个角色</p><p>​    一个角色可以赋予多个用户</p><p>​    用户和角色之间是多对多</p><h2 id="1-mybatis中的延迟加载"><a href="#1-mybatis中的延迟加载" class="headerlink" title="1. mybatis中的延迟加载"></a>1. mybatis中的延迟加载</h2><p>什么是延迟加载？</p><p>问题：在一对多中，当我们有一个用户，它有100个账户</p><p>​            在查询用户的时候，要不要把关联的账户查出来</p><p>​            在查询账户的时候，要不要把关联的用户查出来？</p><p>​            </p><p>​        在查询用户时，用户下的账户信息是什么时候使用，什么时候查询的</p><p>​        在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。</p><p><strong>什么是延迟加载</strong>：在真正使用数据时才发起查询，不用的时候不用查询，，按需加载（懒加载）</p><p><strong>什么是立即加载？</strong>：不管用不用，只要一调用方法，马上发起查询</p><p>在对应的四种表关系中：一对一，多对一，一对一，多对多</p><p><strong>一对多，多对多：</strong>通常情况下我们都是采用延迟加载</p><p><strong>多对一，一对一：</strong>通常情况下，我们都是采用立即加载</p><p>我们可以在mybatis全部配置中或者是每个映射器中配置相关的属性信息，然后进行配置。</p><h2 id="2-mybatis中的缓存"><a href="#2-mybatis中的缓存" class="headerlink" title="2. mybatis中的缓存"></a>2. mybatis中的缓存</h2><p>什么是缓存？</p><p>​        存在于内存中的临时数据</p><p>为什么使用缓存</p><p>​        减少和数据库的交互次数，提高执行效率</p><p>什么样的数据使用缓存，什么样的数据不能使用</p><p>​            适用于缓存：</p><p>​                    经常查询，并且不经常改变的</p><p>​                    数据的正确与否对最终结果影响不大的</p><p>​            不适用与缓存：</p><p>​                    经常改变的数据</p><p>​                    数据的正确与否对最终的结果影响很大的</p><p><strong>mybatis中一级缓存和二级缓存</strong></p><p><strong>一级缓存：</strong></p><p>​            它指的是Mybatis中Sqlsession对象的缓存</p><p>​            当我们执行查询之后，查询的结果会同时存入到Sqlsession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用。</p><p>​        当SqlSession对象消失的时候，mybatis的一级缓存也就消失了。</p><p>一级缓存是sqlsession范围的缓存，当调用sqlsession的修改，添加，删除，commit（） close()等方法时，就会清空一级缓存。</p><p><strong>二级缓存：</strong></p><p>​        它指的是mybatis中的sqlsessionFacory对象的缓存，由同一个sqlsessFactory对象创建的SqlSession共享其缓存。</p><p>​        二级缓存的使用步骤：</p><p>​                    第一步：让Mybatis框架支持二级缓存，（在SQlMapConfig.xml中配置）</p><p>​                    第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）</p><p>​                    第三步：让当前的操作支持二级缓存（在select标签中进行相关类的配置）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-mybatis的入门&quot;&gt;&lt;a href=&quot;#1-mybatis的入门&quot; class=&quot;headerlink&quot; title=&quot;1. mybatis的入门&quot;&gt;&lt;/a&gt;1. mybatis的入门&lt;/h2&gt;&lt;p&gt;mybatis的环境搭建&lt;/p&gt;
&lt;p&gt;​            第一步：创建maven工程并导入坐标&lt;/p&gt;
&lt;p&gt;​            第二步：创建实体类和dao的接口&lt;/p&gt;
&lt;p&gt;​            第三步：创建Mybatis的主配置文件sqlMapConfig.xml&lt;/p&gt;
&lt;p&gt;​            第四步：创建映射配置文件   IUseDao.xml&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试，阿里" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>spring整理</title>
    <link href="http://yoursite.com/2020/06/09/spring/"/>
    <id>http://yoursite.com/2020/06/09/spring/</id>
    <published>2020-06-09T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-spring两个核心容器对象的区别"><a href="#1-spring两个核心容器对象的区别" class="headerlink" title="1. spring两个核心容器对象的区别"></a>1. spring两个核心容器对象的区别</h3><ol><li>ApplicationContext</li></ol><p>它在构建核心容器的时候，采用的创建对象的策略是立即加载的方式，也就是说，只要一读取配置文件马上就创建配置文件中配置的对象、</p> <a id="more"></a><ol start="2"><li>BeanFactory</li></ol><p>它在构建核心容器时，创建对象采用的策略是采用延迟加载的方式，也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。</p><h3 id="2-spring对bean的管理细节"><a href="#2-spring对bean的管理细节" class="headerlink" title="2. spring对bean的管理细节"></a>2. spring对bean的管理细节</h3><h4 id="创建bean的三种方式"><a href="#创建bean的三种方式" class="headerlink" title="创建bean的三种方式"></a>创建bean的三种方式</h4><ol><li><p>第一种方式，使用默认构造函数创建</p><p>在spring的配置文件中使用bean标签，配以id 和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此类如果类中没有默认构造函数，则对象无法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这是第一种方式，直接使用默认构造函数的方式进行创建--&gt;</span><br><span class="line">    &lt;!--&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"lei.study.service.impl.userServiceImpl"</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>使用普通工厂中的方法创建对象，（使用某个类中的方法创建对象，并存入spring容器中  ）</li></ol><p>创建需要实例化的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IUserService <span class="title">getUserServiceInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> userServiceImpl();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>spring 容器中进行配置</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="factoryInstance" class="lei.study.factory.factoryInstance"&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean id="userService" factory-bean="factoryInstance" factory-method="getUserServiceInstance"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>（工厂中有可能是一个普通方法还可能是一个静态方法，这是时候使用）使用工厂中的静态方法创建对象，使用某个类中的静态方法创建对象，并存入spring容器中</li></ol><p>静态方法中需要创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">factoryStaticInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUserService <span class="title">getUserServiceInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> userServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--刚才的第二种创建中，可能不是一个普通类，而是一个静态的类--&gt;</span><br><span class="line">    &lt;bean id="userService" class="lei.study.factory.factoryStaticInstance" factory-method="getUserServiceInstance"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-bean对象的作用范围"><a href="#3-bean对象的作用范围" class="headerlink" title="3. bean对象的作用范围"></a>3. bean对象的作用范围</h4><p>&lt;bean标签的作用范围</p><p>bean标签的scope属性：</p><p>作用：用于指定bean的作用范围</p><p>取值：（常用的就是singleton和protopyte）</p><p>singleton：为默认值，是单例的</p><p>protopyte： 多例的</p><p>request：作用于web应用的请求范围</p><p>session：作用于web应用的会话范围</p><p>global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境是作用就是session</p><h4 id="4-bean的生命周期"><a href="#4-bean的生命周期" class="headerlink" title="4. bean的生命周期"></a>4. bean的生命周期</h4><p>当创建对象配置bean标签中的内容的时候，我们 可以指定bean的生命周期，当配置的是单例模式的时候，我们使ApplicationContext创建容器的时候，对象就创建了，当我们关闭对象的时候，对象销毁。</p><p>当配置的是单例模式的时候，我们使BeanFactory创建容器的时候，对象不会创建，只有当我们使用的时候，才会创建对象，，什么时候对象销毁呢，针对多例模式，spring容器不提供销毁对象的方法，把对象的销毁交给java的垃圾回收机制进行回收。</p><p><strong>单例对象：</strong></p><p>出生：当容器创建时，对象出生</p><p>活着：当容器还在，对象一直活着</p><p>死亡：当容器销毁，对象消亡</p><p>总结：单例对象的声明周期和容器相同</p><p><strong>多例对象：</strong></p><p> 出生：当我们使用对象时，spring对象为我们创建</p><p>活着：对象只要是在使用过程中，就一直活着</p><p>死亡：当对象长时间不用，且没有别的对象引用时，由java的垃圾回收器进行回收</p><h3 id="5-spring的依赖注入"><a href="#5-spring的依赖注入" class="headerlink" title="5. spring的依赖注入"></a>5. spring的依赖注入</h3><p>IOC的作用，就是降低程序间的耦合关系，也叫做依赖关系</p><p>依赖关系的管理：以后都交给spring来进行维护</p><p>在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中进行说明。</p><p>依赖关系的维护就称之为依赖注入</p><p>依赖注入：</p><p>能注入的数据，有三类</p><p>（1） 基本类型和string</p><p>（2）其他bean类型（在配置文件中或者是注解中配置过的bean）</p><p>（3）其他类型/集合类型</p><p><strong>依赖注入的方式有三种：</strong></p><p><strong>（1）第一种：使用构造函数提供</strong></p><p><strong>（2）第二种：使用set方法提供</strong></p><p><strong>（3）第三种：使用注解 提供</strong></p><h5 id="1-使用构造函数提供注入"><a href="#1-使用构造函数提供注入" class="headerlink" title="1. 使用构造函数提供注入"></a>1. 使用构造函数提供注入</h5><p>构造函数注入，需要在bean标签内，使用constructor-arg标签，标签出现的位置是bean标签的内部，、</p><p>标签中的属性：</p><p>​        type：用户指定要注入的数据的数据类型，该数据类型也是构造函数中某个或者是某些参数的类型</p><p>​        index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置是从0开始的</p><p>​        name：用于指定给构造函数中指定名称的参数赋值</p><p>=============最常用的是使用name的方式，给指定的参数进行赋值，=============以上三种都是用于指定给构造函数找那个的那个参数进行赋值</p><p>​        value：用户提供基本类型和string类型的数据</p><p>​        ref： 用于指定其他的bean类型，指的就是在spring的IOC核心容器中，出现过的bean对象。</p><p>构造函数的特点与优势：</p><p>​    在获取bean对象时，注入数据是必须的操作，否则对象是无法创建成功的。当我们使用的某个类的时候，就想使用某些数据的时候，我们就可以使用构造函数注入的方式，使用这种方式更简单。</p><p>弊端：</p><p>​        改变了bean对象的实例化方式，使我们在创建对象的时候，如果用不到这些数据，也必须提供。当我们在开发中除非非要采用这种方式进行创建，一般的时候我们是不使用的。</p><p>例如：</p><p>我们在userServiceImpl中写生需要注入的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date brithday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">userServiceImpl</span><span class="params">(String name, Integer age, Date brithday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.brithday = brithday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userServiceImpl中的save方法执行了"</span>+name+<span class="string">","</span>+age+<span class="string">","</span>+brithday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在spring的配置文件中，进行依赖的注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖注入的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService2"</span> <span class="attr">class</span>=<span class="string">"lei.study.service.impl.userServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"第一个"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"19"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"brithday"</span> <span class="attr">ref</span>=<span class="string">"dataNow"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataNow"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">    System.out.println(ac);</span><br><span class="line">    IUserService userService = (IUserService) ac.getBean(<span class="string">"userService2"</span>);</span><br><span class="line">    userService.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>userServiceImpl中的save方法执行了第一个,19,Sun May 17 15:23:41 CST 2020</p><p>说明注入成功</p><p>引入：</p><p>在进行spring配置文件的编写的时候，需要在配置文件中引入约束，spring容器中相对完整的约束如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:mvc=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">       xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/mvc</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">            http://www.springframework.org/schema/aop/spring-aop.xsd "</span></span><br><span class="line">       <span class="keyword">default</span>-autowire=<span class="string">"byName"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="2-set方法注入-经常使用的方式"><a href="#2-set方法注入-经常使用的方式" class="headerlink" title="2. set方法注入(经常使用的方式)"></a>2. set方法注入(经常使用的方式)</h3><p>set方式注入，设计的标签：property</p><p>出现的位置，bean标签的内部</p><p>标签的属性：</p><p>​        name：用于指定注入时所调用的set方法名称</p><p>​        value：用户提供基本类型和string类型的数据</p><p>​        ref： 用于指定其他的bean类型，指的就是在spring的IOC核心容器中，出现过的bean对象。</p><p><strong>set注入的优点：</strong></p><p>​        创建的对象的时候没有明确的限制，可以直接使用默认构造函数，然后通过property 找到对应的set方法名称，进行一些取值的注入即可</p><p><strong>set注入的缺点：</strong></p><p>​    如果有某个成员必须有值，则获取对象时，有可能set方法没有执行。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date brithday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setter方式注入的方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrithday</span><span class="params">(Date brithday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brithday = brithday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userServiceImpl中的save方法执行了"</span>+name+<span class="string">","</span>+age+<span class="string">","</span>+brithday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring中的配置文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--setter方式注入的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService3"</span> <span class="attr">class</span>=<span class="string">"lei.study.service.impl.userServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"哈哈哈"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brithday"</span> <span class="attr">ref</span>=<span class="string">"dataNow"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在测试文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">    System.out.println(ac);</span><br><span class="line">    IUserService userService = (IUserService) ac.getBean(<span class="string">"userService3"</span>);</span><br><span class="line">    userService.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用set注入-复杂数据类型-集合类型的数据结构"><a href="#使用set注入-复杂数据类型-集合类型的数据结构" class="headerlink" title="使用set注入 复杂数据类型/集合类型的数据结构"></a>使用set注入 复杂数据类型/集合类型的数据结构</h5><p>用于给List结构集合注入的标签有：list  array    set</p><p>用户给Map结构集合注入的标签：map   props</p><p>注意：结构相同，可以互换</p><h6 id=""><a href="#" class="headerlink" title="========================================================="></a>=========================================================</h6><h2 id="Spring基于注解的IOC以及IOC的案例"><a href="#Spring基于注解的IOC以及IOC的案例" class="headerlink" title="Spring基于注解的IOC以及IOC的案例"></a>Spring基于注解的IOC以及IOC的案例</h2><p>注意： 在本节中我们学习使用注解进行依赖的主注入，在上面的案例中，我们使用的是配置文件的方式进行配置的。</p><p>我们学习了———</p><p>用于创建对象</p><p>用于注入数据</p><p>用于改变作用范围的</p><p>和生命周期相关</p><p>等等相关的配置</p><p><strong>当我们使用注解之后，</strong></p><p><strong>用户创建对象的注解</strong>：他们的作用就和在XML配置文件中，编写一个&lt;bean 标签实现的功能是一样的</p><p><strong>用于注入数据的</strong>：他们的作用就和在xml配置文件中的bean 标签中写一个property标签的作用是一样的</p><p><strong>用于改变作用范围的</strong>：他们的作用就和在bean标签中使用scope属性实现的功能是一样的</p><p><strong>和生命周期相关</strong>：他们的作用就和在bean标签中使用  init-method 和destory-method的作用是一样的</p><p><strong>(1) 创建对象的注解：</strong></p><p><strong>①    @Component    作用在类上</strong></p><p>作用：就是把当前类对象存入spring容器中</p><p>属性：value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母小写</p><p><strong>注意：使用这个注解之前，我们需要在spring的配置文件中，加上一个说明，告知spring在创建容器的时候，需要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--告诉spring容器需要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"lei.study"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"haha"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userServiceImpl2</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userServiceImpl中的save方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">    IUserService userService = (IUserService) ac.getBean(<span class="string">"haha"</span>);</span><br><span class="line">    userService.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②   @ Controller        @Service      @Repository   三个注解</strong></p><p>以上三个注解他们的作用和属性与Component是一模一样的。他们三个是spring框架，为我们明确提供的三层对象使用的注解，使三层对象更加清晰</p><p> <strong>@ Controller</strong>  一般使用在表现层</p><p> <strong>@Service</strong>      一般使用的service层</p><p><strong>@Repository</strong>  一般使用在持久层</p><p> <strong>（2）注入数据的注解</strong></p><p><strong>@Autowired :</strong> </p><p>出现位置：可以使变量上，也可以是方法上</p><p>细节：在使用注解注入数据的时候，set方法就不是必须的了</p><p>作用就是，自动按照类型注入（例如   @Autowired   在这上面注解 private  IUserDao  userDao = null，那么就会按照IUserDao  类型 ，去spring容器中进行寻找对象取值），只要容器中有唯一的一个bean 对象类型和要注入的变量类型匹配，就可以注入成功。如果IoC容器中没有任何bean的类型和要注入的变量类型匹配，则报错。</p><p>如果有多个类型相互匹配的时候，就会自动按照名称(userDao 这个名称)进行找对象bean对象，如果名称不一致或者是不存在，就会报错。</p><p>例如我们定义了两个userDaoImpl方法实现了同一个接口，并在每一个方法上面使用@Component注解生成对象到容器中</p><p>第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"userDao1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userDaoImpl</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"saveUser1方法执行了,保存了用户1111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"userDao2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userDaoImpl2</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"saveUser1方法执行了,保存了用户222222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，当我们在service层取值调用bean的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      userDao.saveUser();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个时候按照类型IUserDao寻找bean的时候就会找到两个bean（因为@Autowired是按照类型进行寻找的），程序会报错，这个时候我们就可以和@Qualifer注解进行配合使用</p><p> <strong>这个时候出现了@Qualifer注解</strong></p><p><strong>@Qualifer</strong></p><p>作用：在按照类中注入的基础之上再按照名称进行注入，它在给类成员注入时不能单独使用，但是在给方法参数注入时可以单独使用。</p><p>属性：value 用于指定注入bean的id</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = <span class="string">"userDao2"</span>)</span><br><span class="line"><span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还有一个注解：</strong></p><p><strong>@Resource</strong></p><p>@Recource 作用是，直接按照bean的id注入，它可以独立使用</p><p>属性：name   ：用于指定bean的id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"userDao2"</span>)</span><br><span class="line"> <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     userDao.saveUser();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：以上三种注解都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现。</strong></p><p><strong>@Value注解</strong></p><p>作用：用于注入基本类型和String类型的数据</p><p>属性：value—用于指定数据的值，它可以使用spring中的spEl（也就是spring中的EL表达式）</p><p>​            spEl的写法 ：   ${表达式}</p><p><strong>（3）用于改变作用范围的注解</strong></p><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</p><p>Scope：作用—用于指定bean的作用范围</p><p>属性：value：指定范围的取值，常用取值  single    prototype   分别对应单例和多例</p><p><strong>（4）和生命周期相关的注解</strong></p><p> 他们的作用就和在bean标签中使用init-method和destory-method的作用是一样的</p><p>@PreDestory   作用：用于指定销毁方法</p><p>@PostConstruct    作用：用于指定初始化方法</p><h3 id="-1"><a href="#-1" class="headerlink" title="=================================================="></a>==================================================</h3><h1 id="Spring的新注解"><a href="#Spring的新注解" class="headerlink" title="Spring的新注解"></a>Spring的新注解</h1><p>@Configuration   </p><pre><code>作用》：指定当前类是一个配置类    </code></pre><p>​                细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写</p><p>@ComponentScan </p><p>​                作用》：用于通过注解指定spring在创建容器时要扫描的包</p><p>​                属性：   value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包，我们使用这个注解就相当于在spring的配置文件xml中使用了  &lt;context:component-scan base-package=”lei.study”/&gt;  进行了一个包扫描的作用</p><p>@Bean注解</p><p>​            作用》：用于把当前方法的返回值作为bean对象存入spring的Ioc容器中</p><p>​            属性：  name  用于指定bean的id，当不写时，默认值是当前方法的名称</p><p>​            细节：当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象</p><p>​                        查找的方式和Autowired注解的作用是一样的</p><p>@Import<br>                作用》：用于导入其他的配置类</p><p>​                属性：value   用于指定其他配置类的字节码            </p><p>​                            当我们使用Import的注解之后，有Import注解的类是父配置类，而导入的都是子配置类</p><p>@PropertySource   </p><p>​                作用：用于指定properties文件的位置</p><p>​                            关键字 ： classpath   表示类路径下</p><h2 id="-2"><a href="#-2" class="headerlink" title="=========================================="></a>==========================================</h2><h3 id="Spring中的AOP配置"><a href="#Spring中的AOP配置" class="headerlink" title="Spring中的AOP配置"></a>Spring中的AOP配置</h3><p>spring中基于XML的AOP配置步骤：</p><ol><li><p>把通知Bean也交给spring容器来进行管理</p></li><li><p>使用aop:config标签表明开始AOP的配置</p></li><li><p>使用aop：aspect标签表明配置切面</p><p>​                    id属性：是给切面提供一个唯一标识</p><p>​                    ref属性：是指定通知类bean的id</p></li><li><p>在aop：aspect标签的内部使用对应标签来配置通知的类型</p><p>​                我们现在是让我们定义的切面方法在切入点方法执行之前执行，所以是前置通知</p><p>​                aop：before：表示配置前置通知</p><p>​                method属性：用于指定Logger类中哪个方法是前置通知</p><p>​                pointcut属性：用于指定切入点表达式，改表达式的含义指的是对业务层中哪些方法进行增强</p><p>​        切入点表达式的写法：</p><p>​                关键字：execution（表达式）</p><p>​                表达式：</p><p>​                                访问修饰符   返回值    包名.包名.包名…..类名.方法名（参数列表）</p><p>​                标准的表达式写法  execution(public void lei.study.service.impl.userServiceImpl.saveUser()</p></li></ol><p>   例如我们建立一个切入方法，就是打印日志信息，建立一个日志类，然后写一些方法</p><p>   例如：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要注入切入点的方法，也就是在切入点之前或者之后需要执行的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打印日志的方法，开始打印日志。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   把上面的方法注入到userservice中</p><p>   userServiceImpl.java</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userServiceImpl保存用户的操作执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想把日志信息注入到saveUser（）方法之前或者是之后执行，我们就可以在spring的配置文件中，进行AOP切面的一些配置，就可以使用AOP完成相关的切面编程</p><p>在spring的配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"lei.study.service.impl.userServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"printLogger"</span> <span class="attr">class</span>=<span class="string">"lei.study.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"printLogger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立切入点方法的关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printLogger"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public void lei.study.service.impl.userServiceImpl.saveUser())"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里我们需要注意切入点表达式的写法</p><p>表达式：</p><p>​            访问修饰符   返回值    包名.包名.包名…..类名.方法名（参数列表）</p><p>​            标准的表达式写法  execution(public void lei.study.service.impl.userServiceImpl.saveUser()</p><p>全通配写法</p><p>​            表达式的全通配写法    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 表达式的全通配写法</span><br><span class="line">* *..*.*(..)</span><br></pre></td></tr></table></figure><p>解释说明：在上面的方法中，我们只对userService类中一个saveUser（）方法进行了增强，如果我们需要使用这个日之类对所有的userService中的方法都需要增强，我们不需要一个一个方法的进行编写，只需要写一个表达式的全通配写法   表达式的全通配写法           </p><p><strong>注意：</strong></p><p>​        在标准写法中，</p><p><strong>访问修饰符可以省略</strong> ：  public void lei.study.service.impl.userServiceImpl.saveUser() 中的public可以省略，写成  void lei.study.service.impl.userServiceImpl.saveUser()</p><p><strong>返回值可以使用通配符</strong>：表示任意返回值类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* lei.study.service.impl.userServiceImpl.saveUser()</span><br></pre></td></tr></table></figure><p><strong>包名可以使用通配符：</strong>表示任意包。但是有几级包，就需要写几个*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *.*.*.*.userServiceImpl.saveUser()</span><br></pre></td></tr></table></figure><p><strong>包名可以使用..表示当前包及其子包</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..userServiceImpl.saveUser()</span><br></pre></td></tr></table></figure><p><strong>包名和方法名都可以使用*来实现通配：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..*.*()</span><br></pre></td></tr></table></figure><p><strong>参数列表：</strong></p><p>可以直接写数据类型</p><p>​            基本类型直接写名称   int</p><p>​            引用类型写包.类名的方式   java.lang.String        </p><p>可以使用通配符表示任意类型，但是必须有参数</p><p>可以使用..表示有无参数均可，有参数可以使任意类型</p><p>全通配写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 表达式的全通配写法</span><br><span class="line">* *..*.*(..)</span><br></pre></td></tr></table></figure><p><strong>实际开发中：</strong></p><p>​    实际开发中切入点表达式的通常写法：</p><p>​            我们可以切到业务层实现类下的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* lei.study.service.impl.*.*(..)</span><br></pre></td></tr></table></figure><p>在上面的例子中我们可以使用如下的写法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    表达式的全通配写法</span><br><span class="line">                * *..*.*(..)</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:aspect id=<span class="string">"logAdvice"</span> ref=<span class="string">"printLogger"</span>&gt;</span><br><span class="line">        &lt;!--建立切入点方法的关联--&gt;</span><br><span class="line">        &lt;aop:before method="printLogger" pointcut="execution(* *..*.*(..))"&gt;&lt;/aop:before&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p><strong>通知的类型：</strong></p><p><strong>前置通知</strong>：在切入点方法执行之前执行</p><p><strong>后置通知</strong>：在切入点方法正常执行之后执行，也和异常通知永远只能执行一个 </p><p><strong>异常通知</strong>：在切入点方法执行产生异常之后执行，它和后置通知永远只能执行一个</p><p><strong>最终通知</strong>：无论切入点方法是否正常执行它都会在其后面执行。</p><p><strong>环绕通知：</strong>当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</p><p>切面的配置：</p><p>需要注入切入点的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforePrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知，打印日志的方法，开始打印日志。。。在切入点方法执行之前执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知，结束打印日志。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printThrow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切入点方式产生异常之后，执行的异常通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是最终通知， 无论切入点方法是否正常执行都会在切入点之后执行的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"lei.study.service.impl.userServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"printLogger"</span> <span class="attr">class</span>=<span class="string">"lei.study.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    表达式的全通配写法</span></span><br><span class="line"><span class="comment">                * *..*.*(..)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"printLogger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立切入点方法的关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrint"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* lei.study.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterPrint"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* lei.study.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"printThrow"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* lei.study.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterLogger"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* lei.study.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring中的事物控制"><a href="#spring中的事物控制" class="headerlink" title="spring中的事物控制"></a>spring中的事物控制</h2><h3 id="spring基于XML的声明式事务控制"><a href="#spring基于XML的声明式事务控制" class="headerlink" title="spring基于XML的声明式事务控制"></a>spring基于XML的声明式事务控制</h3><p>在spring中我们不用再编写关于事务的一些操作方法，我们可以直接使用xml配置的方式，对数据库连接操作中的方法进行相关事务的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring中基于XML的声明式事务控制配置步骤 </span><br><span class="line">1. 配置事务管理器 </span><br><span class="line">2. 配置事务的通知           </span><br><span class="line">此时我们需要导入事务的约束 tx的名称和约束  同时也需要aop的           </span><br><span class="line">使用 &lt;tx:advice&gt; 配置事务的通知                    </span><br><span class="line">id :给事务通知起一个唯一标识                    </span><br><span class="line">transtration-manager：给事务通知提供一个事务管理器引用 </span><br><span class="line">3，配置AOP中的通用切入点表达式 </span><br><span class="line">4. 建立事务通知和切入点表达式的对应关系 </span><br><span class="line">5. 配置事务的属性        </span><br><span class="line">是在事务的通知  tx:advice 标签的内部进行配置</span><br></pre></td></tr></table></figure><ol><li><p><strong>在spring中配置事务管理器</strong></p><p>DataSourceTransactionManager可以配置JDBC或者是ibatis关于事务的配置</p><p>HiberateTransactionManager 可以配置整合Hiberate中关于事务的配置</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>配置事务的通知</strong>  （以及配置事务的属性）</li></ol><p>在配置事务的通知中，我们需要配置事务的一些属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvicce"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务的属性</span></span><br><span class="line"><span class="comment">            isolation=""  用于指定事务的隔离级别   默认值是default ，表示使用数据库的默认隔离级别</span></span><br><span class="line"><span class="comment">            propagation=""  用于指定事务的传播行为，默认值是REQUIRED 表示一定有事务，增删改的选择，查询方法可以选择SUPPORTS</span></span><br><span class="line"><span class="comment">            read-only=""   用于指定事务是否只读，只有查询方法才能设置为true。默认值是false，表示读写</span></span><br><span class="line"><span class="comment">            rollback-for=""  用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚，没有默认值，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">            no-rollback-for=""  用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常事务回滚，没有默认值，表示任何异常都回滚</span></span><br><span class="line"><span class="comment">            timeout=""     用于指定事务的超时时间，默认值是-1 表示永不超时，如果指定了数值，以秒为单位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>配置事务的切入点表达式以及建立切入点表达式和事务通知的对应关系</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* lei.study.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立切入点表达式和事务通知的对应关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvicce"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spring基于注解的声明式事务控制"><a href="#spring基于注解的声明式事务控制" class="headerlink" title="spring基于注解的声明式事务控制"></a>spring基于注解的声明式事务控制</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-spring两个核心容器对象的区别&quot;&gt;&lt;a href=&quot;#1-spring两个核心容器对象的区别&quot; class=&quot;headerlink&quot; title=&quot;1. spring两个核心容器对象的区别&quot;&gt;&lt;/a&gt;1. spring两个核心容器对象的区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ApplicationContext&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它在构建核心容器的时候，采用的创建对象的策略是立即加载的方式，也就是说，只要一读取配置文件马上就创建配置文件中配置的对象、&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试，阿里" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>腾讯面试整理</title>
    <link href="http://yoursite.com/2020/06/08/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/08/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</id>
    <published>2020-06-08T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.718Z</updated>
    
    <content type="html"><![CDATA[ <a id="more"></a><h2 id="java相关："><a href="#java相关：" class="headerlink" title="java相关："></a>java相关：</h2><h3 id="JDK中哪一些是线程安全的集合类？是怎么保证安全的？"><a href="#JDK中哪一些是线程安全的集合类？是怎么保证安全的？" class="headerlink" title="JDK中哪一些是线程安全的集合类？是怎么保证安全的？"></a>JDK中哪一些是线程安全的集合类？是怎么保证安全的？</h3><p>早在jdk的1.1版本中，所有的集合都是线程安全的。但是在1.2以及之后的版本中就出现了一些线程不安全的集合，为什么版本升级会出现一些线程不安全的集合呢？因为线程不安全的集合普遍比线程安全的集合效率高的多。随着业务的发展，特别是在web应用中，为了提高用户体验减少用户的等待时间，页面响应速度(也就是效率)是优先考虑的。而且对线程不安全的集合加锁以后也能达到安全的效果（但是效率会低，因为会有锁的获取以及等待）。其实在jdk源码中相同效果的集合线程安全的比线程不安全的就多了一个同步机制，但是效率上却低了不止一点点，因为效率低，所以已经不太建议使用了。</p><p>Vector：就比Arraylist多了个同步化机制（线程安全）。</p><p>Hashtable：就比Hashmap多了个线程安全。</p><p>hashtable是线程安全的,即hashtable的方法都提供了同步机制；hashmap不是线程安全的,即不提供同步机制 ；hashtable不允许插入空值,hashmap允许!</p><p>ConcurrentHashMap:是一种高效但是线程安全的集合。</p><p>Stack：栈，也是线程安全的，继承于Vector。</p><h3 id="2-什么是线程安全？线程安全问题是由什么引起的？什么是死锁？"><a href="#2-什么是线程安全？线程安全问题是由什么引起的？什么是死锁？" class="headerlink" title="2.什么是线程安全？线程安全问题是由什么引起的？什么是死锁？"></a>2.什么是线程安全？线程安全问题是由什么引起的？什么是死锁？</h3><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p><p>  线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p><p>线程安全问题都是由全局变量及静态变量引起的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p><p>死锁产生有四个必要条件，打破任意一个，就能打破死锁状态: 1 互斥条件 2 请求与保持 3 不剥夺 4 循环等待</p><p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p><p>循环等待条件:若干进程间形成首尾相接循环等待资源的关系。</p><h3 id="3-你了解哪些数据结构？栈这种数据结构能应用在哪些场景中-举几个例子说明一下栈的实际应用场景？栈的特点是什么？"><a href="#3-你了解哪些数据结构？栈这种数据结构能应用在哪些场景中-举几个例子说明一下栈的实际应用场景？栈的特点是什么？" class="headerlink" title="3.你了解哪些数据结构？栈这种数据结构能应用在哪些场景中?举几个例子说明一下栈的实际应用场景？栈的特点是什么？"></a>3.你了解哪些数据结构？栈这种数据结构能应用在哪些场景中?举几个例子说明一下栈的实际应用场景？栈的特点是什么？</h3><p>栈这种结构的特点：栈只能从表的一端存取数据，另一端是封闭的。在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。</p><ol><li>使用栈进行符号的逆序输出：栈最大的特点是先进后出，所以逆序输出是栈经常用到的一个应用场景。首先把所有元素依次入栈，然后把所有元素出栈并输出，这样就实现了逆序输出。</li></ol><ol start="2"><li>计算后缀表达式，碰见数字就入栈，碰见符号出栈运算运算。遇见数字就入栈，遇见符号就出栈，然后把结果再入栈</li></ol><ol start="3"><li>语法检测，匹配括号是否成对出现:凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错。</li></ol><ol start="4"><li>什么是中缀表达式？</li></ol><p>​       中缀表达式利于人的理解，但不便于计算机的处理。因此需要将中缀表达式转换成后缀表达式，以方便计算机处理。所谓后缀表达式就是将运算符放在运算数之后。后缀表达式也称为逆波兰表达式。</p><h3 id="5-hashMap这种数据结构，假如让你自己去实现一个hashMap这种数据结构你会怎么去设计实现？（hashMap就是散列表，同一种说法）"><a href="#5-hashMap这种数据结构，假如让你自己去实现一个hashMap这种数据结构你会怎么去设计实现？（hashMap就是散列表，同一种说法）" class="headerlink" title="5.hashMap这种数据结构，假如让你自己去实现一个hashMap这种数据结构你会怎么去设计实现？（hashMap就是散列表，同一种说法）"></a>5.hashMap这种数据结构，假如让你自己去实现一个hashMap这种数据结构你会怎么去设计实现？（hashMap就是散列表，同一种说法）</h3><p>主要还是考的是hash表的结构，哈希表综合了数组和链表的优点，是一种寻址容易而且插入也相对容易的数据结构，哈希表既满足了数据查找方便，同时还不占用太多的内存空间，使用十分方便，哈希表有多种不同的实现方法，我们可以使用一种最常用的实现方法—拉链法来实现哈希表，这个哈希表可以理解为链表的数组。</p><p>哈希表是由数组+链表组成的，在数组中每个元素存储的是一个链表的头结点，数据存储在链表中，那么是按照怎么样的规则来进行存储的呢?一般的情况下是通过hash（key）%len获得，也就是元素的key的哈希值对数组长度取模得到。</p><p>hashMap其实是一个线性的数组实现的，所有可以理解为其存储数据的容器就是一个线性数组。</p><h3 id="6-算法方面了解哪些算法？排序算法中，选择排序和冒泡排序算法的区别在哪里？排序算法的稳定性是指什么？选择排序和冒泡排序的时间复杂度是多少？"><a href="#6-算法方面了解哪些算法？排序算法中，选择排序和冒泡排序算法的区别在哪里？排序算法的稳定性是指什么？选择排序和冒泡排序的时间复杂度是多少？" class="headerlink" title="6. 算法方面了解哪些算法？排序算法中，选择排序和冒泡排序算法的区别在哪里？排序算法的稳定性是指什么？选择排序和冒泡排序的时间复杂度是多少？"></a>6. 算法方面了解哪些算法？排序算法中，选择排序和冒泡排序算法的区别在哪里？排序算法的稳定性是指什么？选择排序和冒泡排序的时间复杂度是多少？</h3><p>选择排序：是一种最简单直观的排序算法，它的工作原理是每一次从待排序的数据元素中选出最小或者是最大的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完，选择排序是不稳定的排序方法。</p><p>冒泡排序：基本思想是将数组中的每个相邻元素进行两两比较，按照小元素在前（或大元素在前）的原则确定是否进行交换。这样每一轮执行之后，最大（或最小）的元素就会被交换到了最后一位。完成一轮之后，我们可以再从头进行第二轮的比较，直到倒数第二位（因为最后一位已经是被排序好的了）时结束。这样一轮之后，第二大（或第二小）的元素就会被交换到了倒数第二位。同样的过程会依次进行，直到所有元素都被排列成预期的顺序为止。</p><p>选择排序和冒泡排序算法的区别主要在于：两种排序比较的次数是相同的，但是交换的次数，选择排序是更少的，但是通常选择排序可能更快一点，冒泡排序是每一次都可能要交换，而选择排序是比较时记下a[i]的位置，最后用来交换的。交换过程是不一样的，但是查找过程是一样的。</p><p>时间复杂度：</p><p>冒泡排序时间复杂度：</p><p>N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><p>综上所述：冒泡排序总的平均时间复杂度为：O(n2)</p><p>选择排序时间复杂度：</p><p>选择排序空间复杂度也是O(1)，是一种原地排序算法。</p><p>它的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O（n^2）。</p><p>选择排序不是稳定的排序算法，因为它每次都要找出剩余未排序元素中的最小值，并和前面的元素交换位置，这样就破坏了稳定性。冒泡排序是一种稳定的排序算法。</p><h3 id="7-排序的稳定性是指什么？冒泡排序是稳定的排序算法，你这么证明，就是如果采用数据推导的方式去证明，你会如何证明是稳定的？"><a href="#7-排序的稳定性是指什么？冒泡排序是稳定的排序算法，你这么证明，就是如果采用数据推导的方式去证明，你会如何证明是稳定的？" class="headerlink" title="7. 排序的稳定性是指什么？冒泡排序是稳定的排序算法，你这么证明，就是如果采用数据推导的方式去证明，你会如何证明是稳定的？"></a>7. 排序的稳定性是指什么？冒泡排序是稳定的排序算法，你这么证明，就是如果采用数据推导的方式去证明，你会如何证明是稳定的？</h3><p>稳定排序是指原来相等的两个元素前后相对位置在排序后依然不变。</p><p>即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的，否则称为不稳定的。</p><h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><h3 id="在操作系统中，实现多进程间通信有哪些方式？信号量是什么-能举几个具体的使用信号量的例子吗"><a href="#在操作系统中，实现多进程间通信有哪些方式？信号量是什么-能举几个具体的使用信号量的例子吗" class="headerlink" title="在操作系统中，实现多进程间通信有哪些方式？信号量是什么? 能举几个具体的使用信号量的例子吗?"></a>在操作系统中，实现多进程间通信有哪些方式？信号量是什么? 能举几个具体的使用信号量的例子吗?</h3><p>进程和线程的关注点是不一样的，进程是资源分配的基本单位，进程间资源是独立的，关注的是进程通信问题，线程间资源是共享的，关注的是安全问题。</p><p>操作系统进程间通信的方式有哪些？</p><p>管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系指的是父子进程关系。</p><p>消息队列（message queue）：消息队列是消息的链表，存在在内核中并由消息队列表示符标示，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限制等缺点。</p><p>共享内存：共享内存就是映射一段内被其它进程所访问的内存，共享内存是由一个进程创建，但是多个进程都可以访问，共享内存是最快的进程间通信方式，它是针对其它进程通信方式运行效率低而专门设计的，它往往与其它通信机制，如信号量配置使用，来实现进程间的同步和通信。</p><p>套接字（socket）：套接字也是进程间的通信机制，与其它通信机制不同的是，它可以用于不同机器间的进程通信。</p><p>信号：信号是一种比较复杂的通信方式，用于通知接受进程某个时间已经发生。</p><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁的机制，防止某进程正在访问共享资源时，其他进程也访问该资源，因此它主要作为不同进程或者同一进程之间不同线程之间同步的手段。</p><h2 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h2><h3 id="数据库的事务中，事务有原子性、一致性等等，他们都是什么？那么一致性是指什么？如果保证了原子性就一定能保证一致性吗？如果我的每个操作都是原子的那么是不是数据肯定能保证是一致的？不能保证，理由是什么？说出理由"><a href="#数据库的事务中，事务有原子性、一致性等等，他们都是什么？那么一致性是指什么？如果保证了原子性就一定能保证一致性吗？如果我的每个操作都是原子的那么是不是数据肯定能保证是一致的？不能保证，理由是什么？说出理由" class="headerlink" title="数据库的事务中，事务有原子性、一致性等等，他们都是什么？那么一致性是指什么？如果保证了原子性就一定能保证一致性吗？如果我的每个操作都是原子的那么是不是数据肯定能保证是一致的？不能保证，理由是什么？说出理由?"></a>数据库的事务中，事务有原子性、一致性等等，他们都是什么？那么一致性是指什么？如果保证了原子性就一定能保证一致性吗？如果我的每个操作都是原子的那么是不是数据肯定能保证是一致的？不能保证，理由是什么？说出理由?</h3><p>原子性：事务是数据库的逻辑工作单位,事务中的操作要么全做，要么不做。</p><p>一致性：事务执行的结果必须是使数据库从一个一致性变到另一个一致性。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。</p><p>隔离性：一个事务的执行不能干扰其他事物。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><p>持久性：一个事务一旦提交，他对数据库中的数据的改变应该是永久性的。接下来的其它操作或者故障不应该对其执行结果有任何影响。</p><h4 id="原子性和一致性的关系是什么？"><a href="#原子性和一致性的关系是什么？" class="headerlink" title="原子性和一致性的关系是什么？"></a>原子性和一致性的关系是什么？</h4><p>在事务处理的ACID属性中，一致性是最基本的属性，其他的三个属性都为了保证一致性而存在的。原子性并不能保证一致性，在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。为了保证并发情况下的一致性引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好像其他并发事务并不存在一样，用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。怎么实现隔离性呢？可以通过锁机制，悲观锁和乐观锁。</p><h3 id="10-MySQL中有哪些方式可以提高数据的查询速度或者是效率的？"><a href="#10-MySQL中有哪些方式可以提高数据的查询速度或者是效率的？" class="headerlink" title="10. MySQL中有哪些方式可以提高数据的查询速度或者是效率的？"></a>10. MySQL中有哪些方式可以提高数据的查询速度或者是效率的？</h3><p>索引：索引是数据库中重要的数据结构，它的根本目的就是为了提高查询速度，对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h3 id="11-Hadoop的架构是怎么样的-Hadoop是怎么保证数据是一致的-是怎么保证数据完整性的？"><a href="#11-Hadoop的架构是怎么样的-Hadoop是怎么保证数据是一致的-是怎么保证数据完整性的？" class="headerlink" title="11.Hadoop的架构是怎么样的? Hadoop是怎么保证数据是一致的,是怎么保证数据完整性的？"></a>11.Hadoop的架构是怎么样的? Hadoop是怎么保证数据是一致的,是怎么保证数据完整性的？</h3><p>Hadoop由HDFS、MapReduce、Yarn(资源调度)、辅助工具（HBase、Hive和ZooKeeper等）成员组成，其中最基础最重要元素为底层用于存储集群中所有存储节点文件的文件系统HDFS（Hadoop Distributed File System）来执行MapReduce程序的MapReduce引擎。</p><h3 id="12-你熟悉MapReduce框架吗？"><a href="#12-你熟悉MapReduce框架吗？" class="headerlink" title="12.你熟悉MapReduce框架吗？"></a>12.你熟悉MapReduce框架吗？</h3><h3 id="13-你现在在做哪些工作？是如何存储的？你的优点在哪里？如果我把不同来源的数据导入spark或者是hive中，是不是也可以呢？"><a href="#13-你现在在做哪些工作？是如何存储的？你的优点在哪里？如果我把不同来源的数据导入spark或者是hive中，是不是也可以呢？" class="headerlink" title="13.你现在在做哪些工作？是如何存储的？你的优点在哪里？如果我把不同来源的数据导入spark或者是hive中，是不是也可以呢？"></a>13.你现在在做哪些工作？是如何存储的？你的优点在哪里？如果我把不同来源的数据导入spark或者是hive中，是不是也可以呢？</h3><h3 id="14-网络方面。TCP和UDP的区别是什么？TCP为什么是安全的？三次握手是什么？三次握手之后，我再发如果断了，会怎么办？"><a href="#14-网络方面。TCP和UDP的区别是什么？TCP为什么是安全的？三次握手是什么？三次握手之后，我再发如果断了，会怎么办？" class="headerlink" title="14. 网络方面。TCP和UDP的区别是什么？TCP为什么是安全的？三次握手是什么？三次握手之后，我再发如果断了，会怎么办？"></a>14. 网络方面。TCP和UDP的区别是什么？TCP为什么是安全的？三次握手是什么？三次握手之后，我再发如果断了，会怎么办？</h3><ol><li>连接方面区别：TCP是面向连接的，发送数据之前需要建立连接，UDP是无连接的，即发送数据之前不需要建立连接。</li></ol><ol start="2"><li>安全方面的区别：TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复且按序到达，UDP尽最大努力交付，即不保证可靠交付。</li></ol><ol start="3"><li>传输效率的区别：TCP传输效率相对较低，UDP传输效率高，适用于对高速传输和实时性有较高要求的通信或者广播通信。</li></ol><ol start="4"><li>链接对象数量的区别：TCP链接只能是点到点，一对一的，UDP支持一对一、一对多、多对一和多对多的交互通信。</li></ol><h3 id="15-什么是滑动窗口，滑动窗口是用来干什么的？"><a href="#15-什么是滑动窗口，滑动窗口是用来干什么的？" class="headerlink" title="15. 什么是滑动窗口，滑动窗口是用来干什么的？"></a>15. 什么是滑动窗口，滑动窗口是用来干什么的？</h3><p>滑动窗口本质上是描述接受方（本地）的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。</p><p>滑动窗口协议（Sliding Window Protocol）属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。</p><p>tcp采用滑动窗口机制来实现流量控制！</p><h3 id="16-操作系统Linux有了解吗？怎么看正在使用CPU的一个线程命令是什么？Linux的常用命令？"><a href="#16-操作系统Linux有了解吗？怎么看正在使用CPU的一个线程命令是什么？Linux的常用命令？" class="headerlink" title="16. 操作系统Linux有了解吗？怎么看正在使用CPU的一个线程命令是什么？Linux的常用命令？"></a>16. 操作系统Linux有了解吗？怎么看正在使用CPU的一个线程命令是什么？Linux的常用命令？</h3><h3 id="17-你看过哪些开源的底层代码？你经常访问的开源的网站是什么？"><a href="#17-你看过哪些开源的底层代码？你经常访问的开源的网站是什么？" class="headerlink" title="17. 你看过哪些开源的底层代码？你经常访问的开源的网站是什么？"></a>17. 你看过哪些开源的底层代码？你经常访问的开源的网站是什么？</h3>]]></content>
    
    <summary type="html">
    
      
      
         &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;java相关：&quot;&gt;&lt;a href=&quot;#java相关：&quot; class=&quot;headerlink&quot; title=&quot;java相关：&quot;&gt;&lt;/a&gt;java相关：&lt;/h2&gt;&lt;h3 id=&quot;JDK中哪一些是线程安全的集合类？是怎么保证安
      
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>springMVC</title>
    <link href="http://yoursite.com/2020/06/07/springMVC/"/>
    <id>http://yoursite.com/2020/06/07/springMVC/</id>
    <published>2020-06-07T12:28:32.000Z</published>
    <updated>2021-05-16T11:04:06.711Z</updated>
    
    <content type="html"><![CDATA[<h4 id="springMVC框架时基于组件的方式执行流程"><a href="#springMVC框架时基于组件的方式执行流程" class="headerlink" title="springMVC框架时基于组件的方式执行流程"></a>springMVC框架时基于组件的方式执行流程</h4>  <a id="more"></a><h3 id="springMVC的执行流程："><a href="#springMVC的执行流程：" class="headerlink" title="springMVC的执行流程："></a>springMVC的执行流程：</h3><p>（1） 首先是浏览器发出请求，发送到web.xml文件中我们配置过的前端控制器DispatcherServlet响应用户请求，DispatcherServlet根据请求的模式决定是否去找对应的映射器，DispatcherServlet是整个流程控制的中心，由它调用其他组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</p><p>（2）DispatcherServlet请求查找Handler，然后到达处理器映射器HandlerMapping，HandlerMapping让Controller类中的方法执行。springMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式</p><p>（3）我们在对应的Controller方法中执行完对应的逻辑之后，或者把数据封装进Model中之后返回。</p><p>在Controller中</p><p>@RequesMappding注解中的参数</p><p>​        value：用于指定请求的URL，它和path属性的作用是一样的</p><p>​        method：用于指定请求的方式</p><p>​        params：用于指定限制请求参数的条件，它支持简单的表达式。要么请求参数的key和value必须和配置的一模一样</p><p>​            例如：  param  ={“accountName”}  表示请求参数必须有accountName</p><p>​                          param={“money！=100”}  表示请求参数money不能是100</p><p>​                            param={“money=100”} 表示请求参数money必须是100</p><p>​        headers：用于指定限制请求消息头的条件</p><p>​            注意：以上四个属性只要出现2个或者以上时，他们的关系是与的关系</p><h3 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h3><p>SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</p><p>要求：提交表单的name和参数的名称是相同的</p><p>支持的数据类型：</p><p>（1） 基本数据类型和字符串类型</p><p>（2）实体类型  JavaBean</p><p>（3）集合数据类型（List、Map集合等）</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;springMVC框架时基于组件的方式执行流程&quot;&gt;&lt;a href=&quot;#springMVC框架时基于组件的方式执行流程&quot; class=&quot;headerlink&quot; title=&quot;springMVC框架时基于组件的方式执行流程&quot;&gt;&lt;/a&gt;springMVC框架时基于组件的方式执行流程&lt;/h4&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Struts2面试整理</title>
    <link href="http://yoursite.com/2020/06/07/Struts2%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/07/Struts2%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</id>
    <published>2020-06-07T10:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是Struts2？"><a href="#1-什么是Struts2？" class="headerlink" title="1. 什么是Struts2？"></a>1. 什么是Struts2？</h2><p>Struts2是一个用Java构建Web应用程序的开源框架。Struts2基于OpenSymphony WebWork框架。它从Struts1中得到了很大的改进，使其更加灵活，易于使用和扩展。Struts2的核心组件是Action，Interceptors和Result页面。</p><p>Struts2提供了许多方法来创建Action类并通过struts.xml或注释来配置它们。我们可以为常见任务创建自己的拦截器。Struts2附带了很多标签，并使用OGNL表达式语言。我们可以创建自己的类型转换器来渲染结果页面。结果页面可以是JSP和FreeMarker模板。</p> <a id="more"></a><h2 id="2-Struts2的核心组件是什么？"><a href="#2-Struts2的核心组件是什么？" class="headerlink" title="2. Struts2的核心组件是什么？"></a>2. Struts2的核心组件是什么？</h2><p>1、前端控制器 </p><p>2、OGNL/ VS：OGNL/ ValueStack </p><p>3、Action：动作</p><p>4、Result：结果 </p><p>5、Interceptor：拦截器 </p><p>6、Tags：标签库</p><h2 id="3-Struts2的工作流程"><a href="#3-Struts2的工作流程" class="headerlink" title="3. Struts2的工作流程"></a>3. Struts2的工作流程</h2><p>（1）所有请求提交给前端控制器。</p><p>（2）根据配置信息确定要调用的 Action。</p><p>（3）创建一个 ValueStack 对象（每个请求都有一个独立的 VS 对象）。</p><p>（4）创建 Action 对象，把 Action 对象放到 VS 的栈顶，将 VS 对象存入到 request 中，存储的 key 为“ struts.valueStack”。</p><p>（5）控制器调用 Action 对象接收请求参数， 并在方法中根据输入属性算输出属性。</p><p>（6）在调用 Action 之前或之后调用一系列 Interceptor。</p><p>（7）根据 Action 返回的字符串确定 Result（ 10 种类型）。</p><p>（8）调用 Result 对象，将 VS 中的数据按照特定的格式输出。</p><p>（9）很多情况下， Result 将转发到 JSP， JSP 页面用 Tags 取出数据并显示。</p><p>（10）请求处理完后，将 ValueStack 对象和 Action 对象销毁。</p><h2 id="4-OGNL技术"><a href="#4-OGNL技术" class="headerlink" title="4. OGNL技术"></a>4. OGNL技术</h2><h5 id="1-什么是OGNL"><a href="#1-什么是OGNL" class="headerlink" title="1.什么是OGNL?"></a>1.什么是OGNL?</h5><p>OGNL是 Object-Graph Navigation Language（对象图形导航语言）的缩写，它是一种功能强大的表达式语言。是一种表达式语言。使用这种表达式语言，你可以通过某种表达式语法，存取Java对象树中的任意属性、调用Java对象树的方法、同时能够自动实现必要的类型转化。</p><p>OGNL简介：　</p><p>　　（1）OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个开源项目。</p><p>　　　　 struts2框架默认就支持Ognl表达式语言（所以struts必须引用的包：ognl.jar）；</p><p>　　（2）struts2的ognl的作用：页面取值使用；</p><p>　　（3）OGNL和EL的区别:</p><p>　　　　　EL表达式语言:用于页面取值，jsp页面取值的标准（默认可以直接使用，应用范围更加广泛）；</p><p>　　　　  OGNL表达式语言：struts2标签默认支持的表达式语言，必须配置struts标签使用，不能离开struts2标签直接使用；</p><p>　　（4）OGNL 有一个上下文（Context）概念,[OgnlContext对象：OgnlContext对象是ognl表达式语言的核心];</p><p>　　　　 其实上下文就是一个MAP结构，它实现了 java.utils.Map 的接口。</p><p>　　（5）ognl表达式语言取值，取根元素的值，不用带#符号；ognl表达式语言取值，取非根元素的值，需要带#符号；</p><p>6：ValueStack, 即值栈对象（根元素的值存储在root中，非根元素的值存储在context中）。</p><p>　 （1）：值栈对象是整个struts数据存储的核心，或者叫中转站。</p><p>　 （2）：用户每次访问struts的action，都会创建一个Action对象、值栈对象、ActionContext对象；  然后把Action对象放入值栈中； 最后再把值栈对象放入request中，传入jsp页面。</p><p>　 （3）：(key: struts.valueStack)； 开发者只需要通过ActionContext对象就可以访问struts的其他的关键对象。 （ActionContext是给开发者用的，便于学习与使用。）</p><h5 id="2-Struts2标签的使用"><a href="#2-Struts2标签的使用" class="headerlink" title="2. Struts2标签的使用"></a>2. Struts2标签的使用</h5><p>Struts2 的很多标记就是通过访问 ValueStack 获得数据的。使用前要在页面中要引入： &lt;%@taglib uri=”/struts-tags” prefix=”s”%&gt;， prefix：表示前缀</p><h2 id="5-什么是Struts2中的拦截器？"><a href="#5-什么是Struts2中的拦截器？" class="headerlink" title="5. 什么是Struts2中的拦截器？"></a>5. 什么是Struts2中的拦截器？</h2><p>它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。Struts2内置了很多拦截器，每个拦截器完成相对独立的功能，多个拦截器的组合体成为拦截器栈。最为重要的拦截器栈是系统默认拦截器栈DefaultStack。struts2默认定义了35种拦截器，默认执行20种。</p><p>1）拦截器（Interceptor）是Struts2的核心组成部分，是XWork体系的重要组件。</p><p>2）Struts2很多功能都是构建在拦截器基础之上的，例如文件的上传下载、国际化、数据类型转换和数据校验等等。</p><p>3）Struts2拦截器在访问某个Action方法之前和之后实施拦截</p><p>4）Struts2拦截器是可插拔的，拦截器是AOP（面向切面编程）的一种实现。</p><p>5）拦截器栈（Interceptor Stack）：将拦截器按一定的顺序联结成一条链，在访问被拦截的方法时，Struts2拦截器链中的拦截器就会按其之前定义的顺序依次调用。</p><p>struts2中的的功能（参数处理、文件上传、字符编码等）都是通过系统拦截器实现的。如果业务需要，当然我们也可以自定义拦截器,进行可插拔配置，在执行  Action  的方法前后、加入相关逻辑完成业务。</p><p>使用场景：</p><p>（1）用户登录判断，在执行 Action的前面判断是否已经登录，如果没有登录的跳转到登录页面。</p><p>（2）用户权限判断，在执行 Action的前面判断是否具有，如果没有权限就给出提示信息。</p><p>（3）操作日志……等等</p><h2 id="6-在Struts2中创建Action类有哪些不同的方法？"><a href="#6-在Struts2中创建Action类有哪些不同的方法？" class="headerlink" title="6. 在Struts2中创建Action类有哪些不同的方法？"></a>6. 在Struts2中创建Action类有哪些不同的方法？</h2><p>（1）方式一：直接创建一个类，可以是POJO，即原生Java类，没有继承任何类，也没有实现任何接口。这种方式使得strust2框架的代码侵入性更低，但是这种方式是理想状态，开发中并不常用。</p><p>（2）方式二：实现一个接口com.opensymphony.xwork2.Action。接口里面有execute方法，提供了action方法的规范，Action接口预置了一些字符串，可以在返回结果时使用。为了方便。这种方式也不常用。</p><p>（3）方式三：继承一个类，ActionSupport。该方式帮我们实现了一些接口 Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable  如果我们需要用到这些接口的时候，就不需要自己实现了</p><h2 id="7-什么是ValueStack和OGNL？"><a href="#7-什么是ValueStack和OGNL？" class="headerlink" title="7. 什么是ValueStack和OGNL？****"></a>7. 什么是ValueStack和OGNL？****</h2><p>ValueStack是Struts2存储应用程序数据以处理客户端请求的存储区域。数据存储在ActionContext使用ThreadLocal的对象中，以具有特定于特定请求线程的值。</p><p>对象图导航语言（OGNL）是一种功能强大的表达式语言，用于处理存储在ValueStack上的数据。正如您在架构图中看到的，拦截器和结果页面都可以使用OGNL访问存储在ValueStack上的数据。</p><h2 id="8-列举Struts2中引入的一些有用的注释？"><a href="#8-列举Struts2中引入的一些有用的注释？" class="headerlink" title="8. 列举Struts2中引入的一些有用的注释？****"></a>8. 列举Struts2中引入的一些有用的注释？****</h2><p>Struts2中引入的一些重要注释是：</p><p>@Action创建动作类</p><p>@Actions为多个动作配置单个类</p><p>@Namespace和@Namespaces用于创建不同的模块</p><p>@Result用于结果页面</p><p>@ResultPath用于配置结果页面位置</p><h2 id="9-项目中继承ActionSupport并实现ModelDriven接口？"><a href="#9-项目中继承ActionSupport并实现ModelDriven接口？" class="headerlink" title="9. 项目中继承ActionSupport并实现ModelDriven接口？****"></a>9. 项目中继承ActionSupport并实现ModelDriven接口？****</h2><p>struts可以继承ActionSupport类，也可以不继承，继承的好处简单来说就是更方便实现验证，国际化等功能，与struts2的功能结合紧密，方便我们开发。</p><p>ActionSupport类的作用：</p><p>   此类实现了很多实用的接口，提供了很多默认的方法，这些默认方法包括国际化信息，默认的处理用户请求的方法等，可以大大简化action的开发，在继承ActionSupport的情况下，必须有无参构造函数。</p><p>  struts2不要求我们自己设计的action类继承任何的struts基类或struts接口，但是我们为了方便实现我们自己的action，大多数情况下都会继承com.opensymphony.xwork2.ActionSupport类，并重写此类里的public String execute() throws Exception方法。因为此类中实现了很多的实用借口，提供了很多默认方法，这些默认方法包括国际化信息的方法、默认的处理用户请求的方法等，这样可以大大的简化Acion的开发。</p><p>实现了ModelDriven</p><p>可以使用VO，就是提交过来的参抄数（这个参数就百是表单的数据）</p><p>可以直接驱动到action的setXXX（）里面，意思就是说</p><p>实现了ModelDriven就必须百实现getModel这个方法，该方法返回的是你的度ModelDrivern泛型中设定的实体类。其实是为了实现代码的重用，不要再定义问一次你在数据访问层定义的属性了，直接用那答个类就行了。不过有时候也回不是很需要这个东西，答比如只有一两个表单域的时候。</p><h2 id="10-Struts国际化？"><a href="#10-Struts国际化？" class="headerlink" title="10. Struts国际化？****"></a>10. Struts国际化？****</h2><p>国际化（i18n）是规划和实施的产品和服务，使他们能很容易地适应特定的本地语言和文化的过程中，这个过程被称为本地化。国际化的过程有时也被称为翻译或本地化启用。国际化是缩写i18n，因为我和两端用n字打头，并有18个字符之间的第i个和最后n。</p><h2 id="11-如何在Struts2应用程序中上传文件？"><a href="#11-如何在Struts2应用程序中上传文件？" class="headerlink" title="11. 如何在Struts2应用程序中上传文件？****"></a>11. 如何在Struts2应用程序中上传文件？****</h2><p>文件上传是Web应用程序中的常见任务之一。 Struts2通过FileUploadInterceptor提供对文件上传的内置支持。 此拦截器在struts-default包中配置，并提供选项以设置文件的最大大小和可以上载到服务器的文件类型。</p><h2 id="12-Struts2实现文件上传的步骤？"><a href="#12-Struts2实现文件上传的步骤？" class="headerlink" title="12. Struts2实现文件上传的步骤？****"></a>12. Struts2实现文件上传的步骤？****</h2><p>基于表单的文件上传需要下载所需要的jar包文件<strong><em>\</em>Commons-FileUpload组件*****</strong>*、*<strong>**</strong>*需要下载Common-FileUplaod*<strong>* *</strong>*当然MyEclipce中Struts2支持里自带有这两个包****</p><p>基于表单的上传，在form标签中有一个必须的属性值设置：enctype </p><p>如果要做文件上传功能必须将enctype值设为multipart/form-data</p><p>修改struts2配置文件</p><p>配置struts.xml文件，重置fileUpload拦截器</p><p>&lt;interceptor-ref name=<strong>“fileUpload”</strong>&gt;</p><p>​      &lt;param name=<strong>“maximumSize”</strong>&gt;10485760</param> </p><!-- 10M --> </interceptor-ref><p>编写相应的action类</p><h2 id="13-Struts2的核心是什么-体现了什么思想？"><a href="#13-Struts2的核心是什么-体现了什么思想？" class="headerlink" title="13. Struts2的核心是什么? 体现了什么思想？****"></a>13. Struts2的核心是什么? 体现了什么思想？****</h2><p>Struts2的核心是拦截器,基本上核心功能都是由拦截器完成,拦截器的实现体现了AOP(面向切面编程)思想</p><h2 id="14-为何继承ActionSupport"><a href="#14-为何继承ActionSupport" class="headerlink" title="14. 为何继承ActionSupport"></a>14. 为何继承ActionSupport</h2><p>因为ActionSupport实现了Action接口，提供了国际化，校验功能。</p><p>ActionSupport实现了国际化功能：因为它提供了一个getText(String key)方法实现国际化,该方法从资源文件上获取国际化信息。</p><p>Action接口提供了五个常量(success,error,login,input,none)。</p><h2 id="15-Struts2-如何定位action中的方法"><a href="#15-Struts2-如何定位action中的方法" class="headerlink" title="15. Struts2 如何定位action中的方法"></a>15. Struts2 如何定位action中的方法</h2><p>在xml配置文件中通过配置多个action，使用action的method指定方法。</p><p>使用通配符(*)匹配方法。</p><h2 id="16-模型驱动与属性驱动是什么-模型驱动使用时注意什么问题"><a href="#16-模型驱动与属性驱动是什么-模型驱动使用时注意什么问题" class="headerlink" title="16. 模型驱动与属性驱动是什么 模型驱动使用时注意什么问题"></a>16. 模型驱动与属性驱动是什么 模型驱动使用时注意什么问题</h2><p>模型驱动与属性驱动都是用来封装数据的。</p><p>（1）模型驱动：在实现类中实现ModelDriven<T>接口使用泛型把属性类封装起来，重写getModel()方法，然后在实现类里创建一个属性类的实例，</p><p>通过这个实例拿到封装进来的值，拿返回值的时候使用工具进行值拷贝。</p><p>（2）属性驱动：在实现类里定义属性，生成get与set方法，通过属性来拿值。</p><p>注意：模型驱动使用时注意的是在使用前先把属性类实例化，否则会出现空指针错误，拿返回对象的值需要用拷贝内存因为地址发生改变。</p><p>模型驱动不可以使用局部类型转换器。</p><h2 id="17-Struts2是怎样进行值封装的？"><a href="#17-Struts2是怎样进行值封装的？" class="headerlink" title="17. Struts2是怎样进行值封装的？"></a>17. Struts2是怎样进行值封装的？</h2><p>struts2的值封装实际上是采用了ognl表达式</p><p>struts2的拦截器经过模型驱动时会先判断action是否实现了ModelDriven，如果是，则拿到模型的实例放在了栈的顶部，</p><p>到属性驱动的时候会从栈里面把栈顶的实例给取出来，从页面传进来的值放在一个map集合当中，</p><p>通过map集合进行迭代会通过ognl技术把值封装到实例中。</p><h2 id="18-OGNL是什么你在项目中如何使用它-？"><a href="#18-OGNL是什么你在项目中如何使用它-？" class="headerlink" title="18. OGNL是什么你在项目中如何使用它****？"></a>18. OGNL是什么你在项目中如何使用它*<strong>**</strong>*？</h2><p>OGNL是：对象图形导航语言。</p><p>原ognl是单个对象的，在struts2的应用是多个对象的，struts2的类型转换也是通过ognl来实现的。</p><p>Struts2中默认的表达式语言就是ognl，struts2的取值设值都是通过ognl来实现的,struts2要依靠它的标签才可以使用ognl。</p><p>相对于jstl或者其他表达式语言，它有如下优势：</p><p>（1）能够调用对象实例的方法</p><p>（2）能够调用类的静态方法</p><p>（3）操作集合对象</p><p>（4）访问Ognl上下文</p><p>取值时ognl有三个参数：</p><p>（1）表达式</p><p>（2）ognl的上下文(map)</p><p>（3）对象实例(值栈)。</p><p>如果表达式带#号是从上下文中(map)拿值，否则是从值栈中拿值。</p><p>设值时有四个参数：</p><p>（1）表达式，（2）ognl的上下文(map)，（3）对象实例，（4）设入的值</p><p>如果表达式带#号是把值设入上下文中(map)，否则是把值设入值栈中。</p><p>在struts2中 ognl的实现关系:ActionConetxt。</p><p>ognl 3个常用的符号 # $ %</p><p># ：构造map，list集合。取ognl上下文的值。用来过滤集合。</p><p>$ ：在校验框架中取资源文件中的值。可以在配置文件中传递参数。</p><p>% ：使用百分号可以进行转义。</p><h2 id="19-Strust2如何访问Servlet-API-？"><a href="#19-Strust2如何访问Servlet-API-？" class="headerlink" title="19. Strust2如何访问Servlet API****？"></a>19. Strust2如何访问Servlet API*<strong>**</strong>*？</h2><p>答：</p><p>（1）通过ActionContext可以获得request，application，session三个作用域(struts2实际上是通过适配器来把servlet的api转换为一个map，</p><p>并把这些map放在ActionContext里面)。</p><p>（2）通过ActionContext的子类ServletActionContext去获取原滋原味的API。</p><p>（3）可以通过实现ServletRequestAware接口，重写里面的setServletRequest方法可以获得request，实际上是通过set的依赖注入。</p><h2 id="20-什么是拦截器-说说Struts2用拦截器来干什么-说出6个拦截器来"><a href="#20-什么是拦截器-说说Struts2用拦截器来干什么-说出6个拦截器来" class="headerlink" title="20. 什么是拦截器 说说Struts2用拦截器来干什么 说出6个拦截器来****"></a>20. 什么是拦截器 说说Struts2用拦截器来干什么 说出6个拦截器来****</h2><p>在访问类的某个方法或者属性之前执行，拦截的是Action的请求，进行拦截然后在方法的执行前或者之后加入某些操作，如：国际化，权限，效验等与源代码无关的操作。</p><p>拦截器：国际化，表单重复提交，类型转换，自动装配，数据封装,异常处理，模型驱动，请求参数，处理类型转换错误，日志拦截器。</p><p><strong><em>\</em>（*****</strong>*项目中遇到什么问题*<strong>**</strong>*）****</p><p>3.使用模型驱动拿返回值的时候地址内存不一样，会拿不到值。</p><p>原因：因为struts2最开始是把创建action的实例放到ActionContext的栈顶，后来把创建模型驱动的实例放到栈顶，</p><p>而通过struts2的标签去取值会取栈顶的实例，而此时拿到的还是最开始的创建的那个实例，所以为空。</p><p>解决方式：利用原型进行对象拷贝，使用拷贝工具，BeanUtils或者是propertyUtils。</p><h2 id="21-ActionContext是用来干什么用的？"><a href="#21-ActionContext是用来干什么用的？" class="headerlink" title="21. ActionContext是用来干什么用的？"></a>21. ActionContext是用来干什么用的？</h2><p>答：ActionContext是Action的上下文。</p><p>通过ActionContext这个类来可以获得:request，application，session，Locale、ValueStack,ConversionErrors</p><p>（1）可以获得servlet的api：request，application，session。</p><p>（2）进行国际化：获得语言环境 Locale。</p><p>（3）收集错误信息：ConversionErrors。</p><p>（4）有个值栈来装action实例与创建的模型驱动的实例:ValueStack。</p><p>（5）ActionContext是线程安全的-用本地线程实现的。</p><h2 id="22-Struts2是如何实现mvc的：struts2的底层视图默认是freemaker。什么mvc？"><a href="#22-Struts2是如何实现mvc的：struts2的底层视图默认是freemaker。什么mvc？" class="headerlink" title="22. Struts2是如何实现mvc的：struts2的底层视图默认是freemaker。什么mvc？****"></a>22. Struts2是如何实现mvc的：struts2的底层视图默认是freemaker。什么mvc？****</h2><p>M：模型，V：视图，C：控制器</p><p>在struts2中分别对应什么？</p><p>M(模型)：除核心控制器外都属于模型，实现业务的类(service层与dao层)。</p><p>V(视图)：result,type,dispatcher默认的(jsp，freemaker，velocity，源代码等)。</p><p>C(控制器)：核心控制器与业务控制器。</p><p>mvc解决什么问题？</p><p>解决了数据封装，类型转换，数据效验，国际化，异常处理等问题。</p><h2 id="23-开发项目时struts2在页面怎样拿值？"><a href="#23-开发项目时struts2在页面怎样拿值？" class="headerlink" title="23. 开发项目时struts2在页面怎样拿值？"></a>23. 开发项目时struts2在页面怎样拿值？</h2><p>从值栈中或者是ognl的上下文中取值</p><h2 id="24-怎么样用Struts2进行文件的上传或者下载"><a href="#24-怎么样用Struts2进行文件的上传或者下载" class="headerlink" title="24. 怎么样用Struts2进行文件的上传或者下载\"></a>24. 怎么样用Struts2进行文件的上传或者下载\</h2><p>上传：Struts2里面已经提供了默认的拦截器来处理上传,只要在jsp用了s:file标签,把s:from的enctype 属性设置为 multipart/form-data,然后在action里面定义三个字段 File file ,String [file]ContentType,String [file]?FileName即可,如果有多个文件上传,那么就用List<File>来接受,然后把接受到的File构建成FileInputStream,转化成硬盘上面的文件即可(用输出流)</p><p>下载：用了resust为stream的类型,然后在action定义四个属性,默认的有个是InputStream 的类型叫inputStream的,从硬盘上面读取文件到这个流赋值即可.</p><h2 id="25-简单讲下struts里面的标签-说不少于5个"><a href="#25-简单讲下struts里面的标签-说不少于5个" class="headerlink" title="25. 简单讲下struts里面的标签,说不少于5个****"></a>25. 简单讲下struts里面的标签,说不少于5个****</h2><p>s:iterater ?s:property s:form s:url s:if 等等</p><h2 id="26-默认struts2里面的标签取值都是从那里取值的"><a href="#26-默认struts2里面的标签取值都是从那里取值的" class="headerlink" title="26.默认struts2里面的标签取值都是从那里取值的****"></a>26.默认struts2里面的标签取值都是从那里取值的****</h2><p>默认都是从OGNL值栈里面取值的</p><h2 id="27-ValueStack分为那两部分-组成部分是什么-分别怎么访问"><a href="#27-ValueStack分为那两部分-组成部分是什么-分别怎么访问" class="headerlink" title="27. ValueStack分为那两部分,组成部分是什么,分别怎么访问****"></a>27. ValueStack分为那两部分,组成部分是什么,分别怎么访问****</h2><p>分为对象栈和ContextMap ,对象栈里面放入的是Action及其用户定义的对象,在前台可以直接访问,在contextMap里面放入的是Servlet对象转化后map,譬如requestMap,sessionMap,访问的时候前面加#即可。</p><h2 id="28-struts2的请求处理流程"><a href="#28-struts2的请求处理流程" class="headerlink" title="28. struts2的请求处理流程\"></a>28. struts2的请求处理流程\</h2><p>（1）客户端发送请求。</p><p>（2）经过一系列的过滤器（如:ActionContextCleanUp、SiteMesh等）到达核心控制器（FilterDispatcher）。</p><p>（3）核心控制器通过ActionMapper决定调用哪个Action，如果不是调用Action就直接跳转到jsp页面</p><p>（4）如果ActionMapper决定调用了某个Action，核心控制器就把请求的处理交给一个代理类（ActionProxy）。</p><p>（5）代理类通过配置管理器(Configuration Manager)找到配置文件（struts.xml）找到需要调用的Action类。</p><p>（6）代理类还要创建一个Action的调度器（ActionInvocation）。</p><p>（7）由调度器去调用Action，当然这里还涉及到一些相关的拦截器的调用。</p><p>（8）Action执行完后，这个调度器还会创建一个Result返回结果集，返回结果前还可以做一些操作（结果集前的监听器）。</p><h2 id="29-struts2源码与设计模式"><a href="#29-struts2源码与设计模式" class="headerlink" title="29. struts2源码与设计模式"></a>29. struts2源码与设计模式</h2><p>命令模式(发生.do请求封装成action调用execute方法)，代理模式(访问action时核心控制器把请求交给代理类(ActionProxy)去访问Action就是代理模式)，</p><p>责任链模式(访问action时经过一系列的拦截器就使用了责任链模式)，适配器(把Servlet的API通过适配器转换成Map，把Map放入ActionContext中)，</p><p>组合模式(拦截器栈和拦截器就使用到组和模式)。</p><p>源码：</p><p>服务器启动的时候容器会创建FilterDispatcher实例，进入dispatcher.init()方法，在init方法里面会初始化sturts2的一系列的配置文件，然后向服务器发送请求，进入doFilter方法，在里面通过调用dispatcher.serviceAction方法,进入到Dispatcher里面的serviceAction方法，在这里就会把servlet的api转换为map，并把它一个个的放在ActionContext中，在这里还会创建ActionProxy的实例去调用execute方法，到StrutsActionProxy的execute方法，通过DefaultActionInvocation的实例去调用invoke方法，在invoke方法里面会进行判断拦截器是否存在，如果存在就会调用intercept方法，在拦截器类(Intercept)中会通过DefaultActionInvocation实例调用里面的invock方法,它们会形成递归调用，当拦截器不存在的时候就会进入invokeActionOnly方法，判断有没有返回结果前的监听器preResultListener如果有则进去一个个执行，最后调用 executeResult()方法，创建result返回，执行execute方法，并返回视图。</p><h2 id="30-struts2工作流程"><a href="#30-struts2工作流程" class="headerlink" title="30. struts2工作流程"></a>30. struts2工作流程</h2><p>1、Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。</p><p>（1）核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。</p><p>（2）业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。</p><p>​    Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。</p><p><strong><em>\</em>简要执行流程：**</strong></p><p>（1）客户端初始化一个指向Servlet容器的请求；</p><p>（2）这个请求经过一系列的过滤器（Filter）</p><p>​    （这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin）</p><p>（3）接着FilterDispatcher被调用，</p><p>​     FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action</p><p>（4）如果ActionMapper决定需要调用某个Action，</p><p>​     FilterDispatcher把请求的处理交给ActionProxy</p><p>（5）ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类</p><p>（6）ActionProxy创建一个ActionInvocation的实例。</p><p>（7）ActionInvocation实例使用命名模式来调用，</p><p>​     在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。</p><p>（8）一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。    在这个过程中需要涉及到ActionMapper</p><p>（9）响应的返回是通过我们在web.xml中配置的过滤器</p><p>（10）如果ActionContextCleanUp是当前使用的，则FilterDispatecher将不会清理sreadlocal ActionContext;如果ActionContextCleanUp不使用，则将会去清理sreadlocals。 </p><h2 id="31-拦截器和过滤器的区别？"><a href="#31-拦截器和过滤器的区别？" class="headerlink" title="31. 拦截器和过滤器的区别？"></a>31. 拦截器和过滤器的区别？</h2><p>1、拦截器是基于Java反射机制的，而过滤器是基于函数回调的。</p><p>2、过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。</p><p>3、拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。</p><p>4、拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。</p><p>5、在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。</p><h2 id="32-Struts2是如何启动的？"><a href="#32-Struts2是如何启动的？" class="headerlink" title="32. Struts2是如何启动的？\"></a>32. Struts2是如何启动的？\</h2><p>1、struts2框架是通过Filter启动的，即StrutsPrepareAndExecuteFilter，此过滤器为struts2的核心过滤器； </p><p>2、StrutsPrepareAndExecuteFilter的init()方法中将会读取类路径下默认的配置文件struts.xml完成初始化操作。struts2读取到struts.xml的内容后，是将内容封装进javabean对象然后存放在内存中，以后用户的每次请求处理将使用内存中的数据，而不是每次请求都读取struts.xml文件。</p><h2 id="33-Struts2的核心控制器是什么？它是什么作用？"><a href="#33-Struts2的核心控制器是什么？它是什么作用？" class="headerlink" title="33. Struts2的核心控制器是什么？它是什么作用？\"></a>33. Struts2的核心控制器是什么？它是什么作用？\</h2><p>1、Struts2框架的核心控制器是StrutsPrepareAndExecuteFilter。 </p><p>2、作用： </p><p> 负责拦截由<url-pattern>/*</url-pattern>指定的所有用户请求，当用户请求到达时，该Filter会过滤用户的请求。默认情况下，如果用户请求的路径 </p><p>不带后缀或者后缀以.action结尾，这时请求将被转入struts2框架处理，否则struts2框架将略过该请求的处理。 </p><p>可以通过常量”struts.action.extension”修改action的后缀，如： </p><constant name="struts.action.extension" value="do"/> <p>如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开。</p><constant name="struts.action.extension" value="do,Go"/>  <h2 id="34-struts2是如何管理action的？这种管理方式有什么好处？"><a href="#34-struts2是如何管理action的？这种管理方式有什么好处？" class="headerlink" title="34. struts2是如何管理action的？这种管理方式有什么好处？"></a>34. struts2是如何管理action的？这种管理方式有什么好处？</h2><p>struts2框架中使用包来管理Action，包的作用和java中的类包是非常类似的。 </p><p>主要用于管理一组业务功能相关的action。在实际应用中，我们应该把一组业务功能相关的Action放在同一个包下。 </p><p>struts2中的默认包struts-default有什么作用？ </p><p>（1）struts-default包是由struts内置的，它定义了struts2内部的众多拦截器和Result类型，而Struts2很多核心的功能都是通过这些内置的拦截器实现，如：从请求中 </p><p>把请求参数封装到action、文件上传和数据验证等等都是通过拦截器实现的。当包继承了struts-default包才能使用struts2为我们提供的这些功能。 </p><p>（2）struts-default包是在struts-default.xml中定义，struts-default.xml也是Struts2默认配置文件。 Struts2每次都会自动加载 struts-default.xml文件。 </p><p>（3）通常每个包都应该继承struts-default包。   </p><h2 id="35-值栈ValueStack的原理与生命周期？"><a href="#35-值栈ValueStack的原理与生命周期？" class="headerlink" title="35. 值栈ValueStack的原理与生命周期？"></a>35. 值栈ValueStack的原理与生命周期？</h2><p>（1）ValueStack贯穿整个 Action 的生命周期，保存在request域中，所以ValueStack和request的生命周期一样。当Struts2接受一个请求时，会迅速创建ActionContext， ValueStack，action。然后把action存放进ValueStack，所以action的实例变量可以被OGNL访问。 请求来的时候，action、ValueStack的生命开始，请求结束，action、  ValueStack的生命结束； </p><p>（2）action是多例的，和Servlet不一样，Servelt是单例的； </p><p>（3）每个action的都有一个对应的值栈，值栈存放的数据类型是该action的实例，以及该action中的实例变量，Action对象默认保存在栈顶； </p><p>（4）ValueStack本质上就是一个ArrayList； </p><p>（5）关于ContextMap，Struts 会把下面这些映射压入 ContextMap 中： </p><p>parameters ：该 Map 中包含当前请求的请求参数</p><p>request ： 该 Map 中包含当前 request 对象中的所有属性 </p><p>session ：该 Map 中包含当前 session 对象中的所有属性 </p><p>Application：该 Map 中包含当前 application 对象中的所有属性 </p><p>attr：该 Map 按如下顺序来检索某个属性: request, session, application     </p><p>（6）使用OGNL访问值栈的内容时，不需要#号，而访问request、session、application、attr时，需要加#号； </p><p>（7）注意： Struts2中，OGNL表达式需要配合Struts标签才可以使用。如：&lt;s:property value=”name”/&gt; </p><p>（8）在struts2配置文件中引用ognl表达式 ,引用值栈的值 ，此时使用的”$”，而不是#或者%; </p><h2 id="36-ActionContext、ServletContext、pageContext的区别？"><a href="#36-ActionContext、ServletContext、pageContext的区别？" class="headerlink" title="36. ActionContext、ServletContext、pageContext的区别？"></a>36. ActionContext、ServletContext、pageContext的区别？</h2><p>（1）ActionContext是当前的Action的上下文环境，通过ActionContext可以获取到request、session、ServletContext等与Action有关的对象的引用； </p><p>（2）ServletContext是域对象，一个web应用中只有一个ServletContext，生命周期伴随整个web应用； </p><p>（3）pageContext是JSP中的最重要的一个内置对象，可以通过pageContext获取其他域对象的应用，同时它是一个域对象，作用范围只针对当前页面，当前页面结束时，pageContext销毁， </p><p>生命周期是JSP四个域对象中最小的。 </p><h2 id="37-struts的工作原理"><a href="#37-struts的工作原理" class="headerlink" title="37. struts的工作原理"></a>37. struts的工作原理</h2><p>（1）初始化，读取struts-config.xml、web.xml等配置文件（所有配置文件的初始化）</p><p>（2）发送HTTP请求,客户端发送以.do结尾的请求</p><p>（3）填充FormBean（实例化、复位、填充数据、校验、保存）</p><p>（4）将请求转发到Action（调用Action的execute（）方法）</p><p>（5）处理业务（可以调用后台类，返回ActionForward对象）</p><p>（6）返回目标响应对象（从Action返回到ActionServlet）</p><p>（7）转换Http请求到目标响应对象（查找响应，根据返回的Forward keyword）</p><p>（8）Http响应，返回到Jsp页面</p><h2 id="38-用自己的话简要阐述struts2的执行流程。"><a href="#38-用自己的话简要阐述struts2的执行流程。" class="headerlink" title="38. 用自己的话简要阐述struts2的执行流程。"></a>38. 用自己的话简要阐述struts2的执行流程。</h2><p>Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。</p><p>核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。</p><p>Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。基本简要流程如下：</p><p>（1）客户端浏览器发出HTTP请求。</p><p>（2）根据web.xml配置，该请求被FilterDispatcher接收。</p><p>（3）根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。</p><p>（4）Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。</p><p>（5）Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。</p><p>（6）返回HTTP响应到客户端浏览器。</p><p>它是以Webwork的设计思想为核心，吸收struts1的优点，可以说 struts2是struts1和Webwork结合的产物。</p><h3 id="struts2-的工作原理图：-一个请求在Struts2框架中的处理分为以下几个步骤："><a href="#struts2-的工作原理图：-一个请求在Struts2框架中的处理分为以下几个步骤：" class="headerlink" title="struts2 的工作原理图： 一个请求在Struts2框架中的处理分为以下几个步骤："></a>struts2 的工作原理图： 一个请求在Struts2框架中的处理分为以下几个步骤：</h3><p>（1）客户端发出一个指向servlet容器的请求(tomcat)；</p><p>（2）这个请求会经过图中的几个过滤器，最后会到达FilterDispatcher过滤器。</p><p>（3）过滤器FilterDispatcher是struts2框架的心脏，在处理用户请求时，它和请求一起相互配合访问struts2 的底层框架结构。在web容器启动时，struts2框架会自动加载配置文件里相关参数，并转换成相应的类。 </p><p>如：ConfigurationManager、ActionMapper和ObjectFactory。ConfigurationManager 存有配置文件的一 些基本信息，ActionMapper存有action的配置信息。在请求过程中所有的对象（Action，Results， Interceptors，等）都是通过ObjectFactory来创建的。过滤器会通过询问ActionMapper类来查找请求中 需要用到的Action。</p><p>（4）如果找到需要调用的Action，过滤器会把请求的处理交给ActionProxy。ActionProxy为Action的代理对象 。ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action类。 </p><p>（5）ActionProxy创建一个ActionInvocation的实例。ActionInvocation在ActionProxy层之下，它表示了 Action的执行状态,或者说它控制的Action的执行步骤。它持有Action实例和所有的Interceptor。 </p><p>（6）ActionInvocation实例使用命名模式来调用，1） ActionInvocation初始化时，根据配置，加载Action相 关的所有Interceptor。2）通过ActionInvocation.invoke方法调用Action实现时，执行Interceptor。在 调用Action的过程前后，涉及到相关拦截器(intercepetor)的调用。</p><p>（7）一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果 通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表 示的过程中可以使用Struts2 框架中继承的标签。</p><h2 id="39-Struts2-如何访问-HttpServletRequest、HttpSession、ServletContext-三个域对象"><a href="#39-Struts2-如何访问-HttpServletRequest、HttpSession、ServletContext-三个域对象" class="headerlink" title="39. Struts2 如何访问 HttpServletRequest、HttpSession、ServletContext 三个域对象 ?"></a>39. Struts2 如何访问 HttpServletRequest、HttpSession、ServletContext 三个域对象 ?</h2><p>①. 与 Servlet API 解耦的访问方式</p><p>　　&gt; 通过 ActionContext 访问域对象对应的 Map 对象</p><p>　　&gt; 通过实现 Aware 接口使 Struts2 注入对应的 Map 对象</p><p>②. 与 Servlet API 耦合的访问方式</p><p>　　&gt; 通过 ServletActionContext 直接获取 Servlet API 对象</p><p>　　&gt; 通过实现 ServletXxxAware 接口的方式使 Struts2 注入对应的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是Struts2？&quot;&gt;&lt;a href=&quot;#1-什么是Struts2？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Struts2？&quot;&gt;&lt;/a&gt;1. 什么是Struts2？&lt;/h2&gt;&lt;p&gt;Struts2是一个用Java构建Web应用程序的开源框架。Struts2基于OpenSymphony WebWork框架。它从Struts1中得到了很大的改进，使其更加灵活，易于使用和扩展。Struts2的核心组件是Action，Interceptors和Result页面。&lt;/p&gt;
&lt;p&gt;Struts2提供了许多方法来创建Action类并通过struts.xml或注释来配置它们。我们可以为常见任务创建自己的拦截器。Struts2附带了很多标签，并使用OGNL表达式语言。我们可以创建自己的类型转换器来渲染结果页面。结果页面可以是JSP和FreeMarker模板。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试整理0406</title>
    <link href="http://yoursite.com/2020/06/06/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%860406/"/>
    <id>http://yoursite.com/2020/06/06/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%860406/</id>
    <published>2020-06-06T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-本地线程-theadlocal-volital-线程锁-线程池-callable应用场景-优点"><a href="#1-本地线程-theadlocal-volital-线程锁-线程池-callable应用场景-优点" class="headerlink" title="1.本地线程  theadlocal  volital  线程锁  线程池  callable应用场景  优点"></a>1.本地线程  theadlocal  volital  线程锁  线程池  callable应用场景  优点</h3><h4 id="1-1-什么是本地线程？"><a href="#1-1-什么是本地线程？" class="headerlink" title="1.1 什么是本地线程？"></a>1.1 什么是本地线程？</h4><p>Threadlocal意思就是线程本地的意思。ThreadLocal字面意思是本地线程，其实更准确来说是线程局部变量。</p><p>我们知道，在多线程并发执行时，一方面，需要进行数据共享，于是才有了volatile变量解决多线程间的数据可见性，也有了锁的同步机制，使变量或代码块在某一时该，只能被一个线程访问，确保数据共享的正确性。其中，Synchronized用于线程间的数据共享的。另一方面，并不是所有数据都需要共享的，这些不需要共享的数据，让每个线程单独去维护就行了，ThreadLocal就是用于线程间的数据隔离的。</p> <a id="more"></a><p>ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程，获取保存的值时非常方便，ThreadLocal为变量在每个线程中都创建了一个副本，每个线程就可以很方便的访问自己内部的副本变量。</p><h4 id="1-2-在java中守护线程和本地线程有什么区别？"><a href="#1-2-在java中守护线程和本地线程有什么区别？" class="headerlink" title="1.2 在java中守护线程和本地线程有什么区别？"></a>1.2 在java中守护线程和本地线程有什么区别？</h4><p>java中的线程分为两种：守护线程（Daemon）和用户线程（User）。任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。在java中守护线程和本地线程有什么区别呢？</p><p>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。</p><p>在JVM启动时候会调用main函数，main函数所在的线程是一个用户线程，这个是我们可以看到的线程，其实JVM内部同时还启动了好多守护线程，比如垃圾回收线程。那么守护线程和用户线程有什么区别那？区别之一是当最后一个非守护线程结束时候，JVM会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响JVM的退出。言外之意是只要有一个用户线程还没结束正常情况下JVM就不会退出。</p><p>如果你想在主线程结束后JVM进程马上结束，那么创建线程的时候可以设置线程为守护线程，否者如果希望主线程结束后子线程继续工作，等子线程结束后在让JVM进程结束那么就设置子线程为用户线程，Tomcat框架就是用了守护线程和用户线程联合运行起来的</p><h3 id="1-3-volital-关键字作用？"><a href="#1-3-volital-关键字作用？" class="headerlink" title="1.3 volital  关键字作用？"></a>1.3 volital  关键字作用？</h3><h4 id="1-4-什么是线程池？"><a href="#1-4-什么是线程池？" class="headerlink" title="1.4 什么是线程池？"></a>1.4 什么是线程池？</h4><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p><p>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。</p><p>Java中有三个比较常用的线程池，分别是FixedThreadPool，</p><p>SingleThreadExecutor，CachedThreadPool。</p><p>1)  FixedThreadPool</p><p>　　这是一个线程数固定的线程池，当这个线程池被创建的时候，池里的线程数就已经固定了。当需要运行的线程数量大体上变化不大时，适合使用这种线程池。固定数量还有一个好处，它可以一次性支付高昂的创建线程的开销，之后再使用的时候就不再需要这种开销。</p><p>2)  SingleThreadExecutor</p><p>　　这是一个线程数量为1的线程池，所有提交的这个线程池的任务都会按照提交的先后顺序排队执行。单个线程执行有个好处：由于任务之间没有并发执行，因此提交到线程池种的任务之间不会相互干扰。程序执行的结果更具有确定性。</p><p>3)  CachedThreadPool</p><p>　　一看到Cache就知道这是一个和缓存有关的线程池，每次有任务提交到线程池的时候，如果池中没有空闲的线程，线程池就会为这个任务创建一个线程，如果有空闲的线程，就会使用已有的空闲线程执行任务。有的人可能会有个疑惑：这样线程不就越来越多了吗？其实不是的，这个线程池还有一个销毁机制，如果一个线程60秒之内没有被使用过，这个线程就会被销毁，这样就节省了很多资源。CachedThreadPool是一个比较通用的线程池，它在多数情况下都能表现出优良的性能。以后编码的时候，遇事不决，用缓存（线程池）。</p><h3 id="1-5-callable应用场景，优点是什么？"><a href="#1-5-callable应用场景，优点是什么？" class="headerlink" title="1.5 callable应用场景，优点是什么？"></a>1.5 callable应用场景，优点是什么？</h3><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>　　而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><h2 id="2-redis-mybatis-二级缓存-一级缓存-spring源码"><a href="#2-redis-mybatis-二级缓存-一级缓存-spring源码" class="headerlink" title="2.redis  mybatis  二级缓存  一级缓存 spring源码"></a>2.redis  mybatis  二级缓存  一级缓存 spring源码</h2><p>一级缓存就是同一个sqlsession中查询一致。则第一次查询到的结果缓存到内存。后续查询则直接读取缓存。</p><p>但是spring封装的方法  每一次提交事务都是打开关闭一个sqlsession。所以一级缓存用不到。</p><p>Mybatis一级缓存：Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p><p>Mybatis二级缓存：MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开席需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了</p><h3 id="3-dubbo-消费者-生产者-区-组-版本号分"><a href="#3-dubbo-消费者-生产者-区-组-版本号分" class="headerlink" title="3. dubbo  消费者  生产者  区  组  版本号分"></a>3. dubbo  消费者  生产者  区  组  版本号分</h3><p>3.1 Dubbo</p><h2 id="4-事务传播行为-数据库事务隔离级别"><a href="#4-事务传播行为-数据库事务隔离级别" class="headerlink" title="4. 事务传播行为   数据库事务隔离级别"></a>4. 事务传播行为   数据库事务隔离级别</h2><h3 id="4-1-数据库事务隔离级别"><a href="#4-1-数据库事务隔离级别" class="headerlink" title="4.1 数据库事务隔离级别"></a>4.1 数据库事务隔离级别</h3><ol><li>脏读：</li></ol><p>脏读是指一个事务处理过程中读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p><ol start="2"><li>不可重复读</li></ol><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询隔离间隔中，被另一个事务修改并提交了。</p><p>例如事务T1在读取某一个数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>不可重复读和读脏的区别是，读脏是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务未提交的数据。</p><p>脏数据：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据(Dirty Data)，依据脏数据所做的操作可能是不正确的。</p><p>不可重复读：在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读</p><ol start="3"><li>虚读（幻读）</li></ol><p>虚读是事务非独立执行时发生的一种现象，例如事务T1对一个表中所有的行的某个数据项做了从1修改为2的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为1并且提交给数据库，而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生了幻觉一样，这就是幻读。</p><h2 id="aop-ioc-几种注入"><a href="#aop-ioc-几种注入" class="headerlink" title="aop  ioc  几种注入"></a>aop  ioc  几种注入</h2><h3 id="5-1-什么是AOP"><a href="#5-1-什么是AOP" class="headerlink" title="5.1 什么是AOP"></a>5.1 什么是AOP</h3><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。然而殊途同归，实现AOP的技术特性却是相同的，分别为：</p><p>1、join point（连接点）：是程序执行中的一个精确执行点，例如类中的一个方法。它是一个抽象的概念，在实现AOP时，并不需要去定义一个join point。</p><p>2、point cut（切入点）：本质上是一个捕获连接点的结构。在AOP中，可以定义一个point cut，来捕获相关方法的调用。</p><p>3、advice（通知）：是point cut的执行代码，是执行“方面”的具体逻辑。</p><p>4、aspect（方面）：point cut和advice结合起来就是aspect，它类似于OOP中定义的一个类，但它代表的更多是对象间横向的关系。</p><p>5、introduce（引入）：为对象引入附加的方法或属性，从而达到修改对象结构的目的。有的AOP工具又将其称为mixin。</p><h3 id="5-2-什么是IOC"><a href="#5-2-什么是IOC" class="headerlink" title="5.2 什么是IOC"></a>5.2 什么是IOC</h3><p>IOC是一种思想，控制反转，在java开发中，就是将你设计好的对象交给容器控制，而不是显示的用代码进行对象的创建。</p><p>把创建和查找对象的控制权交给IOC容器，由IOC容器进行注入、组合对象，这样对象与对象之间是松耦合、便于测试、功能可复用（减少对象的创建和内存消耗），使得程序的整个体系结构可维护性、灵活性、扩展性变高。</p><p>使用IOC的好处：资源集中管理，实现资源的可配置和容易管理，降低了资源的依赖程度，即松耦合，便于测试，功能可复用</p><h3 id="5-3-什么是DI"><a href="#5-3-什么是DI" class="headerlink" title="5.3 什么是DI"></a>5.3 什么是DI</h3><p>DI 是指依赖注入，是IOC容器装配、注入对象的一种方式。通过依赖注入机制，简单的配置即可注入需要的资源，完成自身的业务逻辑，不需要关心资源的出处和具体实现。</p><p>Spring提供了三种主要的方式来配置IOC容器中的bean</p><p>①基于XML文件配置</p><p>②基于注解配置</p><p>③基于注解+java代码显示的配置</p><h3 id="6-数据库优化"><a href="#6-数据库优化" class="headerlink" title="6. 数据库优化"></a>6. 数据库优化</h3><h4 id="6-1-数据库优化的几种方式："><a href="#6-1-数据库优化的几种方式：" class="headerlink" title="6.1 数据库优化的几种方式："></a>6.1 数据库优化的几种方式：</h4><h6 id="一、创建索引："><a href="#一、创建索引：" class="headerlink" title="一、创建索引："></a>一、创建索引：</h6><p>\1. 要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引 。</p><p>\2. (1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。 </p><p>  (2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。 </p><p>  (3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</p><h6 id="二、避免在索引上使用计算"><a href="#二、避免在索引上使用计算" class="headerlink" title="二、避免在索引上使用计算"></a>二、避免在索引上使用计算</h6><p>在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。</p><h5 id="三、使用预编译查询"><a href="#三、使用预编译查询" class="headerlink" title="三、使用预编译查询"></a>三、使用预编译查询</h5><p>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</p><h5 id="四、调整Where字句中的连接顺序"><a href="#四、调整Where字句中的连接顺序" class="headerlink" title="四、调整Where字句中的连接顺序"></a>四、调整Where字句中的连接顺序</h5><p>DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。</p><h6 id="五、尽量将多条SQL语句压缩到一句SQL中"><a href="#五、尽量将多条SQL语句压缩到一句SQL中" class="headerlink" title="五、尽量将多条SQL语句压缩到一句SQL中"></a>五、尽量将多条SQL语句压缩到一句SQL中</h6><p>每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。</p><h5 id="六、用where字句替换HAVING字句"><a href="#六、用where字句替换HAVING字句" class="headerlink" title="六、用where字句替换HAVING字句"></a>六、用where字句替换HAVING字句</h5><p>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数 的过滤，除此之外，应该将条件写在where字句中。</p><h5 id="七、使用表的别名"><a href="#七、使用表的别名" class="headerlink" title="七、使用表的别名"></a>七、使用表的别名</h5><p>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 少哪些友列名歧义引起的语法错误。</p><h5 id="八、考虑使用临时表暂存中间结果"><a href="#八、考虑使用临时表暂存中间结果" class="headerlink" title="八、考虑使用临时表暂存中间结果"></a>八、考虑使用临时表暂存中间结果</h5><p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。 但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><h3 id="7-序列化-静态属性会不会序列化-关键字-父类-是否序列化"><a href="#7-序列化-静态属性会不会序列化-关键字-父类-是否序列化" class="headerlink" title="7. 序列化  静态属性会不会序列化  关键字  父类  是否序列化"></a>7. 序列化  静态属性会不会序列化  关键字  父类  是否序列化</h3><h5 id="7-1-什么是序列化？"><a href="#7-1-什么是序列化？" class="headerlink" title="7.1 什么是序列化？"></a>7.1 什么是序列化？</h5><p>序列化是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p><p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p><p>   然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><p>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p><p>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p><p>\8. nio  aio  bio</p><p>\9. java8新特性</p><p>9.1 java8的新特性</p><p>（1）Lambda 表达式</p><h3 id="10-jvm内存模型jmm"><a href="#10-jvm内存模型jmm" class="headerlink" title="10. jvm内存模型jmm"></a>10. jvm内存模型jmm</h3><p>首先要说一下JVM内存空间分为五部分，分别是：方法区、堆、Java虚拟机栈、本地方法栈、程序计数器</p><p>方法区主要用来存放类信息、类的静态变量、常量、运行时常量池等，方法区的大小是可以动态扩展的，</p><p>堆主要存放的是数组、类的实例对象、字符串常量池等。</p><p>Java虚拟机栈是描述JAVA方法运行过程的内存模型，Java虚拟机栈会为每一个即将执行的方法创建一个叫做“栈帧”的区域，该区域用来存储该方法运行时需要的一些信息，包括：局部变量表、操作数栈、动态链接、方法返回地址等。比如我们方法执行过程中需要创建变量时，就会将局部变量插入到局部变量表中，局部变量的运算、传递等在操作数栈中进行，当方法执行结束后，这个方法对应的栈帧将出栈，并释放内存空间。栈中会发生的两种异常，StackOverFlowError和OutOfMemoryError,StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。</p><p>本地方法栈结构上和Java虚拟机栈一样，只不过Java虚拟机栈是运行Java方法的区域，而本地方法栈是运行本地方法的内存模型。运行本地方法时也会创建栈帧，同样栈帧里也有局部变量表、操作数栈、动态链接和方法返回地址等，在本地方法执行结束后栈帧也会出栈并释放内存资源，也会发生OutOfMemoryError。</p><p>最后是程序计数器，程序计数器是一个比较小的内存空间，用来记录当前线程正在执行的那一条字节码指令的地址。如果当前线程正在执行的是本地方法，那么此时程序计数器为空。程序计数器有两个作用，1、字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，比如我们常见的顺序、循环、选择、异常处理等。2、在多线程的情况下，程序计数器用来记录当前线程执行的位置，当线程切换回来的时候仍然可以知道该线程上次执行到了哪里。而且程序计数器是唯一一个不会出现OutOfMeroryError的内存区域。</p><p>方法区和堆都是线程共享的，在JVM启动时创建，在JVM停止时销毁，而Java虚拟机栈、本地方法栈、程序计数器是线程私有的，随线程的创建而创建，随线程的结束而死亡。</p><h3 id="11-hashcode-equals-线程安全的hashmap？"><a href="#11-hashcode-equals-线程安全的hashmap？" class="headerlink" title="11. hashcode  equals  线程安全的hashmap？"></a>11. hashcode  equals  线程安全的hashmap？</h3><p>hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？</p><p>因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？</p><p>因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：</p><p>（1）equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</p><p>（2）hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p><p>所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p><p> 这种大量的并且快速的对象对比一般使用的hash容器中，比如hashset,hashmap,hashtable等等，比如hashset里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equal()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-本地线程-theadlocal-volital-线程锁-线程池-callable应用场景-优点&quot;&gt;&lt;a href=&quot;#1-本地线程-theadlocal-volital-线程锁-线程池-callable应用场景-优点&quot; class=&quot;headerlink&quot; title=&quot;1.本地线程  theadlocal  volital  线程锁  线程池  callable应用场景  优点&quot;&gt;&lt;/a&gt;1.本地线程  theadlocal  volital  线程锁  线程池  callable应用场景  优点&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是本地线程？&quot;&gt;&lt;a href=&quot;#1-1-什么是本地线程？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是本地线程？&quot;&gt;&lt;/a&gt;1.1 什么是本地线程？&lt;/h4&gt;&lt;p&gt;Threadlocal意思就是线程本地的意思。ThreadLocal字面意思是本地线程，其实更准确来说是线程局部变量。&lt;/p&gt;
&lt;p&gt;我们知道，在多线程并发执行时，一方面，需要进行数据共享，于是才有了volatile变量解决多线程间的数据可见性，也有了锁的同步机制，使变量或代码块在某一时该，只能被一个线程访问，确保数据共享的正确性。其中，Synchronized用于线程间的数据共享的。另一方面，并不是所有数据都需要共享的，这些不需要共享的数据，让每个线程单独去维护就行了，ThreadLocal就是用于线程间的数据隔离的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试，阿里" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>阿里面试整理</title>
    <link href="http://yoursite.com/2020/06/06/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/06/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-06T10:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-类修饰词default和protected关系"><a href="#1-类修饰词default和protected关系" class="headerlink" title="1. 类修饰词default和protected关系"></a>1. 类修饰词default和protected关系</h2><p>Java一共有四类类修饰符，private  default，public protected</p><p>protected 包内所有类可见，包外有继承关系的子类可见。</p><p>default表示默认，不仅本类访问，而且是同包可见。</p><p>当修饰词是private时，只有类内能够访问到，其他任何类都不能直接访问到。</p><p>当修饰词是public时，任何类内都能访问到。</p><a id="more"></a><h3 id="2-参数传递，值传递和引用传递的关系，String和char数组作为入参，结果会改变吗"><a href="#2-参数传递，值传递和引用传递的关系，String和char数组作为入参，结果会改变吗" class="headerlink" title="2.参数传递，值传递和引用传递的关系，String和char数组作为入参，结果会改变吗"></a>2.参数传递，值传递和引用传递的关系，String和char数组作为入参，结果会改变吗</h3><p>值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。</p><p>引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。</p><p>String 比较特别，看过String 代码的都知道， String 是 final的。所以值是不变的。 函数中String对象引用的副本指向了另外一个新String对象,而数组对象引用的副本没有改变,而是改变对象中数据的内容.  </p><p>String作为参数传入时，因为在java中都是传递的是参数的引用，也就是按值传递的，String作为参数时，传递的是String数据的拷贝，那么方法中是不会改变数据本身的内容，char[]作为参数入参时，传递的是引用类型也就是数组的指向的引用的拷贝，引用的拷贝也是指向数组，所以对改变原数组的值。</p><h2 id="3-异常都有几大类？运行时的空指针会抛异常吗？IO-Exception异常发生需要自己去捕获？"><a href="#3-异常都有几大类？运行时的空指针会抛异常吗？IO-Exception异常发生需要自己去捕获？" class="headerlink" title="3.异常都有几大类？运行时的空指针会抛异常吗？IO Exception异常发生需要自己去捕获？"></a>3.异常都有几大类？运行时的空指针会抛异常吗？IO Exception异常发生需要自己去捕获？</h2><p>Java中的异常主要分为运行时异常runtimeExclrtion和非运行时异常IOExcletion，</p><p>运行时异常，主要是程序的编写存在问题，javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。比如数组越界异常，类未找到异常等等异常情况。</p><p>IOExcletion非运行时异常，这种异常编译器要求强制处置，要么try-cathch,要么在方法名后面抛出。要么捕获要么抛出。</p><p>4.线程池的TheadPoolExcutor核心参数,什么时候创建线程，什么时候不创建，线程达到最大上限是什么策略？什么时候加入缓存队列？</p><p>一个完整的线程池应该具备如下要素：</p><p>任务队列：用于缓存提交的任务</p><p>线程数量管理功能：一个线程池应该很好的管理和控制线程的数量，可以通过三个参数来实现，比如创建线程池时初始的线程数量init，线程池自动扩展时最大的线程数量；在线程空闲时需要释放一定的线程但是也要维持一定的活跃数量。</p><h3 id="5-线程状态？什么时候进入阻塞态什么时候进入等待状态？wait之后的状态可以直接回到Runnable吗？"><a href="#5-线程状态？什么时候进入阻塞态什么时候进入等待状态？wait之后的状态可以直接回到Runnable吗？" class="headerlink" title="5.线程状态？什么时候进入阻塞态什么时候进入等待状态？wait之后的状态可以直接回到Runnable吗？"></a>5.线程状态？什么时候进入阻塞态什么时候进入等待状态？wait之后的状态可以直接回到Runnable吗？</h3><p>（1）. NEW 新建状态  线程刚被创建，但是还没启动，还没调用start方法<br>（2）. Runnable 可运行状态 线程可以在Java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统处理器<br>（3）. Blocked 锁阻塞 当一个线程试图获取一个对象锁时，而该对象锁被其他的线程持有，则该线程进入Blocked状态，当该线程持有锁时，该线程将变成Runnable状态<br>（4）. Waiting 无限等待 一个线程在等待另一个线程执行唤醒动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者是notifyAll方法才能够唤醒。<br>（5）. Timed Waiting 计时等待 同Waiting状态 ，，有几个方法有超时参数，调用他们将进入Timed Waiting状态，这一状态将一直保持到超时期满或者是接收到唤醒通知，带有超时参数的常用方法有Thread.sheep、Object.wait<br>（6）. Teminated 被终止 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</p><h3 id="6-高并发会带来什么问题？死锁的解决办法？"><a href="#6-高并发会带来什么问题？死锁的解决办法？" class="headerlink" title="6.高并发会带来什么问题？死锁的解决办法？"></a>6.高并发会带来什么问题？死锁的解决办法？</h3><p>高并发就是多个进程或者线程同时处理不同的操作。高并发会导致系统数据不正确，会出现脏数据等等问题。</p><p>对于一些大型网站，比如门户网站，在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库度、高效率的编程语言、还有高性能的Web容器。</p><h3 id="7-Java的锁的了解，Sychronzed有哪些方法？一个类中两个Sychronized方法被两个线程锁住，分别去调用会阻塞吗？"><a href="#7-Java的锁的了解，Sychronzed有哪些方法？一个类中两个Sychronized方法被两个线程锁住，分别去调用会阻塞吗？" class="headerlink" title="7.Java的锁的了解，Sychronzed有哪些方法？一个类中两个Sychronized方法被两个线程锁住，分别去调用会阻塞吗？"></a>7.Java的锁的了解，Sychronzed有哪些方法？一个类中两个Sychronized方法被两个线程锁住，分别去调用会阻塞吗？</h3><p>悲观锁乐观锁：</p><p>悲观锁：先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><h3 id="8-设计模式知道哪些？设计原则有哪些？单例模式构造函数有何特点？静态方法初始化具体操作-为什么要加volatile"><a href="#8-设计模式知道哪些？设计原则有哪些？单例模式构造函数有何特点？静态方法初始化具体操作-为什么要加volatile" class="headerlink" title="8.设计模式知道哪些？设计原则有哪些？单例模式构造函数有何特点？静态方法初始化具体操作?为什么要加volatile?"></a>8.设计模式知道哪些？设计原则有哪些？单例模式构造函数有何特点？静态方法初始化具体操作?为什么要加volatile?</h3><p>9.Spring的IOC和AOP? IoC自动注入的注解？@Autowired的功能？</p><p>10.数据库方面除了项目之外还有哪些深入学习？试验RR级别下出现幻读？</p><p>\1. 什么是多态？</p><p>接口的多种不同的实现方式即为多态</p><p>在同一个方法中，这种由于参数类型不同而导致执行效果各异的现象就是多态</p><p>在Java中为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。</p><p>多态具体表现在重写和重载</p><p>多态就是类的多种表现方式</p><p>比如方法的同名不同参</p><p>子类重写父类</p><p>方法的重写和重载是Java多态性的不同表现。</p><p>重写是父类与子类之间多态性的一种表现。</p><p>重载是一个类中多态性的一种表现。</p><p>如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 。</p><p>子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。</p><p>如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载。</p><p>并且重载的方法是可以改变返回值的类型的。</p><p>\2. 接口与抽象类的区别？</p><p> 含有abstract修饰符的类即为抽象类，抽象类不能创建实例对象。含有抽象方法的类必须定义为abstract class。在abstract class中，方法不必是抽象的，但是抽象方法必须在具体子类中实现，所以，不能有抽象构造方法或抽象静态方法。子类如果没有实现抽象父类中的所有抽象方法，则必须定义为abstract类型。抽象类需要被继承才能使用，而被final修饰的类无法被继承，所以abstract和final是不能共存的。</p><p>  接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。<strong><em>\</em>接口中的方法定义默认为public abstract类型**</strong>，接口中的成员变量类型默认为public static final。</p><p>\3. 为什么会有java内存模型？</p><p>java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-类修饰词default和protected关系&quot;&gt;&lt;a href=&quot;#1-类修饰词default和protected关系&quot; class=&quot;headerlink&quot; title=&quot;1. 类修饰词default和protected关系&quot;&gt;&lt;/a&gt;1. 类修饰词default和protected关系&lt;/h2&gt;&lt;p&gt;Java一共有四类类修饰符，private  default，public protected&lt;/p&gt;
&lt;p&gt;protected 包内所有类可见，包外有继承关系的子类可见。&lt;/p&gt;
&lt;p&gt;default表示默认，不仅本类访问，而且是同包可见。&lt;/p&gt;
&lt;p&gt;当修饰词是private时，只有类内能够访问到，其他任何类都不能直接访问到。&lt;/p&gt;
&lt;p&gt;当修饰词是public时，任何类内都能访问到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试，阿里" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>参考面经</title>
    <link href="http://yoursite.com/2020/06/05/%E5%8F%82%E8%80%83%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2020/06/05/%E5%8F%82%E8%80%83%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-06-05T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.713Z</updated>
    
    <content type="html"><![CDATA[ <a id="more"></a><h3 id="一、前两道要求写出代码"><a href="#一、前两道要求写出代码" class="headerlink" title="一、前两道要求写出代码"></a>一、前两道要求写出代码</h3><p>后两道说思路即可</p><p>第一题是自己设计一个双向链表，并实现插入 删除 一开始忘了处理头尾节点的情况，面试官让再检查，然后补上了</p><p>第二题是字符串替换，在字符串s中找到字符串p，并替换成e 这个题问了面试官说可以用暴力，就直接暴力解了，但是忘了string的insert和erase怎么用了，太菜了…</p><p>第三题如何找链表的第k个节点，思路：倒数第k个就是正数第l-k+1个，即l-(k-1),也就是说让一个游标先走k-1步，到达第k个节点，再有另一个游标从头开始，这样当第一个游标到达最后一个节点的时候，第二个游标正好在第l-(k-1)个节点，即倒数第k个节点上</p><p>第四题场景：服务器可能被IP重放攻击，要找出访问量最大的k个IP并处理，抽象成topK问题，先哈希去重，再创建小顶堆维护k个节点即可，后面又问了需要多少内存，堆需要维护的内存直接忽略不计了，因为主要的内存消耗在创建哈希表上，当时脑子有点乱，太迷了…第一次说了个8G，后来一想肯定不对，重新算了下，应该是2^32 *8B左右</p><h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3><p>二维矩阵中寻找元素，二维数组满足从左到右从上到下非递减， 从右上角或者左下角扫描，每次砍掉一行或者一列，时间复杂度max（m,n）</p><p>数据库的一些知识，mysql和redis，可以看我其他的面经，就不多提了</p><p>http 0.9 1.0 1.1 2.0 https tcp/udp等等</p><p>三、</p><p><a href="https://blog.nowcoder.net/n/e5fe3fa16b774b469241029a6de4e65a#一java" target="_blank" rel="noopener">https://blog.nowcoder.net/n/e5fe3fa16b774b469241029a6de4e65a#一java</a></p><p>这个链接比较详细</p><p>但是觉得这些参考价值一般，一和二都是直接内推的面试，注重了编程。</p><h3 id="325搜狗"><a href="#325搜狗" class="headerlink" title="325搜狗"></a>325搜狗</h3><p>1项目经验</p><p>2poi限制输入</p><p>3final</p><p>4hashmap currenthashmap </p><p>5spring特征spring事务</p><p>6mysql死锁</p><p>7jvm G1 CMS</p><p>8卷积神经网络</p><p>9linux操作</p><h4 id="325美团"><a href="#325美团" class="headerlink" title="325美团"></a>325美团</h4><p>1项目</p><p>2 mybitits hibenite 区别，哪个效率更高</p><p>3数据链路层和网络层设备和协议</p><p>4数据库左右连接，内连接自然连接，</p><p>5数据库二级索引 数据结构 数据怎么保存</p><p>6虚拟地址 为什么是2的64次方</p><p>7http的状态码</p><p>1gc</p><p>2三次握手 为什么三次握手</p><p>3http长连接短连接</p><p>4io多路复用</p><p>5数据库索引结构 为什么用b+树</p><p>6tcp怎么保证可靠的</p><p>7将字符串空格变为%23，从后往前解决</p><p>字节414</p><p>1==和equals</p><p>2重写equals和hashcode</p><p>3hashmap</p><p>4static和volatile</p><p>5第K大的数</p><p>6TCP可靠</p><p>7网络拥塞避免</p><p>8time-wait状态</p><h3 id="阿里414"><a href="#阿里414" class="headerlink" title="阿里414"></a>阿里414</h3><p>项目，excel面向任务流</p><p>最小生成树和图</p><p>Int long大小</p><p>贪心算法</p><p>红黑树</p><h3 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h3><p>1int大小integer</p><p>2gc</p><p>3jdk jre</p><p>4String stringbuilder 字符串常量池</p><p>5sychronized和volitile</p><p>6ssh</p><p>7</p><h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><p>1多线程 锁区别</p><p>2设计模式，单例（保证方法无状态无状态）</p><p>3数据库优化，数据库索引哪种情况需要建立 索引失效  mysql日志 执行过程</p><p>4redis 要注意key不能过大</p><p>5线程池 参数</p><p>6oom 栈溢出，堆溢出，常量池溢出 </p><h3 id="阿里文娱-实习一面-3-12-50nin"><a href="#阿里文娱-实习一面-3-12-50nin" class="headerlink" title="阿里文娱 实习一面 3.12 50nin"></a>阿里文娱 实习一面 3.12 50nin</h3><p>自我介绍<br>spring 是否看过源码</p><p>Bean生命周期<br>项目中一个难点<br>jdk看过源码 ​树在Java的应用 红黑树 b树b+树区别 使用场景</p><p>协程与线程的关系<br>设计一个上亿用户的登录模块<br>设计一个单点登录<br>排查后端性能思路<br>小组协同开发，编码规则<br>pb级集群日志里找重复行</p><p>编程邮件</p><h4 id="蘑菇街-金融风控部门-实习一面-3-13-40min"><a href="#蘑菇街-金融风控部门-实习一面-3-13-40min" class="headerlink" title="蘑菇街 金融风控部门 实习一面 3.13 40min"></a>蘑菇街 金融风控部门 实习一面 3.13 40min</h4><p>项目经历</p><p>订单管理，订单快照实现                </p><p>为什么使用ES</p><p>Activity 工作流 模板、嵌入、离开</p><p>工作分配换人 怎么实现</p><p>面向对象</p><p>注解怎么自己实现？都有哪些注解</p><p>Threadlocal</p><p>Start方法与run方法，start方法底层实现</p><p>Java线程状态 new、running、waitting、time-waitting、阻塞、终结</p><p>反射的一些方法</p><p>Spring </p><p>两种反射 区别 接口 cglib    </p><p>Mybatis # $区别</p><p>SQL注入有哪些？可以怎么防范？从哪一层可以进行实现</p><p>Limit 参数使用</p><p>索引什么时候失效</p><p>左连接 右连接</p><p>腾讯 电脑管家深圳 简历面 3.16 20min</p><p>项目中ES、MySQL、redis的使用关系</p><p>保证redis一致性</p><p>为什么使用srio，与spring security的区别</p><p>处理大量读写请求</p><p>处理大量写请求</p><p>TF-IDF算法</p><h3 id="阿里-企业智能事业部-3-16-20min"><a href="#阿里-企业智能事业部-3-16-20min" class="headerlink" title="阿里 企业智能事业部 3.16 20min"></a>阿里 企业智能事业部 3.16 20min</h3><p>项目的一个技术难点</p><p>cookie session     </p><p>http tcp</p><p>Tcp拥塞</p><p>浏览器发送cookie流程</p><p>如何保证cookie安全</p><p>面向对象、解释其三个特点</p><p>数据结构快排、插入、堆排序</p><p>核心平台</p><h3 id="人人车-核心平台-3-24-35min"><a href="#人人车-核心平台-3-24-35min" class="headerlink" title="人人车 核心平台 3.24 35min"></a>人人车 核心平台 3.24 35min</h3><p>类加载机制</p><p>JVM数据区域</p><p>各个回收器</p><p>确定回收对象</p><p>MySQL存储引擎</p><p>Innodb mylsam分别哪种场景使用</p><p>建索引需要注意</p><p>索引失效的情况，explan</p><p>Java封装继承多态</p><p>怎么实现多继承</p><p>Java各种基本类型</p><p>自动拆箱、装箱</p><p>String为什么不可变类，为何这样设计</p><p>Java里的数据结构</p><p>怎么理解线程安全</p><p>实现线程几种方式</p><p>Runable 与 callable区别</p><p>Spring IOC与Spring AOP</p><p>动态代理</p><p>Spring bean 单例、多例</p><h3 id="作业帮-一面-3-25-50min"><a href="#作业帮-一面-3-25-50min" class="headerlink" title="作业帮 一面 3.25 50min"></a>作业帮 一面 3.25 50min</h3><p>数组Top k</p><p>快排</p><p>订单模块流程</p><p>购物车怎么实现</p><p>Redis 秒杀 watch 事务</p><p>知识图谱</p><p>短文本相似度计算</p><h3 id="作业帮-二面-3-27-50min"><a href="#作业帮-二面-3-27-50min" class="headerlink" title="作业帮 二面 3.27 50min"></a>作业帮 二面 3.27 50min</h3><p>订单流程</p><p>减库存与生成订单顺序</p><p>elasticSearch </p><p>MySQL与ES的同步</p><p>ES快20%是怎么得到的</p><p>TF-IDF详细步骤</p><p>192.168.255.255\28 有多少个IP</p><p>自己显示器坏了，怎么得到IP</p><p>1 2 3 4 5 1 2 3的页面序号访问，内存中有4页大小的空间，LRU替换策略，最后内存里面保留的是哪几页内容</p><p>消费端1s消费一个指令，但60s最多消化10个，怎么实现？</p><p>编程：A-Z AA-ZZ 一个整数对应列号</p><p>还了解哪些相似度计算算法</p><h3 id="腾讯-后台-小程序-3-30-100min"><a href="#腾讯-后台-小程序-3-30-100min" class="headerlink" title="腾讯 后台 小程序 3.30 100min"></a>腾讯 后台 小程序 3.30 100min</h3><p>商品库存存在哪</p><p>redis存哪些数据、如何解决库存问题</p><p>请求读多写少，如何设计？（分布式锁、手动过期、本地缓存）</p><p>在后台使用一个异步线程的时候，如何确保不同的服务只建立、运行一个线程，而不是多个线程呢？</p><p>Redis 本地缓存 MySQL的关系</p><p>不硬件扩容的基础上，如何提高redis性能</p><p>Redis RDB，AOF以及项目中怎么用</p><p>Redis集群的配置情况</p><p>Redis 分片节点如何操作</p><p>Reids 主从同步、新master选取</p><p>ES的使用情况（项目中如何使用、使用版本、单机or集群）</p><p>ES全文检索的底层原理</p><p>一个商品的不同信息是存在一个document中吗？（回答是，说我用的不是全文检索）</p><p>MySQL索引方式（b树与hash索引）</p><p>B树的应用，Innodb Mysriam存储引擎里索引的具体情况</p><p>Tcp接收端一直不处理收到的字节，会发生什么情况？（回答缓存、窗口，又问这些时间长会过期吗？）</p><p>服务端发送数据发给客户端后，数据经过了几次复制（用户态到内核态）</p><p>Tcp协议之上的有哪些协议</p><p>HTTP与HTTPS区别与两者端口</p><p>HTTPS过程</p><p>中间人攻击是什么？https如何解决中间人攻击？</p><p>原来使用http协议，后来升级为https，如何确保使用http时仍能访问到站点（307）</p><p>10个线程，每个加100，结果与1000的关系，如何解决？如何不适用代码块加锁（synchronized）的方式解决?</p><p>进程与线程有什么区别？</p><p>如何控制一个进程独占一个文件？</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>编程：</p><p>1、有序链表去重</p><p>\2. 给定一个数组，有正数，负数，求和最大的连续子序列（动态规划，三种情况）</p><p>腾讯 后台 小程序 二面 3.31 80min</p><p>Java运行时数据区域</p><p>方法区放的有什么数据</p><p>类加载机制</p><p>加载、双亲委派</p><p>静态变量什么时候初始化</p><p>解析过程</p><p>Java里的锁，synchronized的锁实现</p><p>Synchronized锁升级</p><p>Mysql索引的方式，除了hash B树还能有什么</p><p>介绍不同的存储引擎</p><p>B+树为什么比B树快</p><p>树索引的缺点</p><p>Redo undo</p><p>接收窗口（和一面类似）</p><p>Tcp拥塞控制</p><p>四次挥手 二三次之间、2msl 最大报文时间</p><p>Socket编程？</p><p>虚拟内存、段、页</p><p>Spring IOC，AOP的实现方式</p><p>Spring用到的设计模式</p><p>Redis主从同步</p><p>编程：删除倒数第n个节点</p><p>系统设计：实时输出最近一个小时内访问频率最高的10个IP，要求：</p><p>1、实时输出</p><p>2、从当前时间向前数的1个小时</p><p>3、QPS可能会达到10W/s</p><h3 id="广联达-大数据部门-一面-30min"><a href="#广联达-大数据部门-一面-30min" class="headerlink" title="广联达 大数据部门 一面 30min"></a>广联达 大数据部门 一面 30min</h3><p>项目中是怎么做的Mysql优化</p><p>Explain filesort？</p><p>解释Spring IOC 与 AOP</p><p>Spring 有哪些注入方式</p><p>Spring mvc 怎么做事务？</p><p>MySQL事务特点、隔离级别</p><p>MySQL锁，ABA问题</p><p>MySQL索引 具体细节</p><p>http 常用方法</p><p>https</p><p>重载与重写</p><p>String 为什么是不可变？优点是什么？</p><p>Stringbuilder 与 stringbuffer区别</p><p>Hashcode</p><h3 id="腾讯-后台-3面-4-1-50min"><a href="#腾讯-后台-3面-4-1-50min" class="headerlink" title="腾讯 后台 3面 4.1 50min"></a>腾讯 后台 3面 4.1 50min</h3><p>项目中怎么用到的事务</p><p>Redis怎么存数据</p><p>Es在项目中怎么用？与MySQL的区别在哪里？</p><p>上次未回答出来的统计IP</p><p>100亿个数，找出中位数，4G内存</p><h3 id="3-输入两棵二叉树A，B，判断B是不是A的子结构。"><a href="#3-输入两棵二叉树A，B，判断B是不是A的子结构。" class="headerlink" title="\3******输入两棵二叉树A，B，判断B是不是A的子结构。****"></a><strong><em>\</em>3*****</strong>*输入两棵二叉树A，B，判断B是不是A的子结构。****</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">递归调用，</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judgeSubTree(root1, root2) ||</span><br><span class="line">               judgeSubTree(root1.left, root2) ||</span><br><span class="line">               judgeSubTree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgeSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> judgeSubTree(root1.left, root2) ||</span><br><span class="line">                   judgeSubTree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judgeSubTree(root1.left, root2.left) &amp;&amp;</span><br><span class="line">               judgeSubTree(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作给定的二叉树，将其变换为源二叉树的镜像。"><a href="#操作给定的二叉树，将其变换为源二叉树的镜像。" class="headerlink" title="操作给定的二叉树，将其变换为源二叉树的镜像。"></a>操作给定的二叉树，将其变换为源二叉树的镜像。</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">递归方案：交换左右子树的节点，然后递归调用该方法。</span><br><span class="line">非递归：压入栈进行操作</span><br><span class="line"><span class="number">6</span>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>是某栈的压入顺序，序列<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>是该压栈序列对应的一个弹出序列，但<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</span><br><span class="line">新建一个栈，将数组A压入栈中，当栈顶元素等于数组B时，就将其出栈，当循环结束时，判断栈是否为空，若为空则返回<span class="keyword">true</span>.</span><br></pre></td></tr></table></figure><h3 id="输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径"><a href="#输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径" class="headerlink" title="输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径"></a>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</span><br><span class="line">递归做法</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line"><span class="comment">//因为在每一次的递归中，我们使用的是相同的result引用，所以其实左右子树递归得到的结果我们不需要关心，</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result1 = FindPath(root.left, target);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result2 = FindPath(root.right, target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17二叉树深度"><a href="#17二叉树深度" class="headerlink" title="\17二叉树深度**"></a><strong><em>\</em>17二叉树深度**</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;<span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=TreeDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right=TreeDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">非递归</span><br></pre></td></tr></table></figure><h3 id="36-赛车问题"><a href="#36-赛车问题" class="headerlink" title="\36 赛车问题**"></a><strong><em>\</em>36 赛车问题**</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">你的赛车起始停留在位置 <span class="number">0</span>，速度为 +<span class="number">1</span>，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）</span><br><span class="line">你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。</span><br><span class="line">当车得到指令 <span class="string">"A"</span> 时, 将会做出以下操作： position += speed, speed *= <span class="number">2</span>。</span><br><span class="line">当车得到指令 <span class="string">"R"</span> 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -<span class="number">1</span> ；否则将车速调整为 speed = <span class="number">1</span>。  (当前所处位置不变。)</span><br><span class="line">例如，当得到一系列指令 <span class="string">"AAR"</span> 后, 你的车将会走过位置 <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>，并且速度变化为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;-<span class="number">1</span>。</span><br><span class="line">现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。</span><br><span class="line">使用一个一维数组dp，dp[i]代表走到位置i处所需要的最小步数。因为先向前走forword步再向后走back步与先向后走back步再向前走forword步最后到达的位置相同，所以可以假设永远保持第一步是向前走的。第一步有三种情况：</span><br><span class="line">第一种是刚好走forword步后到达了目标位置i，则dp[i] = forword。</span><br><span class="line">第二种情况是向前走forword步后到达了位置i后面，这时需要再往回走，再加上回头的那一步，此时dp[i] = Math.min(dp[i], forword + <span class="number">1</span> + dp[j - i]);（注意这里的上限是走到<span class="number">2</span> * i处）</span><br><span class="line">第三种情况是向前走forword步后未到达位置i处就需要返回，此时在保证返回的步数back &lt; forword的条件下遍历back，此时dp[i] = Math.min(dp[i], forword + <span class="number">1</span> + back + <span class="number">1</span> + dp[i - j + k])。</span><br><span class="line">得到转移方程后递归i，最后dp[target]即为所求值。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">racecar</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= target; i++)&#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> forword = <span class="number">1</span>;(<span class="number">1</span> &lt;&lt; forword) - <span class="number">1</span> &lt; <span class="number">2</span> * i; forword++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; forword) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == i) </span><br><span class="line">                    dp[i] = forword;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; i)</span><br><span class="line">                    dp[i] = Math.min(dp[i], forword + <span class="number">1</span> + dp[j - i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> back = <span class="number">0</span>; back &lt; forword; back++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k = (<span class="number">1</span> &lt;&lt; back) - <span class="number">1</span>;</span><br><span class="line">                        dp[i] =Math.min(dp[i], forword + <span class="number">1</span> + back + <span class="number">1</span> + dp[i - j + k]);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42回溯法寻找二维数组中字符串"><a href="#42回溯法寻找二维数组中字符串" class="headerlink" title="\42回溯法寻找二维数组中字符串**"></a><strong><em>\</em>42回溯法寻找二维数组中字符串**</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="48会场分配问题"><a href="#48会场分配问题" class="headerlink" title="\48会场分配问题**"></a><strong><em>\</em>48会场分配问题**</strong></h3><p>贪心算法，第一问题求出一个会场最大容纳数，每次贪心，选择可以进行的最早结束的会议当做下一次的选择</p><p>第二问题，最少需要多少会场，将开始时间和结束时间分别排序然后每次开始时间小于结束时间会场加一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (a[i]&lt;b[j])&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="49区间合并问题"><a href="#49区间合并问题" class="headerlink" title="\49区间合并问题**"></a><strong><em>\</em>49区间合并问题**</strong></h3><p>对1，3  2，5  6，7 三个区间进行合并</p><p>Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);</p><p>首先使用指定排序，根据数组的第一个数据进行排序</p><p>使用list对已经合并好的区间进行存储</p><p>将list转换为数组res.toArray(new int[0][]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; intervals.length - <span class="number">1</span> &amp;&amp; intervals[i + <span class="number">1</span>][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                right = Math.max(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="63求数组所有子集"><a href="#63求数组所有子集" class="headerlink" title="### 63求数组所有子集"></a>### 63求数组所有子集</h3><p>采用经典回溯法，核心如下，加入新数字，递归，去掉加入的数字，回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt;list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            process(list, nums, i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="64组合总和"><a href="#64组合总和" class="headerlink" title="\64组合总和**"></a><strong><em>\</em>64组合总和**</strong></h3><p>题目 数组{2,3,5,7} 求和为7的组合，每个数字可以重复</p><p>和上面一样的思路，回溯法，每次加入新数字，递归，最后去除新数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                <span class="comment">//因为每个数字都可以使用无数次，所以递归还可以从当前元素开始</span></span><br><span class="line">                process( candidates, target - candidates[i], list);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="67旋转数组"><a href="#67旋转数组" class="headerlink" title="\67旋转数组**"></a><strong><em>\</em>67旋转数组**</strong></h3><p>给定一个数组，将数组中的元素向右移动 <strong>k</strong> 个位置，其中 <strong>k</strong> 是非负数。</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3</p><p>输出: [5,6,7,1,2,3,4]</p><p>三次翻转数组解决，第一次7654321，第二次5674321，第三次，5671234</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">swap(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">swap(nums,k,nums.length-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="68回文链表"><a href="#68回文链表" class="headerlink" title="\68回文链表**"></a><strong><em>\</em>68回文链表**</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = head, prepre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="80乘积最大连续子数组"><a href="#80乘积最大连续子数组" class="headerlink" title="\80乘积最大连续子数组**"></a><strong><em>\</em>80乘积最大连续子数组**</strong></h3><p>动态规划，记录当前最大值和最小值，因为最小值负数乘以负数会成为最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=max;</span><br><span class="line">            max=Math.max(Math.max(max*nums[i],nums[i]),min*nums[i]);</span><br><span class="line">            min=Math.min(Math.min(temp*nums[i],nums[i]),min*nums[i]);</span><br><span class="line">            result=Math.max(max,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="81除自身外数组乘积"><a href="#81除自身外数组乘积" class="headerlink" title="\81除自身外数组乘积**"></a><strong><em>\</em>81除自身外数组乘积**</strong></h3><p>结果等于该数前面数字的乘积乘以后面数据的乘积，先循环计算该位置前面数的乘积，再循环计算前面数乘积乘以后面数乘积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res[i]=k;</span><br><span class="line">            k=k*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">         k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i]=res[i]*k;</span><br><span class="line">            k=k*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
         &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h3 id=&quot;一、前两道要求写出代码&quot;&gt;&lt;a href=&quot;#一、前两道要求写出代码&quot; class=&quot;headerlink&quot; title=&quot;一、前两道要求写出代码&quot;&gt;&lt;/a&gt;一、前两道要求写出代码&lt;/h3&gt;&lt;p&gt;后两道说思路即可&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="面试整理" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程思想&amp;Lambda表达式</title>
    <link href="http://yoursite.com/2020/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3&amp;Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3&amp;Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-03-22T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程的思想"><a href="#函数式编程的思想" class="headerlink" title="函数式编程的思想"></a>函数式编程的思想</h1><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><a id="more"></a><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类</span></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LambdaRunnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h2 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h2><p>由三部分组成：<br>        a. 一些参数<br>        b. 一个箭头<br>        c. 一段代码</p><p>格式 ：<br>        （参数列表） -&gt; {一些重要的方法的代码}</p><p>解释说明：  （）表达是接口中抽象方法的参数列表，没有参数就空着，有参数就写出参数，各个参数之间使用逗号分隔，箭头 -&gt; 表示  把参数传递给方法体中()    。。大括号{} 中重写接口的抽象方法的方法体</p><h2 id="带有参数和返回值的Lambda表达式"><a href="#带有参数和返回值的Lambda表达式" class="headerlink" title="带有参数和返回值的Lambda表达式"></a>带有参数和返回值的Lambda表达式</h2><p>我们封装一个Person类，Person类中定义姓名和年龄属性，并封装get  set方法</p><p>我们进行重写Compartor接口中compare方法来对Person类按照年龄排序。</p><p>如果不使用Lambda表达式，我们使用匿名内部类的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> LambdaExpress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"小华"</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">29</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 按照从小到大进行排序</span></span><br><span class="line"><span class="comment">         * 升序排列 是前面的减去后边的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们使用Lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> LambdaExpress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"小华"</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">29</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 按照从小到大进行排序</span></span><br><span class="line"><span class="comment">         * 升序排列 是前面的减去后边的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr,(Person o1, Person o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda表达式：是可推到，可以省略。。<br>凡是根据上下文推导出来的内容，都可以省略书写<br>可以省略的内容：</p><ol><li>（参数列表）：括号中参数列表的数据类型，可以省略不写</li><li>（参数列表）：括号中的参数如果只有一个，那么类型和() 都可以省略</li><li>（一些代码）：如果{}中的代码只有一行，无论是否有返回值，都可以盛烈（{}，return，分号）    需要注意的是：要省略{} return ，分号必须一起省略</li></ol><h2 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。</p><p>函数式接口，即适用于函数式编程场景的接口。。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数式编程的思想&quot;&gt;&lt;a href=&quot;#函数式编程的思想&quot; class=&quot;headerlink&quot; title=&quot;函数式编程的思想&quot;&gt;&lt;/a&gt;函数式编程的思想&lt;/h1&gt;&lt;p&gt;在数学中，&lt;strong&gt;函数&lt;/strong&gt;就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——&lt;strong&gt;强调做什么，而不是以什么形式做&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面向对象的思想:&lt;/p&gt;
&lt;p&gt;​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.&lt;/p&gt;
&lt;p&gt;函数式编程思想:&lt;/p&gt;
&lt;p&gt;​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java学习" scheme="http://yoursite.com/tags/java%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Lambda表达式" scheme="http://yoursite.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程原子操作类AtomicInteger</title>
    <link href="http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicInteger/"/>
    <id>http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicInteger/</id>
    <published>2020-03-21T12:28:32.000Z</published>
    <updated>2021-05-16T11:04:06.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是原子操作类AtomicInteger"><a href="#什么是原子操作类AtomicInteger" class="headerlink" title="什么是原子操作类AtomicInteger"></a>什么是原子操作类AtomicInteger</h1><p>我们知道java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。synchronized关键字可以保证可见性和有序性却无法保证原子性。而这个AtomicInteger的作用就是为了保证原子性。</p><p>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。</p><a id="more"></a><p>对于Java中的运算操作，例如自增或自减，若没有进行额外的同步操作，在多线程环境下就是线程不安全的。num++解析为num=num+1，明显，这个操作不具备原子性，多线程并发共享这个变量时必然会出现问题。</p><p>下面我们测试一下：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicintegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                        System.out.println(count++);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>我们定义了是10个线程，每个线程做五次加操作，如果程序正常并发执行的话，结果应该是0–50个数字，中间没有重复数字出现，但是运行结果显然不是，这个时候就出现了多线程的数据安全问题。</p><p>分析出现上述安全问题的原因，可能是我们没有对多线程共享的变量进行保证在多线程间的可见性，所以我们可以使用volatile关键字修饰</p><h3 id="换成volatile修饰count变量"><a href="#换成volatile修饰count变量" class="headerlink" title="换成volatile修饰count变量"></a>换成volatile修饰count变量</h3><p>顺带说下volatile关键字很重要的两个特性：</p><p>1、保证变量在线程间可见，对volatile变量所有的写操作都能立即反应到其他线程中，换句话说，volatile变量在各个线程中是一致的（得益于java内存模型—“先行发生原则”）；</p><p>那么换成volatile修饰count变量后，会有什么效果呢？ 试一试:</p><p>还是上述的代码，我们对变量count使用volatile关键字进行修饰</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></code></pre><p>输出结果好像还是与预期的不一致，这是为什么呢？并不能得出”基于volatile变量的运算在并发下是安全的”这个结论，，，此时，这个核心点在于在java的运算中，比如count++,++count操作并不是原子性的。</p><p>对于count++的操作，其实可以分解为3个步骤。</p><p>（1）从主存中读取count的值</p><p>（2）对count进行加1操作</p><p>（3）把count重新刷新到主存</p><p>这三个步骤在单线程中一点问题都没有，但是到了多线程就出现了问题了。比如说有的线程已经把count进行了加1操作，但是还没来得及重新刷入到主存，其他的线程就重新读取了旧值。因为才造成了错误。如何去解决呢？方法当然很多，但是为了和我们今天的主题对应上，很自然的联想到使用AtomicInteger。下面我们使用AtomicInteger重新来测试一遍：</p><p>我们对上面的类继续进行改造：</p><p>把上面的代码改造成AtomicInteger原子类型，先看看效果</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicintegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//private static  int count = 0;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                        System.out.println(count.incrementAndGet());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>最后通过运行结果我们发现，输出结果中并没有重复的数字，程序能够在多线程的状况下并发的执行，并能够正确的输出结果，这都归功于AtomicInteger.incrementAndGet()方法的原子性。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>在上面的例子中，我们使用AtomicInteger 中的incrementAndGet 函数来进行自增操作，代替直接使用count++来进行自增，保证了操作的原子性。</p><p>AtomicInteger类为我们提供了很多函数。</p><p>我们先看一下我们在上面使用的increasementAndGet函数，我们直接直接查看源码</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>在这里我们会看到，底层使用的是unsafe的getAndAddInt方法。这里你可能有一个疑问了，这个unsafe是个什么鬼，而且还有一个valueOffset参数又是什么，想要看明白，我们从源码的开头开始看起。</p><p><img src="https://img-blog.csdnimg.cn/20200320160113766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlbzExMjAxNzg1MTg=,size_16,color_FFFFFF,t_70" alt=""></p><p>开头在Unsafe的上面会发现，有一行注释叫做Unsafe.compareAndSwapInt。这又是什么？</p><p>（1） compareAndSwapInt的含义</p><p>compareAndSwapInt又叫做CAS，CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。</p><p>对于CAS的解释我不准备长篇大论讲解。因为里面涉及到的知识点还是挺多的。在这里你理解了其含义就好。</p><p>（2）Unsafe的含义</p><p>在上面我们主要是讲解了CAS的含义，CAS修饰在Unsafe上面。那这个Unsafe是什么意思呢？</p><p>Unsafe是位于sun.misc包下的一个类，Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p><p>这里说一句题外话，在jdk1.9中，对Usafe进行了删除，所以因为这，那些基于Usafe开发的框架慢慢的都死掉了。</p><p>我们回到上面的源码中，继续进行说明，在这里也就是说，Usafe再进行getAndAddInt的时候，首先是先加1，然后对底层对象的地址做出了更改。这个地址是什么呢？这就是涉及到我们的第三个疑问参数了。</p><p>（3）valueOffset的含义</p><p>这个valueOffset是long类型的，代表的含义就是对象的地址的偏移量。下面我们重新解释一下这行代码。</p><p>unsafe.getAndAddInt(this, valueOffset, 1) + 1。这行代码的含义是，usafe通过getAndAddInt方法，对原先对象的地址进行了加1操作。现在应该明白了。我们return的时候，也是直接返回的最新的值。这一点我们对比另外一个方法incrementAndGet就能看出。</p><p><img src="https://img-blog.csdnimg.cn/20200320160712960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlbzExMjAxNzg1MTg=,size_16,color_FFFFFF,t_70" alt=""></p><p>在这个方法的源代码中我们可以看到最后的+1操作没有了，也就是说，直接返回的是旧地址的值，然后再进行自增操作。如何去拿的地址的偏移量呢？是通过下面这个代码。</p><p><img src="https://img-blog.csdnimg.cn/2020032016094369.png" alt=""></p><p>OK，到了这一步相信你已经知道了，usafe对a的值使用getAndAddInt方法进行了加1操作。然后返回最新的值。</p><p>对于AtomicInteger的原理就是这，主要是通过Usafe的方式来完成的。Usafe又是通过CAS机制来实现的，因此想要弄清整个原子系列的真正实现，就是要搞清楚CAS机制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于jdk1.8的并发包来说，底层基本上就是通过Usafe和CAS机制来实现的。有好处也肯定有一个坏处。从好的方面来讲，就是上面AtomicInteger类可以保持其原子性。但是从坏的方面来看，Usafe因为直接操作的底层地址，肯定不是那么安全，而且CAS机制也伴随着大量的问题，比如说有名的ABA问题等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是原子操作类AtomicInteger&quot;&gt;&lt;a href=&quot;#什么是原子操作类AtomicInteger&quot; class=&quot;headerlink&quot; title=&quot;什么是原子操作类AtomicInteger&quot;&gt;&lt;/a&gt;什么是原子操作类AtomicInteger&lt;/h1&gt;&lt;p&gt;我们知道java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。synchronized关键字可以保证可见性和有序性却无法保证原子性。而这个AtomicInteger的作用就是为了保证原子性。&lt;/p&gt;
&lt;p&gt;AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程-CyclicBarrier</title>
    <link href="http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier%E7%94%A8%E6%B3%95/</id>
    <published>2020-03-21T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CyclicBarrier-是什么"><a href="#CyclicBarrier-是什么" class="headerlink" title="CyclicBarrier 是什么"></a>CyclicBarrier 是什么</h2><p>现实生活中我们经常会遇到这样的情景，在进行某个活动前需要等待人全部都齐了才开始。例如吃饭时要等全家人都上座了才动筷子，旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。</p><p>在JUC包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是CyclicBarrier类。利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作</p><a id="more"></a><p>CyclicBarrier字面意思是可循环（Cyclic）的屏障（Barrier）。它主要做的事情是，让一组线程达到一个屏障（也可以叫同步点或者栏栅）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。</p><p>我们看一下CyclicBarrier与CountDownLatch的直观区别就是：<br>        CountDownLatch说白了是做减法，减到0时，被阻塞的线程被唤醒；</p><pre><code>CyclicBarrier说白了是做加法，加到固定值时，被阻塞的线程被唤醒；</code></pre><p>CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。</p><p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现的。因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p><p>在CyclicBarrier类的内部有一个计数器，每个线程在到达屏障点的时候都会调用await方法将自己阻塞，此时计数器会减1，当计数器减为0的时候所有因调用await方法而被阻塞的线程将被唤醒。这就是实现一组线程相互等待的原理，下面我们先看看CyclicBarrier有哪些成员变量</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//同步操作锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//线程拦截器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">//每次拦截的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">//换代前执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">//表示栅栏的当前代</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类Generation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面贴出了CyclicBarrier所有的成员变量，可以看到CyclicBarrier内部是通过条件队列trip来对线程进行阻塞的，并且其内部维护了两个int型的变量parties和count，parties表示每次拦截的线程数，该值在构造时进行赋值。count是内部计数器，它的初始值和parties相同，以后随着每次await方法的调用而减1，直到减为0就将所有线程唤醒。CyclicBarrier有一个静态内部类Generation，该类的对象代表栅栏的当前代，就像玩游戏时代表的本局游戏，利用它可以实现循环等待。barrierCommand表示换代前执行的任务，当count减为0时表示本局游戏结束，需要转到下一局。在转到下一局游戏之前会将所有阻塞的线程唤醒，在唤醒所有线程之前你可以通过指定barrierCommand来执行自己的任务。</p><p>接下来我们看看它的构造器。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造器1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>CyclicBarrier有两个构造器，其中构造器1是它的核心构造器，在这里你可以指定本局游戏的参与者数量(要拦截的线程数)以及本局结束时要执行的任务，还可以看到计数器count的初始值被设置为parties。CyclicBarrier类最主要的功能就是使先到达屏障点的线程阻塞并等待后面的线程，其中它提供了两种等待的方法，分别是定时等待和非定时等待。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//非定时等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>可以看到不管是定时等待还是非定时等待，它们都调用了dowait方法，只不过是传入的参数不同而已。下面我们就来看看dowait方法都做了些什么。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心等待方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">//检查当前栅栏是否被打翻</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查当前线程是否被中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//如果当前线程被中断会做以下三件事</span></span><br><span class="line">            <span class="comment">//1.打翻当前栅栏</span></span><br><span class="line">            <span class="comment">//2.唤醒拦截的所有线程</span></span><br><span class="line">            <span class="comment">//3.抛出中断异常</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次都将计数器的值减1</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//计数器的值减为0则需唤醒所有线程并转换到下一代</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//唤醒所有线程前先执行指定的任务</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    command.run();</span><br><span class="line">                &#125;</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//唤醒所有线程并转到下一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//确保在任务未成功执行时能将所有线程唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果计数器不为0则执行此循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//根据传入的参数来决定是定时等待还是非定时等待</span></span><br><span class="line">                <span class="keyword">if</span> (!timed) &#123;</span><br><span class="line">                    trip.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">//若当前线程在等待期间被中断则打翻栅栏唤醒其他线程</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若在捕获中断异常前已经完成在栅栏上的等待, 则直接调用中断操作</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果线程因为打翻栅栏操作而被唤醒则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果线程因为换代操作而被唤醒则返回计数器的值</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果线程因为时间到了而被唤醒则打翻栅栏并抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>可以看到在dowait方法中每次都将count减1，减完后立马进行判断看看是否等于0，如果等于0的话就会先去执行之前指定好的任务，执行完之后再调用nextGeneration方法将栅栏转到下一代，在该方法中会将所有线程唤醒，将计数器的值重新设为parties，最后会重新设置栅栏代次，在执行完nextGeneration方法之后就意味着游戏进入下一局。如果计数器此时还不等于0的话就进入for循环，根据参数来决定是调用trip.awaitNanos(nanos)还是trip.await()方法，这两方法对应着定时和非定时等待。如果在等待过程中当前线程被中断就会执行breakBarrier方法，该方法叫做打破栅栏，意味着游戏在中途被掐断，设置generation的broken状态为true并唤醒所有线程。同时这也说明在等待过程中有一个线程被中断整盘游戏就结束，所有之前被阻塞的线程都会被唤醒。线程醒来后会执行下面三个判断，看看是否因为调用breakBarrier方法而被唤醒，如果是则抛出异常；看看是否是正常的换代操作而被唤醒，如果是则返回计数器的值；看看是否因为超时而被唤醒，如果是的话就调用breakBarrier打破栅栏并抛出异常。这里还需要注意的是，如果其中有一个线程因为等待超时而退出，那么整盘游戏也会结束，其他线程都会被唤醒。下面贴出nextGeneration方法和breakBarrier方法的具体代码。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//切换栅栏到下一代</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//唤醒条件队列所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">//设置计数器的值为需要拦截的线程数</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">//重新设置栅栏代次</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打翻当前栅栏</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前栅栏状态设置为打翻</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//设置计数器的值为需要拦截的线程数</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">//唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p> 最后，我们来看看怎么重置一个栅栏：</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p><p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p><h3 id="通过一个例子来看一下CyclicBarries"><a href="#通过一个例子来看一下CyclicBarries" class="headerlink" title="通过一个例子来看一下CyclicBarries"></a>通过一个例子来看一下CyclicBarries</h3><p>LeetCode上面有一道交替打印字符串的案例，我们可以使用多线程并发包中的  CyclicBarrier类来进行实现同步控制</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</span><br><span class="line"></span><br><span class="line">如果这个数字可以被 3 整除，输出 &quot;fizz&quot;。</span><br><span class="line">如果这个数字可以被 5 整除，输出 &quot;buzz&quot;。</span><br><span class="line">如果这个数字可以同时被 3 和 5 整除，输出 &quot;fizzbuzz&quot;。</span><br><span class="line">例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>设立static（静态唯一)的CyclicBarrier   等待其他线程都一起触发之后，才进行下一步操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CyclicBarrier-是什么&quot;&gt;&lt;a href=&quot;#CyclicBarrier-是什么&quot; class=&quot;headerlink&quot; title=&quot;CyclicBarrier 是什么&quot;&gt;&lt;/a&gt;CyclicBarrier 是什么&lt;/h2&gt;&lt;p&gt;现实生活中我们经常会遇到这样的情景，在进行某个活动前需要等待人全部都齐了才开始。例如吃饭时要等全家人都上座了才动筷子，旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。&lt;/p&gt;
&lt;p&gt;在JUC包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是CyclicBarrier类。利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础</title>
    <link href="http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-21T12:26:32.000Z</published>
    <updated>2021-05-16T11:04:06.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是指内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程，进程也是程序的一次执行过程，是系统运行程序的基本单位 ，系统运行一个程序即是一个进程从运行到消亡的过程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，一个进行中是可以同时有多个线程的，这个应用程序也可以称为多线程程序。</p><a id="more"></a><h2 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h2><p>创建多线程程序的第一种方式：创建Thread类的子类</p><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。</p><p>每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的</p><p>步骤如下：</p><ol><li><p>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</p></li><li><p>创建Thread子类的实例，即创建了线程对象</p></li><li><p>调用线程对象的start()方法来启动该线程，执行里面的run方法</p><p> void  run() 使该线程开始执行，Java虚拟机调用该线程的run方法。</p></li></ol><p>Java程序属于抢占式调度，哪个线程的优先级高，哪个线程优先执行，同一个优先级的，随机选择一个执行。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"mythread"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       myThread myThread = <span class="keyword">new</span> myThread();</span><br><span class="line">       myThread.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"main"</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="创建线程方式二"><a href="#创建线程方式二" class="headerlink" title="创建线程方式二"></a>创建线程方式二</h3><p>采用Runnable 也是非常常见的一种，我们只需要重写run方法即可。</p><p>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run() 方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法，来启动线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"runnable"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       RunnableThread runnableThread = <span class="keyword">new</span> RunnableThread();</span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread(runnableThread);</span><br><span class="line">       thread.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"main"</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程 代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 </p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。 </p><p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程 编程的基础。</p><h4 id="创建线程的两种方式Thread和Runnable的区别"><a href="#创建线程的两种方式Thread和Runnable的区别" class="headerlink" title="创建线程的两种方式Thread和Runnable的区别"></a>创建线程的两种方式Thread和Runnable的区别</h4><p>简单的说，如果一个类继承Thread，则不适合资源共享，但是如果实现了Runnable接口的话，则很容易的实现资源共享。</p><p>总结：<br>实现Runnable接口比继承Thread类所具有的优势。</p><ol><li>适合多个相同的程序代码的线程去共享同一个资源</li><li>可以避免Java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立</li><li>线程池只能放入实现Runnable或者是Callable类线程，不能直接放入继承Thread的类</li></ol><p><strong>扩充：</strong>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果有多个线程同时运行，而这些线程可能会同时运行这段代码，如果多个线程同时运行同一段代码时，程序每次运行结果和单线程状态下运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>例如在以电影院卖票为例，当多个窗口也就是多个线程同时对一个变量也就是票数进行操作时，如果不控制线程安全，就有可能出现相同的票被卖了两回以及卖出不存在的票等等线程变量异常问题。简单的说，就是当几个窗口之间也就是几个线程之间票数变量不同步了，这种问题称为线程不安全问题。。</p><p>注意：</p><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。</p><h2 id="线程同步问题"><a href="#线程同步问题" class="headerlink" title="线程同步问题"></a>线程同步问题</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p><p>要解决上述中出现的多线程并发访问同一个资源的安全问题,也就是解决重复票与不存在票问题，Java中提供了同步机制  synchronized 来解决。</p><p>还以上述卖票的代码为例：</p><p>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码 去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU 资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p><h3 id="有三种方法解决线程安全问题"><a href="#有三种方法解决线程安全问题" class="headerlink" title="有三种方法解决线程安全问题"></a>有三种方法解决线程安全问题</h3><ol><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ol><h2 id="第一种同步方法：同步代码块"><a href="#第一种同步方法：同步代码块" class="headerlink" title="第一种同步方法：同步代码块"></a>第一种同步方法：同步代码块</h2><p>同步代码块： 使用synchronized 关键字用于方法中需要进行同步的某个区块中，表示只对这个区块的资源实行互斥访问。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（同步锁）&#123;</span><br><span class="line">需要同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. </p><ol><li>锁对象 可以是任意类型。 </li><li>多个线程对象 要使用同一把锁。</li></ol><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)</p><p>例如卖票的例子使用同步锁实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">saleTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (number &gt;<span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在卖"</span> + number + <span class="string">"张票"</span>);</span><br><span class="line">                    number--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二种同步方法：同步方法"><a href="#第二种同步方法：同步方法" class="headerlink" title="第二种同步方法：同步方法"></a>第二种同步方法：同步方法</h2><p>同步方法：使用synchronized修饰的方法，就叫做同步方法，使用synchronized修饰的方法，当多个线程同时执行时，可以保证线程A执行该方法的时候，其他线程只能在方法外面等着。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同步方法中的同步锁是：对于非static方法，同步锁就是this，对于static方法，我们使用当前方法所在类的字节码对象（类名.class）作为同步锁。</p><h2 id="第三种同步方法：Lock锁"><a href="#第三种同步方法：Lock锁" class="headerlink" title="第三种同步方法：Lock锁"></a>第三种同步方法：Lock锁</h2><p>在Java的机制中，提供了比synchronized代码块同步，和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能，Lock都有，初次之外Lock还有它特有的功能，使用Lock进行同步，更能体现面向对象的思想。</p><p>Lock锁也称为同步锁，加锁与释放锁方法化了，具体的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>  :加同步锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>  :释放同步锁</span></span><br></pre></td></tr></table></figure><p>以卖票为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">saleTirckLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现卖票同步的方法  Lock锁机制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前卖的是："</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是指内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程，进程也是程序的一次执行过程，是系统运行程序的基本单位 ，系统运行一个程序即是一个进程从运行到消亡的过程。&lt;/p&gt;
&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，一个进行中是可以同时有多个线程的，这个应用程序也可以称为多线程程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/03/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E4%B8%8E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E4%B8%8E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-03-20T02:20:32.000Z</published>
    <updated>2021-05-16T11:04:06.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><p>冒泡排序与选择排序算法</p><a id="more"></a><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是一种简单直观的排序算法。<br>选择排序的基本步骤是：</p><p>首先，第一次从一个数组中选取最小值，与数组的第一个值arr[0]交换，，第二次从剩余的数组中选取最小值，与数组的第二个值交换，…..依次类推，重复以上步骤，总共是通过n-1次，这样就得到一个按排序码从小到大排列的有序序列。</p><p>说明：<br> 选择排序一共有数组大小-1次的排序<br>每一轮的排序，又是一个循环，循环的规则代码<br>先假定当前的这个数是最小的，然后和后面的数依次比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标。<br>当遍历到数组的最后时，就得到本轮最小数和下标</p><p>Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 选择排序方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> minIndex;</span><br><span class="line">       <span class="keyword">int</span> min;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           minIndex = i;</span><br><span class="line">           min = arr[i];</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j= i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (min &gt; arr[j])&#123;</span><br><span class="line">                   min = arr[j];</span><br><span class="line">                   minIndex = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找出最小值之后，交换位置</span></span><br><span class="line">           <span class="keyword">if</span> (minIndex != i)&#123;</span><br><span class="line">               arr[minIndex] = arr[i];</span><br><span class="line">               arr[i] = min;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述代码的执行顺序</p><p>首先是定义指向最小值的下标，以及最小值的变量，因为要经过n-1次的过程。</p><p>首先初始化最小值为第一个数组，最小值下标为0。在每一次中，把最小值和每一个元素进行比较，如果较小就更新最小值，并更新最小值的下标。在每一次的比较结束，进行位置交换。上述的n-1次按照这种方式依次进行比较。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的基本思想是：通过对待排序序列从前向后遍历（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样，逐渐向上冒。。</p><p>因为在排序的过程中，各个元素不断的被移动到接近自己的位置 ，如果一趟比较下来，没有元素进行过交换，那就说明序列有序，因此在冒泡排序的过程中需要设置一个标志 flag 判断元素是否进行过交换，从而减少不必要的比较。</p><p>Java实现冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maopaoSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> temp= <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  <span class="comment">//定义一个标志变量，来表示是否发生过交换，如果一趟比较发生过交换，则置为true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  flag = <span class="keyword">true</span>;</span><br><span class="line">                  temp = arr[j];</span><br><span class="line">                  arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                  arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              flag = <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序算法总结&quot;&gt;&lt;a href=&quot;#排序算法总结&quot; class=&quot;headerlink&quot; title=&quot;排序算法总结&quot;&gt;&lt;/a&gt;排序算法总结&lt;/h1&gt;&lt;p&gt;冒泡排序与选择排序算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>

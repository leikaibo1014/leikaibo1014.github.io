{"meta":{"title":"雷凯博的博客","subtitle":"记录学习中的点点滴滴","description":"你现在所经历的挫折和失败，它只属于现在，把它交给时间，一切都是最好的安排","author":"雷凯博","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-08T07:28:29.000Z","updated":"2021-05-16T11:04:06.721Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式 手机：18437927257 Email：kaibo_lei@163.com QQ：1120178518"},{"title":"categories","date":"2019-11-08T07:29:03.000Z","updated":"2021-05-16T11:04:06.721Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"resume","date":"2019-11-08T09:27:40.000Z","updated":"2021-05-16T11:04:06.722Z","comments":true,"path":"resume/index.html","permalink":"http://yoursite.com/resume/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-08T07:28:55.000Z","updated":"2021-05-16T11:04:06.723Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"堆排序-快排-冒泡","slug":"堆排序","date":"2021-05-10T12:26:32.000Z","updated":"2021-05-16T12:56:51.338Z","comments":true,"path":"2021/05/10/堆排序/","link":"","permalink":"http://yoursite.com/2021/05/10/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"堆排序堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。","text":"堆排序堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 java代码实现堆排序的过程 首先，我们需要先交换每一个非叶子结点和他们的左右孩子节点，构造这三个节点为一个大顶堆. 以下代码的思想就是，交换结点以及他们左右孩子节点，找到最大值并交换位置 1234567891011121314151617181920212223242526272829303132333435/** * 参数说明 arr 表示待构建数组 * n：表示堆的元素个数 * i: 表示每一个小堆的父节点 */ public static void heap_step(int[] arr, int n, int i) &#123; int c1 = 2 * i + 1; //i结点的左孩子 int c2 = 2 * i + 2; //i结点的右孩子 int max = i; //这三个元素最大值的下标指向 //定义递归出口 if (i &gt; n) &#123; return; &#125; if (c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max])&#123; max = c1; &#125; if (c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123; max = c2; &#125; if (max != i) &#123; swap(arr, max, i);//交换两个位置的元素 heap_step(arr, n, max);//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆 &#125; &#125; /* 两个元素交换位置的函数 */ public static void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; 上面的方法是构建结点以及孩子节点元素的交换步骤 下面我们需要，对数组中也就是完全二叉树中所有的非叶子结点，逐次遍历，对每一个非叶子结点都需要进行构造大顶堆的过程 12345678910111213141516/** * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆 * 从最后一个非叶子结点开始 * 最后一个叶子结点数组下标为： last_node = arr.length-1 * 则最后一个非叶子结点为 last_parent = (last_node-1)/2 * @param arr * @param n */ public static void build_heap(int[] arr, int n) &#123; int last_node = n-1; int last_parent = (last_node-1)/2; //对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建 for (int i = last_parent; i &gt;=0 ; i--) &#123; heap_step(arr,n,i); &#125; &#125; 以上方法执行完，我们的数组完全二叉树就完全变成了一个大顶堆。每一个根节点都大于他们的左右孩子节点 构造完大顶堆之后，我们需要把大顶堆的根元素与最后一个位置的元素进行位置的交换。 交换代码如下： 12345678910111213141516171819/** * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换 * @param arr */public static void heap_sort(int[] arr,int n)&#123; build_heap(arr, arr.length); //把数组先构造成为一个大顶堆 // 这个时候数组已经是一个大顶堆了 //交换数据 for (int i = n - 1; i &gt;= 0; i--) &#123; swap(arr, i, 0); /* 因为这个时候完全二叉树已经是一个大顶堆了， 所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点 */ heap_step(arr, i, 0); &#125;&#125; 上面是对排序中的各个步骤逐一的记录，下面是完整代码： 完整的堆排序算法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package study;public class heapSort &#123; public static void main(String[] args) &#123; int[] array = &#123;12,15,10,18,6,9,16&#125;; heap_sort(array, array.length); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]+\" \"); &#125; &#125; /** * 参数说明 arr 表示待构建数组 * n：表示堆的元素个数 * i: 表示每一个小堆的父节点 */ public static void heap_step(int[] arr, int n, int i) &#123; int c1 = 2 * i + 1; //i结点的左孩子 int c2 = 2 * i + 2; //i结点的右孩子 int max = i; //这三个元素最大值的下标指向 //定义递归出口 if (i &gt; n) &#123; return; &#125; if (c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max])&#123; max = c1; &#125; if (c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123; max = c2; &#125; if (max != i) &#123; swap(arr, max, i);//交换两个位置的元素 heap_step(arr, n, max);//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆 &#125; &#125; /** * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆 * 从最后一个非叶子结点开始 * 最后一个叶子结点数组下标为： last_node = arr.length-1 * 则最后一个非叶子结点为 last_parent = (last_node-1)/2 * @param arr * @param n */ public static void build_heap(int[] arr, int n) &#123; int last_node = n-1; int last_parent = (last_node-1)/2; //对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建 for (int i = last_parent; i &gt;=0 ; i--) &#123; heap_step(arr,n,i); &#125; &#125; /** * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换 * @param arr */ public static void heap_sort(int[] arr,int n)&#123; build_heap(arr, arr.length); //把数组先构造成为一个大顶堆 // 这个时候数组已经是一个大顶堆了 //交换数据 for (int i = n - 1; i &gt;= 0; i--) &#123; swap(arr, i, 0); /* 因为这个时候完全二叉树已经是一个大顶堆了， 所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点 */ heap_step(arr, i, 0); &#125; &#125; /* 两个元素交换位置的函数 */ public static void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344package study.Sort;//快速排序public class quickSort &#123; public static void quickSortArray(int[] array,int low,int hight)&#123; int i,j,temp,t; if (low &gt; hight) &#123; return; &#125; i = low; j = hight; temp = array[low]; while (i &lt; j) &#123; while (temp&lt;=array[j] &amp;&amp; i &lt; j) &#123; j--; &#125; while (temp&gt;=array[i] &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; t = array[j]; array[j] = array[i]; array[i] = t; &#125; &#125; array[low] = array[i]; array[i] = temp; quickSortArray(array,low,j-1); quickSortArray(array,j+1,hight); &#125; public static void main(String[] args) &#123; int[] array =&#123;10,5,7,3,12,25,15,8&#125;; quickSortArray(array,0,array.length-1); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]+\" \"); &#125; &#125;&#125; 冒泡排序12345678910111213private static void bubbleSortArr(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; int temp = array[j]; array[j] = array[j + 1]; array[j+1] =temp; &#125; &#125; &#125;&#125; 选择排序123456789101112131415161718private static void select(int[] array) &#123; for (int i = 0; i &lt; array.length-1; i++) &#123; int min = array[i]; int minIndex = i; for (int j = i+1; j &lt; array.length; j++) &#123; if (min &gt; array[j]) &#123; min = array[j]; minIndex = j; &#125; &#125; if (minIndex != i) &#123; array[minIndex] = array[i]; array[i] = min; &#125; &#125;&#125;","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"二叉树操作","slug":"二叉树操作","date":"2020-06-12T12:26:32.000Z","updated":"2021-05-16T11:04:06.712Z","comments":true,"path":"2020/06/12/二叉树操作/","link":"","permalink":"http://yoursite.com/2020/06/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%93%8D%E4%BD%9C/","excerpt":"1. 给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况例如 abcd 这个字符串，求这四个字符的全排列我们可以这样的进行思考，首先固定第一位的字符，然后把后序的字符依次与第一个位置的字符进行数据位置交换，依次，对于后序的字符我们采用这样方法依次进行交换。按照这种规律，我们可以想到递归的思想。","text":"1. 给定一个字符串求字符串中所有字符组成的全排列即所有字符的组合的情况例如 abcd 这个字符串，求这四个字符的全排列我们可以这样的进行思考，首先固定第一位的字符，然后把后序的字符依次与第一个位置的字符进行数据位置交换，依次，对于后序的字符我们采用这样方法依次进行交换。按照这种规律，我们可以想到递归的思想。 递归求全排列 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; String array = \"abc\"; char[] chars = array.toCharArray(); allSort(chars,0,array.length());&#125;private static void allSort(char[] array, int start, int end) &#123; if (end &lt; 0) &#123; return; &#125; if (start == end) &#123; System.out.println(array); &#125;else &#123; for (int i = start; i &lt; end; i++) &#123; swap(array, start, i); allSort(array,start+1,end); swap(array, i, start); &#125; &#125; &#125; private static void swap(char[] array, int start, int i) &#123; char temp = array[start]; array[start] = array[i]; array[i] = temp; &#125; 除了这种方法外，这个题的递归代码还可以这样写： 123456789101112131415161718public static void main(String[] args) &#123; String array = \"abc\"; allZuHe(\"\", array);&#125;public static void allZuHe(String a, String b) &#123; if (a.length() == 3) &#123; System.out.println(a); &#125; for (int i = 0; i &lt; b.length(); i++) &#123; String atemp = a; String btemp = b; StringBuffer temp = new StringBuffer(b); allZuHe(a+temp.charAt(i),temp.deleteCharAt(i).toString()); &#125;&#125; 2.求一个连续整数数组中的连续子序列和的最大值例如在 {-2,-1,6,-3,-2,7,-15,1,2,2} 中连续子序列的最大是8 即是由数组中的 6 -3 -2 7 构成的连续子序列的和最大 我们可以采用 前i项和与第i项进行比较，取前i项和与第i项的最大值。由于我们每一步的最大值都会变，所以我们需要使用一个变量并记录当前计算或者上一步计算中的最大值 123456789101112131415161718192021public class ArraySum &#123; public static void main(String[] args) &#123; int[] array = &#123;-2,-1,6,-3,-2,7,-15,1,2,2&#125;; int i = FindGreatestSumOfSubArray(array); System.out.println(i); &#125; public static int FindGreatestSumOfSubArray(int[] array) &#123; //max就是上面的dp[i] int max = array[0]; //因为这个dp[i]老是变，所以比如你dp[4]是8 dp[5]就变成-7了，所以需要res保存一下 int res = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; max = Math.max(max + array[i], array[i]); res = Math.max(res, max); &#125; return res; &#125;&#125; 3. 二叉树给定数组构建二叉树由数组构建二叉树，主要是按照数组中的数据顺序，把数组中的数据插入到二叉树中。 最重要的就是先找出非叶子节点的节点序号，需要为每个序号建立他们的左右孩子节点。 123456789101112131415161718192021public static TreeNode creatTreeByArray(int[] array) &#123; List&lt;TreeNode&gt; treeNodeList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; array.length; i++) &#123; treeNodeList.add(new TreeNode(array[i]));//把数组转换为树中的节点 &#125; int countNode = array.length; //节点个数 //为每个父节点添加左右孩子节点 //父节点的个数为countNode/2 父节点的下标为 countNode - 1 for (int i = 0; i &lt; countNode / 2 - 1 ; i++) &#123; treeNodeList.get(i).left = treeNodeList.get(i * 2 + 1); treeNodeList.get(i).right = treeNodeList.get(i * 2 + 2); &#125; int lastTreeNode = countNode / 2 - 1; //如果节点数量为奇数则最后一个父节点有右孩子 treeNodeList.get(lastTreeNode).left = treeNodeList.get(lastTreeNode * 2 + 1); if (countNode % 2 == 1) &#123; treeNodeList.get(lastTreeNode).right = treeNodeList.get(lastTreeNode * 2 + 2); &#125; return treeNodeList.get(0);&#125; 前序遍历的递归与非递归123456789101112131415161718192021222324252627//前序的非递归与递归 public static void preePrintNode(TreeNode treeNode) &#123; TreeNode node = treeNode; if (node == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack(); while(node!=null || !stack.empty())&#123; if (node != null) &#123; System.out.print(node.value+&quot;-&gt;&quot;); stack.push(node); node = node.left; &#125;else&#123; TreeNode pop = stack.pop(); node = pop.right; &#125; &#125; &#125; public static void prePrintNodeDiGui(TreeNode treeNode) &#123; if (treeNode == null) &#123; return; &#125; System.out.print(treeNode.value+&quot;-&gt;&quot;); preePrintNode(treeNode.left); preePrintNode(treeNode.right); &#125; 把 前序遍历的结果存放在集合中12345678910111213141516171819202122232425262728293031323334//前序遍历存集合中public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); preorderTree(root,result); return result;&#125;public void preorderTree(TreeNode root,List&lt;Integer&gt; list)&#123; if (root==null)&#123; return ; &#125; list.add(root.value); preorderTree(root.left,list); preorderTree(root.right,list);&#125;//前序遍历非递归集合public List&lt;Integer&gt; preorderList(TreeNode root)&#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); TreeNode node = root; Stack&lt;TreeNode&gt; stack = new Stack(); while (node != null || !stack.empty()) &#123; if (node != null) &#123; result.add(node.value); stack.push(node); node = node.left; &#125;else &#123; TreeNode pop = stack.pop(); node = pop.right; &#125; &#125; return result;&#125; 中序遍历的递归与非递归1234567891011121314151617181920212223242526272829//中序的非递归与递归public static void middlePrintNode(TreeNode treeNode) &#123; TreeNode node = treeNode; if (treeNode == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.empty()) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125;else &#123; TreeNode pop = stack.pop(); System.out.print(pop.value+\"-&gt;\"); node = pop.right; &#125; &#125;&#125;//递归public static void middlePrintNodeDiGui(TreeNode treeNode) &#123; if (treeNode == null) &#123; return; &#125; middlePrintNodeDiGui(treeNode.left); System.out.print(treeNode.value+\"-&gt;\"); middlePrintNodeDiGui(treeNode.right);&#125; 后序遍历的递归与非递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//后序遍历的非递归public static void houPrintNode(TreeNode treeNode) &#123; TreeNode node = treeNode; TreeNode curnode = null; if (treeNode == null) &#123; return; &#125; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(node); //stack2 按照根右左的顺序进栈 while (!stack1.empty()) &#123; curnode = stack1.pop(); stack2.push(curnode); if (curnode.left != null) &#123; stack1.push(curnode.left); &#125; if (curnode.right != null) &#123; stack1.push(curnode.right); &#125; &#125; while (!stack2.empty()) &#123; System.out.print(stack2.pop().value+\"-&gt;\"); &#125;&#125;//后序非递归集合---把结果存放在集合中public static List&lt;Integer&gt; houPrintTreeList(TreeNode treeNode) &#123; TreeNode node = treeNode; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (node == null) &#123; return result; &#125; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(node); while (!stack1.empty()) &#123; TreeNode curNode = stack1.pop(); stack2.push(curNode); if (curNode.left != null) &#123; stack1.push(curNode.left); &#125; if (curNode.right != null) &#123; stack1.push(curNode.right); &#125; &#125; while (!stack2.empty()) &#123; result.add(stack2.pop().value); &#125; return result;&#125;//后序遍历递归实现public static void houPrintNodeDiGui(TreeNode treeNode) &#123; if (treeNode == null) &#123; return; &#125; houPrintNodeDiGui(treeNode.left); houPrintNodeDiGui(treeNode.right); System.out.print(treeNode.value+\"-&gt;\");&#125; 给定二叉树，返回层次遍历得到的节点1234567891011121314151617181920212223242526272829//层次[[],[],[]]//给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。public static List&lt;List&lt;Integer&gt;&gt; cengciPrintNode(TreeNode treeNode) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (treeNode == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); //Queue&lt;TreeNode&gt; queue2 = new ArrayDeque&lt;&gt;(); queue.offer(treeNode); int count = 0; while (!queue.isEmpty()) &#123; List list = new ArrayList(); count = queue.size(); for (int i = 0; i &lt; count; i++) &#123; TreeNode poll = queue.poll(); list.add(poll.value); if (poll.left != null) &#123; queue.offer(poll.left); &#125; if (poll.right != null) &#123; queue.offer(poll.right); &#125; &#125; result.add(list); &#125; return result;&#125; 二叉树，从最底层向上，依次层次遍历1234567891011121314151617181920212223242526272829//从底向上遍历//给定一个二叉树，返回其节点值自底向上的层次遍历。// （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）public static List&lt;List&lt;Integer&gt;&gt; downToUpCengCiPrint(TreeNode root)&#123; LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); int count = 0; while (!queue.isEmpty()) &#123; List list = new ArrayList(); count = queue.size(); for (int i = 0; i &lt; count; i++) &#123; TreeNode temp = queue.poll(); list.add(temp.value); if (temp.left != null) &#123; queue.offer(temp.left); &#125; if (temp.right != null) &#123; queue.offer(temp.right); &#125; &#125; result.addFirst(list); &#125; return result;&#125; 求树的路径的和1234567891011121314151617181920212223242526272829303132333435363738public class TreeSumPath &#123; public static void main(String[] args) &#123; TreeDemo treeDemo = new TreeDemo(); int[] array = &#123;12,8,6,16,20,22,18&#125;; TreeNode treeNode = treeDemo.creatBinTree(array); List&lt;List&lt;Integer&gt;&gt; path = findPath(treeNode, 36); System.out.println(path.toString()); int pathSum = findPathSum(treeNode); System.out.println(pathSum); &#125; //找二叉树中存在目标值得节点，并打印出路径 public static void treesumPath(TreeNode treeNode,int target) &#123; if (treeNode == null) &#123; return; &#125; ArrayList list = new ArrayList(); printPath(treeNode, target, list); &#125; public static void printPath(TreeNode treeNode, int target, ArrayList list) &#123; if (treeNode == null) &#123; return; &#125; list.add(treeNode.value); target = target - treeNode.value; if (target == 0 &amp;&amp; treeNode.left == null &amp;&amp; treeNode.right == null) &#123; for (Object integer : list) &#123; System.out.print(integer + \" -&gt;\"); &#125; System.out.println(); &#125; else &#123; printPath(treeNode.left, target, list); printPath(treeNode.right, target, list); &#125; list.remove(list.size() - 1); &#125; 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，1234567891011121314//给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，// 这条路径上所有节点值相加等于目标和。public static boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null)&#123; return false; &#125; sum = sum - root.value; if(root.left == null &amp;&amp; root.right == null)&#123; return sum == 0; &#125;else&#123; return hasPathSum(root.left,sum) || hasPathSum(root.right,sum); &#125;&#125; 这条路径上所有节点值相加等于目标的目标路径 返回List&lt;List&gt;1234567891011121314151617181920212223242526272829303132333435363738//给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，// 这条路径上所有节点值相加等于目标的目标路径 返回List&lt;List&lt;Integer&gt;。public static List&lt;List&lt;Integer&gt;&gt; findPath(TreeNode root,int target)&#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; getPath(root, target, result, temp); return result;&#125;public static void getPath(TreeNode treeNode, int target, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp) &#123; if (treeNode == null) &#123; return; &#125; target = target - treeNode.value; if (treeNode.left == null &amp;&amp; treeNode.right == null) &#123; if (target == 0) &#123; temp.add(treeNode.value); result.add(new ArrayList&lt;&gt;(temp)); temp.remove(temp.size() - 1); &#125; return; &#125;else &#123; if (treeNode.left != null) &#123; temp.add(treeNode.value); getPath(treeNode.left,target,result,temp); temp.remove(temp.size() - 1); &#125; if (treeNode.right != null) &#123; temp.add(treeNode.value); getPath(treeNode.right, target, result, temp); temp.remove(temp.size() - 1); &#125; &#125;&#125; 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 //首先找出所有的从根节点带叶子节点的所有路径 //求所有路径组成的数字并求和 public static int findPathSum(TreeNode treeNode) &#123; int result = 0; List&lt;List&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); findPathList(treeNode, resultList, temp); System.out.println(resultList.toString()); for (List list: resultList) &#123; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; list.size(); i++) &#123; stringBuffer.append(list.get(i).toString()); &#125; int t = Integer.parseInt(stringBuffer.toString()); result += t; &#125; return result; &#125; private static void findPathList(TreeNode treeNode, List&lt;List&lt;Integer&gt;&gt; resultList, List&lt;Integer&gt; temp) &#123; if (treeNode == null) &#123; return; &#125; if (treeNode.left == null &amp;&amp; treeNode.right == null) &#123; temp.add(treeNode.value); resultList.add(new ArrayList&lt;&gt;(temp)); temp.remove(temp.size() - 1); &#125;else &#123; if (treeNode.left != null) &#123; temp.add(treeNode.value); findPathList(treeNode.left, resultList, temp); temp.remove(temp.size() - 1); &#125; if (treeNode.right != null) &#123; temp.add(treeNode.value); findPathList(treeNode.right, resultList, temp); temp.remove(temp.size() - 1); &#125; &#125; &#125;&#125; 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。123456789101112131415161718192021222324252627282930313233343536373839404142package com.data.treeDemo;import com.data.TreeNode;/** * 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 * * 本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。 * * 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： *//** * 二叉搜索树的中序遍历就是升序排列的 * 所以升序数组是树的中序遍历 * 用二分法加递归就可以构建二叉树 * * 从定义我们知道，二叉搜索树的中序遍历为一个递增序列，给定的数组其实就是中序遍历结果 * 取有序数组的中间值做根，左边部分做左树，右边部分做右树如此循环迭代去二分就可还原这棵BST树 */public class tranSearchTree &#123; public static void main(String[] args) &#123; int[] array = &#123;-10,-3,0,5,9&#125;; &#125; public TreeNode createSearchTree(int[] array,int start,int end)&#123; if (array == null || array.length == 0) &#123; return null; &#125; //计算中间节点 int middle = start + (end - start) / 2; TreeNode root = new TreeNode(array[middle]); root.left = createSearchTree(array, start, middle); root.right = createSearchTree(array, middle, end); return root; &#125;&#125;","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"回溯问题","slug":"回溯问题","date":"2020-06-12T12:26:32.000Z","updated":"2021-05-16T11:07:29.404Z","comments":true,"path":"2020/06/12/回溯问题/","link":"","permalink":"http://yoursite.com/2020/06/12/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/","excerpt":"回溯问题从网格中寻找单词","text":"回溯问题从网格中寻找单词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.data.stringDemo;/** * 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 * 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。 * 同一个单元格内的字母不允许被重复使用。 * * board = * [ * ['A','B','C','E'], * ['S','F','C','S'], * ['A','D','E','E'] * ] * * 给定 word = \"ABCCED\", 返回 true * 给定 word = \"SEE\", 返回 true * 给定 word = \"ABCB\", 返回 false * *//** * 思路使用递归回溯的方法 * 需要定义一个二维boolean类型的数组，用来存储当前位置是否能走通 * */public class searchWord &#123; public static void main(String[] args) &#123; char[][] array = &#123;&#123;'A','B','C','E'&#125;,&#123;'S','F','C','S'&#125;,&#123;'A','D','E','E'&#125;&#125;; Solution solution = new Solution(); boolean result = solution.exist(array, \"ABCCED\"); System.out.println(result); &#125;&#125;class Solution &#123; public boolean exist(char[][] board, String word) &#123; boolean[][] visited = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (word.charAt(0) == board[i][j] &amp;&amp; backtrack2(i, j, 0, word, visited, board)) return true; &#125; &#125; return false; &#125; private boolean backtrack2(int i, int j, int idx, String word, boolean[][] visited, char[][] board) &#123; if (idx == word.length()) return true; if (i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word.charAt(idx) || visited[i][j]) return false; visited[i][j] = true; //向下找 if (backtrack2(i + 1, j, idx + 1, word, visited, board)) &#123; return true; &#125; //向上找 if (backtrack2(i - 1, j, idx + 1, word, visited, board)) &#123; return true; &#125; //向右 if (backtrack2(i, j + 1, idx + 1, word, visited, board)) &#123; return true; &#125; //向左 if (backtrack2(i, j - 1, idx + 1, word, visited, board)) &#123; return true; &#125; visited[i][j] = false; // 回溯 return false; &#125;&#125;","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归回溯","slug":"递归回溯","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/"}]},{"title":"链表操作","slug":"链表操作","date":"2020-06-12T12:24:32.000Z","updated":"2021-05-16T11:04:06.719Z","comments":true,"path":"2020/06/12/链表操作/","link":"","permalink":"http://yoursite.com/2020/06/12/%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"链表操作判断单链表是否有环第一种方式，我们可以使用快慢指针的形式","text":"链表操作判断单链表是否有环第一种方式，我们可以使用快慢指针的形式 * 开始，快慢指针都指向头结点，快指针每次都两步，慢指针每次走一步 * 如果存在环，则在运行中，无论运行了几圈，快慢指针肯定会相等，也就是指向同一个位置 * 除此之外，还有另一种解题方式123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.data.LinkListDemo;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class LinkedListDemo &#123; //判断一个单链表中是否有环 /** * 第一种方式，我们可以使用快慢指针的形式 * 开始，快慢指针都指向头结点，快指针每次都两步，慢指针每次走一步 * 如果存在环，则在运行中，无论运行了几圈，快慢指针肯定会相等，也就是指向同一个位置 * 除此之外，还有另一种解题方式 * @param head * @return */ public boolean hasCycle(ListNode head) &#123; ListNode first = head; ListNode slow = head; while (first != null &amp;&amp; first.next!=null) &#123; first = first.next.next; slow = slow.next; if (first == slow) &#123; return true; &#125; &#125; return false; &#125; //可以使用一个set集合，存放遍历过的节点，如果下次遍历时存在同样的节点，则证明该单链表中存在环 public boolean hasCycle2(ListNode head) &#123; Set&lt;ListNode&gt; set = new HashSet&lt;&gt;(); ListNode temp = head; while (temp != null) &#123; if (set.contains(temp))&#123; return true; &#125; set.add(temp); temp = temp.next; &#125; return false; &#125; 判断链表有环，并找出入环的第一个节点123456789101112131415161718192021222324252627282930313233343536373839404142 //判断链表有环，并找出入环的第一个节点 /** * 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 * 如果 pos 是 -1，则在该链表中没有环。 * * 输入：head = [3,2,0,-4], pos = 1 * 输出：tail connects to node index 1 * 解释：链表中有一个环，其尾部连接到第二个节点。 * * 主要解题思路 * 1，首先是使用快慢指针找出链表中存在环的指针位置 * 2，指针执行当前快慢指针相交的位置 cur * 3. 另一个mo指针从头结点开始向后遍历 mo * 4. 当 cur与mo相等，即当前位置为入环的位置 */ public ListNode hasCyclePlace(ListNode listNode) &#123; ListNode first = listNode; ListNode slow = listNode; ListNode cur = null; ListNode mo = listNode; while (first != null &amp;&amp; first.next != null) &#123; first = first.next.next; slow = slow.next; if (first == slow) &#123; cur = slow; break; &#125; &#125; if (cur != null) &#123; while (cur != mo) &#123; cur = cur.next; mo = mo.next; &#125; &#125; return cur; &#125;&#125; 判断一个数组是不是二叉树的后序遍历1234567891011121314151617181920212223242526272829303132333435363738package com.data;public class verifySquenceBST &#123; public static void main(String[] args) &#123; int[] array = &#123;5,7,6,9,11,10,8&#125;; boolean b = verfySequenceofBST(array, array.length); System.out.println(b); &#125; //给定一个数组，判断这个数组是不是二叉搜索树的后序遍历 public static boolean verfySequenceofBST(int[] array, int length)&#123; if (array == null || length &lt; 0) &#123; return false; &#125; int root = array[length - 1];//树的根节点 int i = 0; for (; i &lt; length-1; i++) &#123; if (array[i] &gt; root) &#123; break; &#125; &#125; for (int j = i; j &lt; length-1; j++) &#123; if (array[j] &lt; root) &#123; return false; &#125; &#125; boolean left =true; if (i &gt; 0) &#123; left = verfySequenceofBST(array, i); &#125; boolean right = true; if (i&lt;length-1)&#123; right = verfySequenceofBST(array, length - i - 1); &#125; return left&amp;&amp;right; &#125;&#125; 单例模式饿汉式1234567891011package com.data.sheji;public class SingleInstance &#123; private static SingleInstance singleInstance = new SingleInstance(); private SingleInstance()&#123;&#125; private static SingleInstance getSingleInstance()&#123; return singleInstance; &#125;&#125; 懒汉式1234567891011121314package com.data.sheji;//懒汉式public class SingleInstance2 &#123; private static SingleInstance2 singleInstance = null; private SingleInstance2()&#123;&#125; private static SingleInstance2 getInstance()&#123; if (singleInstance == null) &#123; return new SingleInstance2(); &#125; return singleInstance; &#125;&#125; 双重验证1234567891011121314151617181920212223242526272829303132package com.data.sheji;//双重验证public class SingleInstance3 &#123; private static SingleInstance3 singleInstance3 = null; public static void SingleInstance3()&#123;&#125; public static SingleInstance3 getInstance3()&#123; if (singleInstance3 == null) &#123; synchronized (SingleInstance3.class) &#123; if (singleInstance3 == null) &#123; return new SingleInstance3(); &#125; &#125; &#125; return singleInstance3; &#125;&#125;class SingleInastance4&#123; private static void SingleInastance4()&#123;&#125; private static class SingleHolder&#123; private static SingleInastance4 singleInastance = new SingleInastance4(); &#125; public static SingleInastance4 getInstance()&#123; return SingleHolder.singleInastance; &#125;&#125;","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-06-11T12:26:32.000Z","updated":"2021-05-16T11:04:06.712Z","comments":true,"path":"2020/06/11/单例模式/","link":"","permalink":"http://yoursite.com/2020/06/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"单例模式单例模式饿汉式","text":"单例模式单例模式饿汉式 1234567891011package com.data.sheji;public class SingleInstance &#123; private static SingleInstance singleInstance = new SingleInstance(); private SingleInstance()&#123;&#125; private static SingleInstance getSingleInstance()&#123; return singleInstance; &#125;&#125; 懒汉式1234567891011121314package com.data.sheji;//懒汉式public class SingleInstance2 &#123; private static SingleInstance2 singleInstance = null; private SingleInstance2()&#123;&#125; private static SingleInstance2 getInstance()&#123; if (singleInstance == null) &#123; return new SingleInstance2(); &#125; return singleInstance; &#125;&#125; 双重验证1234567891011121314151617181920212223242526272829303132package com.data.sheji;//双重验证public class SingleInstance3 &#123; private static SingleInstance3 singleInstance3 = null; public static void SingleInstance3()&#123;&#125; public static SingleInstance3 getInstance3()&#123; if (singleInstance3 == null) &#123; synchronized (SingleInstance3.class) &#123; if (singleInstance3 == null) &#123; return new SingleInstance3(); &#125; &#125; &#125; return singleInstance3; &#125;&#125;class SingleInastance4&#123; private static void SingleInastance4()&#123;&#125; private static class SingleHolder&#123; private static SingleInastance4 singleInastance = new SingleInastance4(); &#125; public static SingleInastance4 getInstance()&#123; return SingleHolder.singleInastance; &#125;&#125;","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"作业帮面试整理","slug":"作业帮面试整理","date":"2020-06-09T14:26:32.000Z","updated":"2021-05-16T11:04:06.712Z","comments":true,"path":"2020/06/09/作业帮面试整理/","link":"","permalink":"http://yoursite.com/2020/06/09/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/","excerpt":"Linux常用命令","text":"Linux常用命令 一面： 1.自我介绍 2.讲讲之前实习是做了什么工作 3.项目做了什么，为什么做这个项目，有什么困难，如何解决，结果是什么。 看你项目中遇到的困难在缓存和数据库，那你项目的后端框架用的是什么，数据库的底层数据结构是什么，磁盘的数据结构是什么？ . B+树的结构是什么，和B树有什么区别，红黑树结构是什么？ 红黑树的应用有哪些？AVL树是什么，平衡二叉树的条件是什么？ 一、B树的应用1、B树大量应用在数据库和文件系统当中。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法减少定位记录时所经历的中间过程，从而加快存取速度。 假定一个节点可以容纳100个值，那么3层的B树可以容纳100万个数据，如果换成二叉查找树，则需要20层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在100万个数据中查找目标值，只需要读取两次硬盘。 如mongoDB数据库使用，单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多） 二、B+树的应用mysql使用B+树作为索引： B+树相对B树的优点： ①B+树的所有Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串联起来，遍历叶子节点就能获取全部数据，这样就能进行区间访问了。 ②IO一次读数据是从磁盘上读的，磁盘容量是固定的，取数据量大小是固定的，非叶子节点不存储数据，节点小，磁盘IO次数就少。 InnoDB索引和MyISAM最大的区别是它只有一个数据文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点数据域保存了完整的数据记录。所以我们又把它的主索引叫做聚集索引。而它的辅助索引和MyISAM也会有所不同，它的辅助索引都是将主键作为数据域。所以，这样当我们查找的时候通过辅助索引要先找到主键，然后通过主索引再找到对于的主键，得到信息。 MyISAM表索引在处理文本索引时更具优势，而INNODB表索引在其它类型上更具效率优势，同时MySQL高并发需要事务场景时，只能使用INNODB表 三、红黑树红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。 如linux中进程的调度用的是红黑树。 反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。 哈希表用什么解决冲突的？拉链法 拉链法解决冲突可以，但是如果链表变长，如何优化呢？ HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）,时，将链表转换为红黑树，这样大大减少了查找时间。 一直到JDK7为止，HashMap的结构都是这么简单，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。 这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。再最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。 如果优化为树结构，数据量依旧很大，如何进一步优化？10 数据库读写分离机制，如何做分库分表的？用的什么中间件去分库分表？11.如何确保数据库的稳定性 12.算法：链表反转 13.有什么要问我的？ 1.自我介绍2.做过哪些项目，给自己印象最深的项目是什么3.用redis做二级缓存的时候如何确保高并发数据的一致性，如果有一张订单表，我要你找到对应用户所拥有的订单，怎么找？数据库的几种事务隔离机制是什么，有哪些？有什么用？ mysql支持事务的常用引擎是InnoDB 第一种：读未提交（read uncommitted） 第一个事务未提交更新的数据，第二个事务可以读到，这是读未提 交。 第一个事务未提交更新的数据回滚，第二个事务读到回滚的数据， 这是脏读。故读未提交，可能会出现脏读。 第二种：读已提交（read committed），也称不可重复读 第一个事务未提交更新的数据，第二个事务读不到； 第一个事务提交更新的数据，第二个事务可以读到；这是读已提交。 第一个事务提交更新小明同学年龄12岁，第二个事务读到小明12 岁； 第三个事务再次提交更新小明同学年龄14岁，第二个事务再读到小明14岁；这是不可重复读（同一个事务内读取的数据结果不一致）。 故读已提交，会出现不可重复读（同一个事务内读取的数据结果不 一致），不可重复读也会造成幻读（同一个事务内读取的数据结果 不一致）。 第三种：可重复读（repeatable read），mysql默认事务隔离级别 第一个事务提交更新小明同学年龄12岁，第二个事务读到小明12岁； 第三个事务再次提交更新小明同学年龄14岁，第二个事务再读到小明12岁；这是可重复读（同一个事务内读取的数据结果一致）。 第四个事务提交插入同学小马数据记录，第二个事务再读不仅读到小明12 岁数据，还会读到小马同学数据，这是幻读。 故可重复读，会出现幻读（同一个事务内读取的数据结果不一致）。 第四种：串行化（serializable） 隔离级别最高，解决了脏读、不可重复无、幻读问题。 同一个事务内，不管读取多少次，结果集永远一致。 Str1=“a” str2=new string(“a”)区别，虚拟机内存空间上如何体现这两个区别，这区别具体在开发中会造成什么问题，如何解决？ ==:比较引用类型比较的是地址值是否相同 equals:比较引用类型默认也是比较地址值是否相同，注意:\\String类重写了equals()方法**，比较的是内容是否相同。 String A = “ABC”;内存会去查找永久代(常量池) ，如果没有的话，在永久代中中开辟一块儿内存空间，把地址付给栈指针，如果已经有了”ABC”的内存，直接把地址赋给栈指针；**** \\而String str = new String(“a”);是根据”a”这个String对象再次构造一个String对象;在堆中从新new一块儿内存，把指针赋给栈，** 堆 栈 变量的存放位置 Java和C++在内存处理上有什么区别？虚拟机的常用垃圾回收机制有什么？什么时候会发生OOM错误（内存溢出错误）栈溢出，堆溢出 栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化） 所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。 heap space表示堆空间，堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出 Redis的基本数据结构是什么？redis如何做持久化的？给你一个场景，设计秒杀系统，假设有10件商品， 先用redis去get数量，数量-1，然后用set更新redis的数据，如果get数据为0就表示商品卖完了，这种情况安全么，有问题的话如何解决redis加锁上锁的命令是什么Linux awk grep命令是什么，如何用正则表达式匹配AxxxxAxxx？（正则还是用的比较少 生疏了。。。）讲一下在浏览器输入URL之后到浏览器出现界面的全过程，系统后面用了哪些协议 首先进行域名解析，域名解析具体过程讲一下： 浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找： 本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址； 本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址； 本地域名服务器向权限域名服务器发起请求，得到IP地址； 本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来； 操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来； 至此，浏览器已经得到了域名对应的IP地址。 浏览器发起HTTP请求； 接下来到了传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息–三次握手建立连接–四次挥手断开连接； 然后到了网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址； 接下来到了数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层； 服务器响应请求并请求客户端要的资源，传回给客户端； 断开TCP连接，浏览器对页面进行渲染呈现给客户端。 如果你有很多IP地址，如何找到出现次数最多的前三个IP地址？（hashMap + heap） 1.直接排序 2.使用hashTable 我们的算法就有了：维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。 本方法相比算法1：在时间复杂度上提高了一个数量级，为O（N），但不仅仅是时间复杂度上的优化，该方法只需要IO数据文件一次，而算法1的IO次数较多的，因此该算法2比算法1在工程上有更好的可操作性。 如果你有一个100G的IP地址文件，你的机器只有5G存储空间，如何找到出现次数最多的前三IP地址？如果一张订单表特别大，你会如何处理这个表格，如何优化它？我们一般都是把历史数据定期转存其他表（一样的表名后加年月例如TABLE201205）归档~这样该表本年度的查询的压力也小点（90%查询量集中在本年度）,即使查询历史数据也不影响性能，强力推荐！ 算法题：字符串切分+反转123456789101112131415161718192021222324252627public class reverseString &#123; public static void main(String[] args) &#123; // i am a student String string = \"i am a student\"; String s = reverseDemo(string); System.out.println(s); &#125; public static String reverseDemo(String string)&#123; String[] strArr = string.split(\" \"); String[] resultArr = new String[strArr.length]; StringBuffer stringBuffer = new StringBuffer(); for (int i=0;i&lt;strArr.length;i++)&#123; resultArr[i] = strArr[strArr.length - i - 1]; if (i != strArr.length - 1) &#123; stringBuffer.append(resultArr[i]); stringBuffer.append(\" \"); &#125;else &#123; stringBuffer.append(resultArr[i]); &#125; &#125; return stringBuffer.toString(); &#125;&#125; 16.盲人有10双袜子，两双黑的，8双白的，如何在没人帮助下找出黑的（在太阳下晒一晒黑色更吸热）17.你有什么问题想问我的？MYSQL日志分为几种https://blog.csdn.net/xiamiflying/article/details/80960598 如何保证回滚 数据库中事务到底是mvcc回滚还是日志回滚 socket有几种状态Socket 11种状态 1、SOCKET状态介绍 socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口;HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。 1、客户端独有的：（1）SYN_SENT （2）FIN_WAIT1 （3）FIN_WAIT2 （4）CLOSING （5）TIME_WAIT 。 2、服务器独有的：（1）LISTEN （2）SYN_RCVD （3）CLOSE_WAIT （4）LAST_ACK 。 3、共有的：（1）CLOSED （2）ESTABLISHED 。 mysql更新了数据日志文件有什么改变它的意思是服务器崩了，你访问服务器应该是什么样服务器崩了发送什么错误码，崩了情况下500是谁发的开发环境和生产环境不一样，配置环境应该有什么不同配置数据库ACID死锁以及解决措施 rabbitmq中各种模式堆栈区别GC回收算法点击按钮这个过程详解一下 算法题：长字符串相加nums[] = {1,-1,0,2,-2,1,3} 找到所有不重复a + b + c = 0 123456789101112131415161718192021222324252627282930313233暴力解法，而且重复public class zifuJia &#123; public static void main(String[] args) &#123; int[] array = &#123;1,-1,0,2,-2,1,3&#125;; List list = stringSum(array); System.out.println(list); &#125; public static List stringSum(int[] array)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(array); for (int i = 0; i &lt; array.length; i++) &#123; if (i &gt; 1 &amp;&amp; array[i] == array[i - 1]) &#123; continue; &#125; for (int j = i + 1; j &lt; array.length; j++) &#123; for (int k = j + 1; k &lt; array.length; k++) &#123; if (array[i] + array[j] + array[k] == 0) &#123; list.add(Arrays.asList(array[i], array[j], array[k])); &#125; &#125; &#125; &#125; for (int i = 0; i &lt; list.size()-1; i++) &#123; if (list.get(i).equals(list.get(i+1)))&#123; list.remove(list.get(i + 1)); &#125; &#125; return list; &#125;&#125; 堆排序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class heapSort &#123; public static void main(String[] args) &#123; int[] array = &#123;12,15,10,18,6,9,16&#125;; heap_sort(array, array.length); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]+\" \"); &#125; &#125; /** * 参数说明 arr 表示待构建数组 * n：表示堆的元素个数 * i: 表示每一个小堆的父节点 */ public static void heap_step(int[] arr, int n, int i) &#123; int c1 = 2 * i + 1; //i结点的左孩子 int c2 = 2 * i + 2; //i结点的右孩子 int max = i; //这三个元素最大值的下标指向 //定义递归出口 if (i &gt; n) &#123; return; &#125; if (c1 &lt; n &amp;&amp; arr[c1] &gt; arr[max])&#123; max = c1; &#125; if (c2 &lt; n &amp;&amp; arr[c2] &gt; arr[max]) &#123; max = c2; &#125; if (max != i) &#123; swap(arr, max, i);//交换两个位置的元素 heap_step(arr, n, max);//继续进行递归判断，确保每一次构建完任意一个小堆都是大顶堆 &#125; &#125; /** * 我们需要对每一个非叶子结点以及他们的左右孩子构建大顶堆 * 从最后一个非叶子结点开始 * 最后一个叶子结点数组下标为： last_node = arr.length-1 * 则最后一个非叶子结点为 last_parent = (last_node-1)/2 * @param arr * @param n */ public static void build_heap(int[] arr, int n) &#123; int last_node = n-1; int last_parent = (last_node-1)/2; //对每一个非叶子结点，依次从后向前遍历，每一个都做heap_step的大顶堆构建 for (int i = last_parent; i &gt;=0 ; i--) &#123; heap_step(arr,n,i); &#125; &#125; /** * 构建完大顶堆之后，需要进行大顶堆的第一个元素与最后元素进行交换 * @param arr */ public static void heap_sort(int[] arr,int n)&#123; build_heap(arr, arr.length); //把数组先构造成为一个大顶堆 // 这个时候数组已经是一个大顶堆了 //交换数据 for (int i = n - 1; i &gt;= 0; i--) &#123; swap(arr, i, 0); /* 因为这个时候完全二叉树已经是一个大顶堆了， 所以我们只需要使用heap_step交换最顶层的三个数字就可以,也就是最根节点以及它们的左右孩子节点 */ heap_step(arr, i, 0); &#125; &#125; /* 两个元素交换位置的函数 */ public static void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 快速排序;问了项目，单点登录实现 如何解决分布式session redis集群怎么做的，主从复制流程 RDB和AOF，如果AOF文件很大怎么办，AOF重做，还是特别大怎么办，分片复制 TCP三次握手四次挥手三次挥手行不行，为什么 状态码301与302的区别详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了） 301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved ) Linux找到文件夹下包含某个字符的所有记录grep -r message ./ 示例解释：在当前目录下递归查找含有字符串message的文件 -r 是递归查找 -n 是显示行号 -R 查找所有文件包含子目录 -i 忽略大小写 分页查询页数很大效率低怎么办，join 连接主键优化select * from orders_history where type=8 limit 100000,100; \\这种分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。** (1) \\使用子查询优化–**这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。 (2) \\使用 id 限定优化******—****这种方式假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询 (3) 当然还可以使用 in 的方式来进行查询，这种方式经常用在多表关联的时候进行查询，使用其他表查询的id集合，来进行查询 聚簇索引和非聚簇索引聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。 索引覆盖(1) 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。 (2) 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。 一个包含查询所需字段的索引称为“覆盖索引” MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少IO，提高了效率 算法：下一个排列solr怎么用的，zookeeper怎么用的 如何保证solr与数据库一致性 DNS递归和迭代一、主机向本地域名服务器的查询一般都是采用递归查询。 ​ 所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份， ​ 向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。 ​ 因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 二、本地域名服务器向根域名服务器的查询的迭代查询。​ 迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。 ​ 然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。 ​ 顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。 ​ 最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机 CAS原理，ABA问题，解决方法volatile只能保证可见性，不能保证原子性。 但原子类（AtomicInteger等可以保证原子性），原子类利用volatile+CAS来保证原子性 CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 CAS原理独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 CAS存在的问题CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作 ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 Dubbo原理注册中心宕机怎么办RPC分为哪几部分Linux常用命令，让我按要求查日志，就是grep，cut，啥的cat 查看文件 cat 文件名 ——一次显示整个文件的内容 将几个文件合并为一个文件 $cat file1 file2 &gt; file grep 搜索 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。 ps -ef | grep redis 查找指定进程 从文件中查找关键词 Grep “cat” 文件名 搜索log目录下卡号为：“4563513600036385540”,在哪个文件的具体位置及行数 grep -rin “4563513600036385540” log/ Cut 剪切文件 cut命令是一个选取命令，其功能是将文件中的每一行”字节” ”字符” ”字段” 进行剪切，选取我们需要的，并将这些选取好的数据输出至标准输出 Cut -c 文件名 以字符为单位进行分割 Cut -d 文件名 默认制表符分割 ES倒排索引 算法： \\1. 一个字符串数组，按长度大小，相同长度按字典顺序 字符数组排序 public static void sortString(String[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = i + 1; j &lt; arr.length; j++) { if (arr[i].compareTo(arr[j]) &gt; 0) //字符串比较 arr[i].compareTo(arr[j]) swap(arr, i, j); } }} 2.EXCEL数字转字母 生活中你是怎样的人 举个例子 了解作业帮吗 说说你的缺点 说说你觉得经历过比较困难的时间 有看非技术的书吗，推荐下， 介绍下*本书讲了什么 对未来的规划 想来北京发展吗等等 一面： 一棵m阶的B-tree(m叉树)：树中每个结点至多()个孩子，除根结点和叶子结点外，其它每个结点至少有()个孩子 B 树又叫平衡多路查找树。一棵m阶的B 树 (m叉树)的特性如下： 树中每个结点最多含有m个孩子（m&gt;=2）； 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）； 若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）； 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)； 每个非终端结点中包含有n个关键字信息： (P1，K1，P2，K2，P3，……，Kn，Pn+1)。其中： ​ a) Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 ​ b) Pi为指向子树根的接点，且指针P(i)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 ​ c) 关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。 二进制1101.01转化成十进制快速排序的平均时间复杂度和最坏时间复杂度是多少排序算法的时间复杂度(7&lt;&lt;1)&amp;15运算后的结果是TCP/IP协议栈(说的越多越好)那为什么要叫TCP/IP协议栈内，这些协议和栈有什么关系呢，大家应该都知道栈是一种先进后出的数据结构，那这和TCP/IP协议有什么关系呢？我们就拿一个HTTP报文来说吧，HTTP报文属于应用层协议的报文，我们输入网址，首先会调用到DNS协议（域名协议，后面会讲到），然后把我们输入的网址转换为IP地址，这个IP地址大致就相当于现实生活中每个人的身份证一样，是每个网页唯一的标识，关于IP地址，后续我会详细介绍，IP协议属于网络层的协议。我们先将HTTP报文压入一个栈中（就好像是在分装报文），然后是IP，不对，我们貌似漏了一个传输层啊，别急别介，HTTP报文在传输层用的是TCP协议，好，我们把TCP压入栈中，再讲IP层也压入栈中，至于链路层的话，就用最常见的以太网就OK了，好了，现在我们的栈里面从头至尾依次是以太帧头-IP协议-TCP协议-HTTP协议，然后我们先忽略最底层的物理层，假设这个封装好的栈一样的报文漂洋过海，来到了它的目的地（至于怎么过来的，我们后续也会讲到），当对端收到这个报文以后，也就是我们封装好的这个栈一样的东西以后该怎么办呢？会不会也是先拿HTTP呢？因为这个报文是我们构造的一个栈，所以说它的顺序肯定也是栈，因此拿取的顺序就是以太帧头-IP协议-TCP协议-HTTP协议，发现没，最先被封装入的HTTP报文是最后才被拿出来的，这中间的细节如果能全部掌握，那基本商就算是入门了，关于这部分东西，我会在后面详细介绍，现在有这个概念就可以了。 二面：说一下你项目中遇到的最大的问题，如何解决的（再次把我毫不相关的科研项目扯了一通）堆和栈 const和define的区别Linux用过吗一个文件里面有很多ip地址，如何用grep命令查看出现次数最多的三个？用awk呢？awk wk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk ‘BEGIN{ commands } pattern{ commands } END{ commands }’ 第一步：运行BEGIN{ commands }语句块中的语句。 第二步：从文件或标准输入(stdin)读取一行。然后运行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行反复这个过程。直到文件所有被读取完成。 第三步：当读至输入流末尾时，运行END{ commands }语句块。 BEGIN语句块在awk開始从输入流中读取行之前被运行，这是一个可选的语句块，比方变量初始化、打印输出表格的表头等语句通常能够写在BEGIN语句块中。 END语句块在awk从输入流中读取全然部的行之后即被运行。比方打印全部行的分析结果这类信息汇总都是在END语句块中完毕，它也是一个可选语句块。 可用awk来统计固定格式日志里的一些数据，如日志中出现过所有不同的IP awk ‘{i=$1;count[i]++}END{for(i in count)print(i,count[i])}’ /var/log/httpd/access_log awk对文件进行流处理，每次读取一行。$1就是IP，count[i]++是将IP作为一个数组的下标，并且使得统计这个IP所对应的数组元素自增 也可以用来找出访问次数最多的ip。 awk ‘{a[$1] += 1;} END {for (i in a) printf(“%d %s\\n”, a[i], i);}’ 日志文件 | sort -n | tail -n 10 #用tail显示最后10行 有一个文件ip.txt，每行一条ip记录，共若干行，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？ sort ip.txt | uniq -c | sort -rn | head -n 3 root用户如何修改文件的所属人？谈到了chmod命令 chmod作用：修改文件、目录的权限 有两种方式修改权限 （1）+ 、-、= 变更权限 u：所有者 g:所在组 o：其他组 a：所有人(u、g、o的总和) ① chmod u=rwx, g=rx, o=x 文件目录名 ② chmod o+w 文件目录名 给其他组的用户增加写的权限 ③ chmod a-x 文件目录名 给所有人去掉可执行文件的权限 算法题：面试官说有一道简单的，一道难一点的，让我自己选择，因为前面linux命令那块答得不太好，就选了难的那道 给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于”niuniu”子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class niuniuString &#123; /** * 给出一个字符串S，牛牛想知道这个字符串有多少个子序列等于\"niuniu\" * 子序列可以通过在原串上删除任意个字符(包括0个字符和全部字符)得到 */ public static void main(String[] args) &#123; String str = \"yrabbbit\"; String str2 = \"rabbit\"; int i = numDistinct(str, str2); System.out.println(i); &#125; public static int numDistinct(String S, String T) &#123; if(S==null&amp;&amp;T==null) return 1; if(S==null&amp;&amp;T!=null) return 0; if(S!=null&amp;&amp;T==null) return 1; int[][]dp=new int[S.length()+1][T.length()+1]; dp[0][0]=1; for(int i=1;i&lt;=S.length();i++)&#123; dp[i][0]=1; &#125; for(int i=1;i&lt;=T.length();i++)&#123; dp[0][i]=0; &#125; for(int i=1;i&lt;=S.length();i++)&#123; for(int j=1;j&lt;=T.length();j++)&#123; if(S.charAt(i-1)!=T.charAt(j-1))&#123; dp[i][j]=dp[i-1][j]; &#125; else&#123; dp[i][j]=dp[i-1][j]+dp[i-1][j-1]; &#125; &#125; &#125; for (int i =0;i&lt;dp.length;i++)&#123; for (int j = 0; j &lt; dp[0].length; j++) &#123; System.out.print(dp[i][j]+\" \"); &#125; System.out.println(); &#125; return dp[S.length()][T.length()]; &#125;&#125; 求子串的长度算法123456789101112131415161718192021222324252627282930313233343536373839404142public class StringDemo &#123; public static void main(String[] args) &#123; String str = \"vrabbbit\"; String str2 = \"rabbit\"; int i = childString(str, str2); System.out.println(i); &#125; public static int childString(String s1,String s2)&#123; if (s1 == null &amp;&amp; s2 == null) &#123; return 1; &#125; if (s1 == null &amp;&amp; s2 != null) &#123; return 0; &#125; int[][] result = new int[s1.length()+1][s2.length()+1]; for (int i = 0; i &lt; result.length; i++) &#123; for (int j = 0; j &lt; result[0].length; j++) &#123; System.out.print(result[i][j]+\" \"); &#125; System.out.println(); &#125; for (int i = 1; i &lt; result.length; i++) &#123; for (int j = 1; j &lt; result[1].length; j++) &#123; if (s1.charAt(i-1) == s2.charAt(j-1)) &#123; result[i][j] = result[i-1][j-1]+1; &#125;else &#123; if (result[i][j - 1] &gt;= result[i - 1][j]) &#123; result[i][j] = result[i][j-1]; &#125;else &#123; result[i][j] = result[i-1][j]; &#125; &#125; &#125; &#125; return result[s1.length()][s2.length()]; &#125;&#125; 3、linux命令（我平时不太用linux就只知道哪些情况用什么命令但是具体参数不太知道；问了查找文件里关键词最多的怎么查，还有查找进程名为live的进程等等grep -count 文件名称 | tail 10 4、数据库查找stu表内名字为lily，住址包含北京的信息，按年龄降序排序；我开始是select *然后要求只查住址列怎么办？然后问我修改包含北京的列里北京两个字为上海怎么办（replace我没用过…int和Integer的区别，为什么有了int还需要IntegerArrayList和LinkedList区别，各有什么特点进程和线程的区别，联系多线程编程，死锁检测与预防，死锁的检测手段，怎样避免死锁讲一讲线程池，讲讲为什么很多公司对于线程池的使用非常谨慎SQL代码书写：有一个学生信息表包含id，学号，选修课程和该课程的成绩，写一个SQL语句来查找总分最高的前十名同学。建表过程中索引添加的规范InnoDB的4种事务隔离级别SSM和Spring Boot的比较，Spring Boot的缺点(没答上来，面试官的解释是Spring Boot封装层数过多导致的性能问题)假如有10亿个手机号，怎么样快速判断一个手机号是否在其中(一开始没什么好的思路，面试官一步一步从hash，二分，布隆过滤器引导到位图)机智题：烧完一整根香需要30分钟，怎么样得到15分钟的计时，怎么样得到7.5分钟的计时算法题：把数组中奇数放在前面，偶数放在后面，并且奇数偶数都要保证从小到大，要求空间复杂度O(1)MySQL索引结构，说说B树和B+树的区别MySQL索引什么时候失效，联合索引，聚集索引聚集索引：聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。聚集索引的叶子节点称为数据页，每个数据页通过一个双向链表来进行链接，而且数据页按照主键的顺序进行排列。 辅助索引：辅助索引(二级索引)：叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。 覆盖索引： 当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。 写一个单例模式Redis数据结构，场景题 讲讲Java的堆内存、GC Java把内存分成两种，一种叫做栈内存，一种叫做堆内存，有着不同的作用。栈内存用来存储局部变量和方法调用。栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，\\数**组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针! 说说抽象类和接口的区别 相同点：都不能被实例化 区别一，两者表达的概念不一样。抽象类是一类事物的高度聚合，那么对于继承抽象类的子类来说，对于抽象类来说，属于“是”的关系；而接口是定义行为规范，因此对于实现接口的子类来说，相对于接口来说，是“行为需要按照接口来完成”。 区别二，抽象类在定义类型方法的时候，可以给出方法的实现部分，也可以不给出；而对于接口来说，其中所定义的方法都不能给出实现部分。 区别三，继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，可以不用重写，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中必须要给出相应的方法和属性实现。 区别四，在抽象类中，新增一个方法的话，继承类中可以不用作任何处理；而对于接口来说，则需要修改继承类，提供新定义的方法。 写程序。排序。要求奇数放到前面，偶数放到后面(空间复杂度o(1)) 一次http请求过程发生了什么 springmvc处理过程(http请求服务端发生了那些) （1）我们应该都知道在启动一个Spring MVC项目的时候，我们要在web.xml配置文件中声明DispatcherServlet。如下图的web.xml所示，这个Servlet监听的URL是*模式，这意味着所有的请求都能通过DispatcherServlet。 URL匹配模式是非常重要的，如果请求符合DispatcherServlet配置的URL模式,那么这个请求就会被处理，否则就不会。DispatcherServlet根据URL请求的地址把请求传给指定的controller。那么DispatcherServlet是如何知道请求要传给哪个controller的呢？ 使用@RequestMapping注解或者Spring MVC配置文件，可以找到URL请求的controller。当然也可以用特定的请求注解，比如@GetMapping或PostMapping。controller文件必须使用@Controller或@RestController(Restful风格)注解进行标记。 最后，总结一下Spring MVC处理HTTP请求的过程 1.客户端发送HTTP请求到指定的URL。 2.Spring MVC的DispatcherServlet接收到请求 3.DispatcherServlet把请求传到用@Controller和@RequestMapping注解的controller 4.Spring MVC返回逻辑视图的名称和模型给DispatcherServlet 5.DispatcherServlet咨询视图处理器直到有实际的视图来展示数据为止 6.DispatcherServlet使用模型数据联系所选的视图，例如Thymeleaf,Freemarker,JSP,并根据数据模型呈现输出。 7.呈现的输出作为响应返回给客户端 以上就是Spring MVC的工作流程或者说Spring MVC处理HTTP请求的过程。 mybatis执行过程，原理 怎么转换成html了。(没怎么写过前端，都是传json数据) 为什么握手是三次 数据库索引用的什么结构。b 树比b树有什么优势 最左前缀(数据库自己的优化) 单例模式 session和cookie JAVA垃圾回收 二面 分享一个你觉得比较有的讲得实习经历(五分钟) 怼项目(十分钟) JAVA是自学的还是开的课程 学习JAVA你怎么学习的 JAVA虚拟机内存模型 syn和lock 可重入锁实现原理 事务用来做什么 lru 网络方面TCP断开time_wait(什么时候进入这种状态，为什么要有这种状态) 快排 对工作的方向对语言有要求吗 看你学JAVA很多，是因为这方面需求比较大吗 平时得工作环境在Linux吗 统计某个字符串的行数统计用什么命令 Grep -count “字符串” 文件名称 统计某个文件的行数 Wc 文件名 显示行数 字数 字节数 有什么要问我的吗？ MYSQL日志分为几种 如何保证回滚 数据库中事务到底是mvcc回滚还是日志回滚socket有几种状态mysql更新了数据日志文件有什么改变它的意思是服务器崩了，你访问服务器应该是什么样服务器崩了发送什么错误码，崩了情况下500是谁发的开发环境和生产环境不一样，配置环境应该有什么不同配置数据库ACID死锁以及解决措施rabbitmq中各种模式堆栈区别GC回收算法点击按钮这个过程详解一下 算法题：长字符串相加nums[] = {1,-1,0,2,-2,1,3} 找到所有不重复a + b + c = 0","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试，作业帮","slug":"面试，作业帮","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E4%BD%9C%E4%B8%9A%E5%B8%AE/"}]},{"title":"Java常见面试题整理","slug":"Java常见面试题整理","date":"2020-06-09T12:26:32.000Z","updated":"2021-05-17T01:32:09.861Z","comments":true,"path":"2020/06/09/Java常见面试题整理/","link":"","permalink":"http://yoursite.com/2020/06/09/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"java常见面试题整理","text":"java常见面试题整理 java相关：Java中线程安全的集合类？java中的线程安全是什么： 就是线程同步的意思，就是当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问 什么叫线程安全： 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。 看过vector源码的同学就会知道他的许多操作都是加了synchronized修饰的比如他的添加元素。 而HashMap的所有操作都没有加synchronized修饰 HashMap和hashtable的区别？（1）HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。 HashMap存数据的过程是： HashMap内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。 HashMap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。 Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。 Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。 区别：hashtable是线程安全的，hashMap是非线程安全的集合类 Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。 HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 3.Java继承中子类父类函数的调用问题？在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。 4. 类和对象的区别** **？****请说明类和对象的区别****类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。 对象是具有类类型的变量。类和对象是面向对象编程技术中的最基本的概念。 类是一个静态的概念，类本身不携带任何数据。当没有为类创建任何数据时，类本身不存在于内存空间 对象是一个动e68a847a6431333366306464态的概念，每一个对象都存在着有别于其它对象的属于自己的独特的属性和行为，属性可以随着它自己的行为而发生改变。 5. Overload和Override的区别。Overloaded的方法是否可…\\请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?** Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。 6. 用两个栈实现队列****？****用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。12345678910111213141516171819202122232425262728293031323334353637package niu;import java.util.Stack;public class doubleStack &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //先写入栈函数，如果想往栈中放入什么函数，直接调用放入函数就可以了 public void push(int a)&#123; stack1.push(a); &#125; //写出栈函数，因为是两个栈，所以入栈stack1之后，如果要出栈，就需要借助stack2, //先把数值从stack1中出栈放入stack2中 int result =0; int temp = 0; public int pop()&#123; if (!stack2.empty()) &#123; result = stack2.pop(); &#125;else &#123; //如果栈2为空，就需要把数据一个一个取出来先放入栈2中 while(!stack1.empty())&#123; temp = stack1.pop(); stack2.push(temp); &#125; //重新取出栈2中的值 if (!stack2.empty()) &#123; result = stack2.pop(); &#125; &#125; return result; &#125;&#125; # 7. 介绍一下volatile？请你介绍一下volatile？volatile作为java中的关键词之一，用以声明变量的值可能随时会别的线程修改，使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。volatile会禁止指令重排 volatile具有可见性、有序性，不具备原子性。 注意，volatile不具备原子性，这是volatile与java中的synchronized、java.util.concurrent.locks.Lock最大的功能差异 8. 编程题栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 9. GCRoot可以是哪些** **请问GC Root可以是哪些？GcRoot是垃圾回收器算法中判断一个对象是否可以回收的一种算法。 就是对象到达GcRoot的路径是否还有可达，即是否有可引用链，如果有，这表明对象还存在着引用，如果没有，则表明该对象没有引用，在下一次垃圾回收时就会被回收 GcRoot的种类 （1）虚拟机栈：栈帧中的本地变量表引用的对象 （2）native方法引用的对象 （3）方法区中的静态变量和常量引用的对象 10. 编程题：****二叉树的深度****？****输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。123456789101112131415161718public int TreeDepth(TreeNode root)&#123; if(root == null) return 0; int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); int result = 1+((leftDepth&gt;rightDepth)?leftDepth:rightDepth); return result; &#125; 11. springIOC原理？自己实现IOC要怎么做，哪些步骤？\\请说明一下springIOC原理是什么？如果你要实现IOC需要怎么做？请简单描述一下实现步骤？** 12. JDK和JRE有什么区别？JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 JRE,是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。 JVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。 13. . ==和equels有什么区别？equals源自于Object类，Object中equals方法默认比较的内容还是==比较的结果。 如果没有重写equals的话，equals和==是一样的。都是比较内存地址。 14. 说说final在java中的作用？final关键字可以用来修饰引用、方法、和类。 （1）如果修饰的引用为基本数据类型，则该引用为常量，该值无法修改 （2）如果修饰的引用为引用数据类型，比如对象、数组、则该对象、数组本身可以修改，但是指向该对象或者数组的地址的引用不能修改。 （3）如果引用是类的成员变量，则必须当场赋值，否则编译会报错。 当用final修饰一个方法的时候，当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。 当使用final修饰一个类的时候，当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。 15.String类的常用方法有哪些?（1）equals：字符串是否相同 （2）indexof：目标字符或者是目标字符串在源字符串中的位置下标 （3）valueOf：其他类型转字符串 （4）isEmpty：字符串的长度是否为零 （5）contains：是否包含目标字符串 16. java中操作字符串的类有哪些？他们之间有什么区别？（1）String （2）StringBuilder （3）StringBuffer 从类的继承关系上来开的话,String和StringBuffer,StringBuilder是没有任何关系的,但是StringBuffer和StringBuilder的继承关系时一样的。 java中操作字符串的类,我知道的有三个类,分别是String,StringBuffer和StringBuilder.这三个类都是以char[]的形式保存的字符串,但是String类型的字符串是不可变的,对String类型的字符床做修改操作都是相当于重新创建对象.而对StringBuffer和StringBuilder进行增删操作都是对同一个对象做操作.StringBuffer中的方法大部分都使用synchronized关键字修饰,所以StringBuffer是线程安全的,StringBuilder中的方法则没有,线程不安全,但是StringBuilder因为没有使用使用synchronized关键字修饰,所以性能更高,在单线程环境下我会选择使用StringBuilder,多线程环境下使用StringBuffer.如果生命的这个字符串几乎不做修改操作,那么我就直接使用String,因为不调用new关键字声明String类型的变量的话它不会在堆内存中创建对象,直接指向String的常量池,并且可以复用.效率更高 17. 如何将字符串反转？使用StringBuffer或者StringBuilder中的reverse()方法。 18. . 普通类和抽象类有什么区别？（1）抽象类不能被实例化 （2）抽象类可以有抽象方法，抽象方法只需申明，无需实现 （3）含有抽象方法的类必须申明为抽象类 （4）抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类 （5）抽象方法不能被声明为静态 （6）抽象方法不能用 private 修饰 （7）抽象方法不能用 final 修饰 19. 接口和抽象类有什么区别？他们都不能实例化对象，都可以包含抽象方法，而且抽象方法必须被继承的类全部实现。 区别： 1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 2、抽象类要被子类继承，接口要被类实现。 3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果 7、抽象类里可以没有抽象方法 8、如果一个类里有抽象方法，那么这个类只能是抽象类 9、抽象方法要被实现，所以不能是静态的，也不能是私有的。 10、接口可继承接口，并可多继承接口，但类只能单根继承。 20. java中的IO流分为几种？java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 21. List Set Map 之间有什么区别？List和set是实现了collection接口的 List： 1.可以允许重复的对象。 2.可以插入多个null元素。 3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。 4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。 Set： 1.不允许重复对象 无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。 只允许一个 null 元素 Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。 Map： Map不是collection的子接口或者实现类。Map是一个接口。 Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。 TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。 Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。 5.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用） 什么场景下使用list，set，map呢？（为什么这里要用list、或者set、map，这里回答它们的优缺点就可以了） （1）如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。 （2）如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。 （3）如果你想保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。 （4）如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。 1.JDK和JRE有什么区别？JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 JRE,是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。与大家熟知的JDK不同，JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。 JVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。 ==和equels有什么区别？****equals源自于Object类，Object中equals方法默认比较的内容还是==比较的结果。 如果没有重写equals的话，equals和==是一样的。都是比较内存地址。 说说final在java中的作用？final关键字可以用来修饰引用、方法、和类。 （1）如果修饰的引用为基本数据类型，则该引用为常量，该值无法修改 （2）如果修饰的引用为引用数据类型，比如对象、数组、则该对象、数组本身可以修改，但是指向该对象或者数组的地址的引用不能修改。 （3）如果引用是类的成员变量，则必须当场赋值，否则编译会报错。 当用final修饰一个方法的时候，当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。 当使用final修饰一个类的时候，当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。 4. String类的常用方法有哪些? （1）equals：字符串是否相同 （2）indexof：目标字符或者是目标字符串在源字符串中的位置下标 （3）valueOf：其他类型转字符串 （4）isEmpty：字符串的长度是否为零 （5）contains：是否包含目标字符串 5. java中操作字符串的类有哪些？他们之间有什么区别？（1）String （2）StringBuilder （3）StringBuffer 从类的继承关系上来开的话,String和StringBuffer,StringBuilder是没有任何关系的,但是StringBuffer和StringBuilder的继承关系时一样的。 java中操作字符串的类,我知道的有三个类,分别是String,StringBuffer和StringBuilder.这三个类都是以char[]的形式保存的字符串,但是String类型的字符串是不可变的,对String类型的字符床做修改操作都是相当于重新创建对象.而对StringBuffer和StringBuilder进行增删操作都是对同一个对象做操作.StringBuffer中的方法大部分都使用synchronized关键字修饰,所以StringBuffer是线程安全的,StringBuilder中的方法则没有,线程不安全,但是StringBuilder因为没有使用使用synchronized关键字修饰,所以性能更高,在单线程环境下我会选择使用StringBuilder,多线程环境下使用StringBuffer.如果生命的这个字符串几乎不做修改操作,那么我就直接使用String,因为不调用new关键字声明String类型的变量的话它不会在堆内存中创建对象,直接指向String的常量池,并且可以复用.效率更高 6. 如何将字符串反转？使用StringBuffer或者StringBuilder中的reverse()方法。 7. 普通类和抽象类有什么区别？（1）抽象类不能被实例化 （2）抽象类可以有抽象方法，抽象方法只需申明，无需实现 （3）含有抽象方法的类必须申明为抽象类 （4）抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类 （5）抽象方法不能被声明为静态 （6）抽象方法不能用 private 修饰 （7）抽象方法不能用 final 修饰 8. 接口和抽象类有什么区别？9. java中的IO流分为几种？10. List Set Map 之间有什么区别？11. java有8种基本类型，请问byte、int、long、char、float、double、boolean各占多少个字节？\\byte：8位 一个字节 int：32位 四个字节 long：64位 八个字节 char：16位 两个字节 float:32位 四个字节 double：64位 八个字节 boolean：8位 一个字节 12. 下面哪个不属于HttpServletResponse接口完成的功能？HttpServletResponse完成：设置http头标，设置cookie，设置返回数据类型，输出返回数据；读取路径信息是HttpServletRequest做的 HttpServletResponse 在Servlet中，当服务器响应客户端的一个请求时，就要用到HttpServletResponse接口。 设置响应的类型可以使用setContentType()方法。发送字符数据，可以使用getWriter()返回一个对象。下表是接口HttpServletResponse的常用方法。 接口HttpServletResponse的常用方法 方 法 说 明 addCookie(Cookie cookie) 将指定的Cookie加入到当前的响应中 addHeader(String name,String value) 将指定的名字和值加入到响应的头信息中 containsHeader(String name) 返回一个布尔值，判断响应的头部是否被设置 encodeURL(String url) 编码指定的URL sendError(int sc) 使用指定状态码发送一个错误到客户端 sendRedirect(String location) 发送一个临时的响应到客户端 setDateHeader(String name,long date) 将给出的名字和日期设置响应的头部 setHeader(String name,String value) 将给出的名字和值设置响应的头部 setStatus(int sc) 给当前响应设置状态码","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"mybatis整理","slug":"mybatis","date":"2020-06-09T12:26:32.000Z","updated":"2021-05-16T11:04:06.710Z","comments":true,"path":"2020/06/09/mybatis/","link":"","permalink":"http://yoursite.com/2020/06/09/mybatis/","excerpt":"1. mybatis的入门mybatis的环境搭建 ​ 第一步：创建maven工程并导入坐标 ​ 第二步：创建实体类和dao的接口 ​ 第三步：创建Mybatis的主配置文件sqlMapConfig.xml ​ 第四步：创建映射配置文件 IUseDao.xml","text":"1. mybatis的入门mybatis的环境搭建 ​ 第一步：创建maven工程并导入坐标 ​ 第二步：创建实体类和dao的接口 ​ 第三步：创建Mybatis的主配置文件sqlMapConfig.xml ​ 第四步：创建映射配置文件 IUseDao.xml mybatis的文件约束 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; mybatis的配置文件 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--Mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置MySQL的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源，连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射数据源文件的位置--&gt; &lt;mappers&gt; &lt;mapper resource=\"config/userDao/userDao.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 我们编写IUserDao的接口 12345import java.util.List;public interface IUserDao &#123; List&lt;User&gt; findAll();&#125; 编写User的实体类，注意实体类中的属性名称要和数据库中的相同 编写映射器 映射的约束文件 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"lei.study.dao.IUserDao\"&gt; &lt;select id=\"findAll\" resultType=\"lei.study.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写测试类 12345678910111213141516171819202122232425262728293031323334import lei.study.dao.IUserDao;import lei.study.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class testDemo &#123; public static void main(String[] args) throws Exception &#123; //加载配置文件 InputStream is = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); //2.创建SqlSessionFactry工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory sessionFactory = builder.build(is); //3. 使用工厂生产SQLSSession对象 SqlSession sqlSession = sessionFactory.openSession(); //4. 使用sqlsession创建Dao接口的代理对象 IUserDao userDao = sqlSession.getMapper(IUserDao.class); List&lt;User&gt; users = userDao.findAll(); for (User user: users ) &#123; System.out.println(user); &#125; sqlSession.close(); is.close(); &#125;&#125; 分析上面的代码，我们发现 创建工厂的时候，我们使用了建造者模式 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory sessionFactory = builder.build(is); 我们只需要往建造者中传入字节流就可以 构建者模式：把对象的创建细节隐藏，使使用者直接调用方法即可以拿到对象 生产sqlsession使用了工厂模式（解耦） SqlSession sqlSession = sessionFactory.openSession(); 代理模式 //4. 使用sqlsession创建Dao接口的代理对象 IUserDao userDao = sqlSession.getMapper(IUserDao.class);优势：就是在不改变源码的基础上对原有方法增强 除了使用上面的xml文件形式的配置，我们还可以使用注解的方式完成数据库的查询操作 使用注解： 我们需要在接口中的方法上使用@Select() 注解，指定SQL语句，同时需要在sqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名 在主配置文件中指定接口全限定类名 1234&lt;!--指使用注解的方式--&gt;&lt;mappers&gt; &lt;mapper class=\"lei.study.dao.IUserDao\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 在接口中 1234public interface IUserDao &#123; @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; 注意：我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式，不管使用XML还是注解配置，但是mybatis它是支持写dao实现类的。 2. 自定义mybatis框架分析通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照 mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得 更为简单，只需要编写一个 mybatis 配置文件就够了。） 但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还 要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。 这些问题我们在自定义 mybatis 框架进行讲解。 请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解 mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有 一个认识。 mybatis中的连接池 连接池，我们在实际开发中都会使用连接池，因为它可以减少我们开发的时间。 mybatis中的连接池 ： ​ mybatis连接池提供了3中方式的配置 ： ​ 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式 ​ type属性 的取值： ​ POOLED：采用传统的javac.sql.DataSource规范中的连接池，mybatis中有针对规范的实现 ​ UNPOOLED：采用传统的获取连接的方式，虽然也实现了javax.sql.DataSource接口，但是并没有使用池的思想 ​ JNDI：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到的DataSource是不一样的。 ​ 注意：如果不是web或者maven的war工程，是不能使用的，我们使用的是Tomcat服务器，采用的连接池就是dbcp连接池 ​ mybatis中的事务什么是事务 事务的四大特性 不考虑隔离性会产生的3个问题 解决办法：四种隔离级别 mybatis中是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚 mybatis中的多表查询一对一的查询操作 我们使用user表和account表关联 在account表中新建主表属性 private User user 12345private int id; private int uid; private Double money; private User user; 在account的配置文件中，我们编写映射文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"lei.study.dao.IAccountDao\"&gt; &lt;resultMap id=\"accountMap\" type=\"lei.study.domain.Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"lei.study.domain.User\"&gt; &lt;id property=\"userId\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"userName\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userBirthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"userSex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" column=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findAllAccount\" resultMap=\"accountMap\"&gt; SELECT u.*,a.id AS aid,a.uid, a.money from account a, user u WHERE u.id = a.id &lt;/select&gt;&lt;/mapper&gt; 一对多的关系 一个用户可能关联多张账户表 在User实体中，新建Account属性集合 1234567private int userId;private String userName;private Date userBirthday;private String userSex;private String userAddress;private List&lt;Account&gt; accounts; UserDao的映射文件中 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"lei.study.dao.IUserDao\"&gt; &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt; &lt;resultMap id=\"userAccountMap\" type=\"lei.study.domain.User\"&gt; &lt;id property=\"userId\" column=\"id\"&gt;&lt;/id&gt; &lt;!--非主键字段的对应--&gt; &lt;result property=\"userName\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userBirthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"userSex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" column=\"address\"&gt;&lt;/result&gt; &lt;collection property=\"accounts\" ofType=\"lei.study.domain.Account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userAccountMap\"&gt; SELECT * FROM user u LEFT OUTER JOIN account a on u.id = a.uid; &lt;/select&gt; 多对多的关系​ 用户可以有多个角色 ​ 一个角色可以赋予多个用户 ​ 用户和角色之间是多对多 1. mybatis中的延迟加载什么是延迟加载？ 问题：在一对多中，当我们有一个用户，它有100个账户 ​ 在查询用户的时候，要不要把关联的账户查出来 ​ 在查询账户的时候，要不要把关联的用户查出来？ ​ ​ 在查询用户时，用户下的账户信息是什么时候使用，什么时候查询的 ​ 在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。 什么是延迟加载：在真正使用数据时才发起查询，不用的时候不用查询，，按需加载（懒加载） 什么是立即加载？：不管用不用，只要一调用方法，马上发起查询 在对应的四种表关系中：一对一，多对一，一对一，多对多 一对多，多对多：通常情况下我们都是采用延迟加载 多对一，一对一：通常情况下，我们都是采用立即加载 我们可以在mybatis全部配置中或者是每个映射器中配置相关的属性信息，然后进行配置。 2. mybatis中的缓存什么是缓存？ ​ 存在于内存中的临时数据 为什么使用缓存 ​ 减少和数据库的交互次数，提高执行效率 什么样的数据使用缓存，什么样的数据不能使用 ​ 适用于缓存： ​ 经常查询，并且不经常改变的 ​ 数据的正确与否对最终结果影响不大的 ​ 不适用与缓存： ​ 经常改变的数据 ​ 数据的正确与否对最终的结果影响很大的 mybatis中一级缓存和二级缓存 一级缓存： ​ 它指的是Mybatis中Sqlsession对象的缓存 ​ 当我们执行查询之后，查询的结果会同时存入到Sqlsession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用。 ​ 当SqlSession对象消失的时候，mybatis的一级缓存也就消失了。 一级缓存是sqlsession范围的缓存，当调用sqlsession的修改，添加，删除，commit（） close()等方法时，就会清空一级缓存。 二级缓存： ​ 它指的是mybatis中的sqlsessionFacory对象的缓存，由同一个sqlsessFactory对象创建的SqlSession共享其缓存。 ​ 二级缓存的使用步骤： ​ 第一步：让Mybatis框架支持二级缓存，（在SQlMapConfig.xml中配置） ​ 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） ​ 第三步：让当前的操作支持二级缓存（在select标签中进行相关类的配置）","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试，阿里","slug":"面试，阿里","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"}]},{"title":"spring整理","slug":"spring","date":"2020-06-09T12:26:32.000Z","updated":"2021-05-16T11:04:06.711Z","comments":true,"path":"2020/06/09/spring/","link":"","permalink":"http://yoursite.com/2020/06/09/spring/","excerpt":"1. spring两个核心容器对象的区别 ApplicationContext 它在构建核心容器的时候，采用的创建对象的策略是立即加载的方式，也就是说，只要一读取配置文件马上就创建配置文件中配置的对象、","text":"1. spring两个核心容器对象的区别 ApplicationContext 它在构建核心容器的时候，采用的创建对象的策略是立即加载的方式，也就是说，只要一读取配置文件马上就创建配置文件中配置的对象、 BeanFactory 它在构建核心容器时，创建对象采用的策略是采用延迟加载的方式，也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。 2. spring对bean的管理细节创建bean的三种方式 第一种方式，使用默认构造函数创建 在spring的配置文件中使用bean标签，配以id 和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此类如果类中没有默认构造函数，则对象无法创建 12&lt;!--这是第一种方式，直接使用默认构造函数的方式进行创建--&gt; &lt;!--&lt;bean id=\"userService\" class=\"lei.study.service.impl.userServiceImpl\"&gt; 使用普通工厂中的方法创建对象，（使用某个类中的方法创建对象，并存入spring容器中 ） 创建需要实例化的工厂类 123public IUserService getUserServiceInstance()&#123; return new userServiceImpl(); &#125; spring 容器中进行配置 12&lt;bean id=\"factoryInstance\" class=\"lei.study.factory.factoryInstance\"&gt;&lt;/bean&gt; &lt;bean id=\"userService\" factory-bean=\"factoryInstance\" factory-method=\"getUserServiceInstance\"&gt;&lt;/bean&gt; （工厂中有可能是一个普通方法还可能是一个静态方法，这是时候使用）使用工厂中的静态方法创建对象，使用某个类中的静态方法创建对象，并存入spring容器中 静态方法中需要创建对象 12345public class factoryStaticInstance &#123; public static IUserService getUserServiceInstance()&#123; return new userServiceImpl(); &#125;&#125; 12&lt;!--刚才的第二种创建中，可能不是一个普通类，而是一个静态的类--&gt; &lt;bean id=\"userService\" class=\"lei.study.factory.factoryStaticInstance\" factory-method=\"getUserServiceInstance\"&gt;&lt;/bean&gt; 3. bean对象的作用范围&lt;bean标签的作用范围 bean标签的scope属性： 作用：用于指定bean的作用范围 取值：（常用的就是singleton和protopyte） singleton：为默认值，是单例的 protopyte： 多例的 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境是作用就是session 4. bean的生命周期当创建对象配置bean标签中的内容的时候，我们 可以指定bean的生命周期，当配置的是单例模式的时候，我们使ApplicationContext创建容器的时候，对象就创建了，当我们关闭对象的时候，对象销毁。 当配置的是单例模式的时候，我们使BeanFactory创建容器的时候，对象不会创建，只有当我们使用的时候，才会创建对象，，什么时候对象销毁呢，针对多例模式，spring容器不提供销毁对象的方法，把对象的销毁交给java的垃圾回收机制进行回收。 单例对象： 出生：当容器创建时，对象出生 活着：当容器还在，对象一直活着 死亡：当容器销毁，对象消亡 总结：单例对象的声明周期和容器相同 多例对象： 出生：当我们使用对象时，spring对象为我们创建 活着：对象只要是在使用过程中，就一直活着 死亡：当对象长时间不用，且没有别的对象引用时，由java的垃圾回收器进行回收 5. spring的依赖注入IOC的作用，就是降低程序间的耦合关系，也叫做依赖关系 依赖关系的管理：以后都交给spring来进行维护 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中进行说明。 依赖关系的维护就称之为依赖注入 依赖注入： 能注入的数据，有三类 （1） 基本类型和string （2）其他bean类型（在配置文件中或者是注解中配置过的bean） （3）其他类型/集合类型 依赖注入的方式有三种： （1）第一种：使用构造函数提供 （2）第二种：使用set方法提供 （3）第三种：使用注解 提供 1. 使用构造函数提供注入构造函数注入，需要在bean标签内，使用constructor-arg标签，标签出现的位置是bean标签的内部，、 标签中的属性： ​ type：用户指定要注入的数据的数据类型，该数据类型也是构造函数中某个或者是某些参数的类型 ​ index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置是从0开始的 ​ name：用于指定给构造函数中指定名称的参数赋值 =============最常用的是使用name的方式，给指定的参数进行赋值，=============以上三种都是用于指定给构造函数找那个的那个参数进行赋值 ​ value：用户提供基本类型和string类型的数据 ​ ref： 用于指定其他的bean类型，指的就是在spring的IOC核心容器中，出现过的bean对象。 构造函数的特点与优势： ​ 在获取bean对象时，注入数据是必须的操作，否则对象是无法创建成功的。当我们使用的某个类的时候，就想使用某些数据的时候，我们就可以使用构造函数注入的方式，使用这种方式更简单。 弊端： ​ 改变了bean对象的实例化方式，使我们在创建对象的时候，如果用不到这些数据，也必须提供。当我们在开发中除非非要采用这种方式进行创建，一般的时候我们是不使用的。 例如： 我们在userServiceImpl中写生需要注入的对象 12345678910111213141516public class userServiceImpl implements IUserService &#123; private String name; private Integer age; private Date brithday; public userServiceImpl(String name, Integer age, Date brithday) &#123; this.name = name; this.age = age; this.brithday = brithday; &#125; public void saveUser() &#123; System.out.println(\"userServiceImpl中的save方法执行了\"+name+\",\"+age+\",\"+brithday); &#125;&#125; 然后在spring的配置文件中，进行依赖的注入 1234567&lt;!--依赖注入的方式--&gt;&lt;bean id=\"userService2\" class=\"lei.study.service.impl.userServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"第一个\"/&gt; &lt;constructor-arg name=\"age\" value=\"19\"/&gt; &lt;constructor-arg name=\"brithday\" ref=\"dataNow\"/&gt;&lt;/bean&gt;&lt;bean id=\"dataNow\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 编写测试代码 123456public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); System.out.println(ac); IUserService userService = (IUserService) ac.getBean(\"userService2\"); userService.saveUser();&#125; 执行结果： userServiceImpl中的save方法执行了第一个,19,Sun May 17 15:23:41 CST 2020 说明注入成功 引入： 在进行spring配置文件的编写的时候，需要在配置文件中引入约束，spring容器中相对完整的约束如下： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \" default-autowire=\"byName\"&gt; 2. set方法注入(经常使用的方式)set方式注入，设计的标签：property 出现的位置，bean标签的内部 标签的属性： ​ name：用于指定注入时所调用的set方法名称 ​ value：用户提供基本类型和string类型的数据 ​ ref： 用于指定其他的bean类型，指的就是在spring的IOC核心容器中，出现过的bean对象。 set注入的优点： ​ 创建的对象的时候没有明确的限制，可以直接使用默认构造函数，然后通过property 找到对应的set方法名称，进行一些取值的注入即可 set注入的缺点： ​ 如果有某个成员必须有值，则获取对象时，有可能set方法没有执行。 例如： 123456789101112131415161718192021222324252627public class userServiceImpl implements IUserService &#123; private String name; private Integer age; private Date brithday; /** * setter方式注入的方式 */ public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBrithday(Date brithday) &#123; this.brithday = brithday; &#125; public void saveUser() &#123; System.out.println(\"userServiceImpl中的save方法执行了\"+name+\",\"+age+\",\"+brithday); &#125;&#125; 在spring中的配置文件中 123456&lt;!--setter方式注入的方式--&gt;&lt;bean id=\"userService3\" class=\"lei.study.service.impl.userServiceImpl\"&gt; &lt;property name=\"name\" value=\"哈哈哈\"/&gt; &lt;property name=\"age\" value=\"18\"/&gt; &lt;property name=\"brithday\" ref=\"dataNow\"/&gt;&lt;/bean&gt; 在测试文件中 123456public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); System.out.println(ac); IUserService userService = (IUserService) ac.getBean(\"userService3\"); userService.saveUser();&#125; 使用set注入 复杂数据类型/集合类型的数据结构用于给List结构集合注入的标签有：list array set 用户给Map结构集合注入的标签：map props 注意：结构相同，可以互换 =========================================================Spring基于注解的IOC以及IOC的案例注意： 在本节中我们学习使用注解进行依赖的主注入，在上面的案例中，我们使用的是配置文件的方式进行配置的。 我们学习了——— 用于创建对象 用于注入数据 用于改变作用范围的 和生命周期相关 等等相关的配置 当我们使用注解之后， 用户创建对象的注解：他们的作用就和在XML配置文件中，编写一个&lt;bean 标签实现的功能是一样的 用于注入数据的：他们的作用就和在xml配置文件中的bean 标签中写一个property标签的作用是一样的 用于改变作用范围的：他们的作用就和在bean标签中使用scope属性实现的功能是一样的 和生命周期相关：他们的作用就和在bean标签中使用 init-method 和destory-method的作用是一样的 (1) 创建对象的注解： ① @Component 作用在类上 作用：就是把当前类对象存入spring容器中 属性：value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母小写 注意：使用这个注解之前，我们需要在spring的配置文件中，加上一个说明，告知spring在创建容器的时候，需要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为context名称空间和约束中 12&lt;!--告诉spring容器需要扫描的包--&gt; &lt;context:component-scan base-package=\"lei.study\"/&gt; 1234567@Component(value = \"haha\")public class userServiceImpl2 implements IUserService &#123; public void saveUser() &#123; System.out.println(\"userServiceImpl中的save方法执行了\"); &#125;&#125; 测试 12345public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); IUserService userService = (IUserService) ac.getBean(\"haha\"); userService.saveUser();&#125; ② @ Controller @Service @Repository 三个注解 以上三个注解他们的作用和属性与Component是一模一样的。他们三个是spring框架，为我们明确提供的三层对象使用的注解，使三层对象更加清晰 @ Controller 一般使用在表现层 @Service 一般使用的service层 @Repository 一般使用在持久层 （2）注入数据的注解 @Autowired : 出现位置：可以使变量上，也可以是方法上 细节：在使用注解注入数据的时候，set方法就不是必须的了 作用就是，自动按照类型注入（例如 @Autowired 在这上面注解 private IUserDao userDao = null，那么就会按照IUserDao 类型 ，去spring容器中进行寻找对象取值），只要容器中有唯一的一个bean 对象类型和要注入的变量类型匹配，就可以注入成功。如果IoC容器中没有任何bean的类型和要注入的变量类型匹配，则报错。 如果有多个类型相互匹配的时候，就会自动按照名称(userDao 这个名称)进行找对象bean对象，如果名称不一致或者是不存在，就会报错。 例如我们定义了两个userDaoImpl方法实现了同一个接口，并在每一个方法上面使用@Component注解生成对象到容器中 第一个 123456@Component(value = \"userDao1\")public class userDaoImpl implements IUserDao &#123; public void saveUser() &#123; System.out.println(\"saveUser1方法执行了,保存了用户1111111\"); &#125;&#125; 第二个 123456@Component(value = \"userDao2\")public class userDaoImpl2 implements IUserDao &#123; public void saveUser() &#123; System.out.println(\"saveUser1方法执行了,保存了用户222222\"); &#125;&#125; ，当我们在service层取值调用bean的时候 12345@Autowired private IUserDao userDao; public void saveUser() &#123; userDao.saveUser(); &#125; 这个时候按照类型IUserDao寻找bean的时候就会找到两个bean（因为@Autowired是按照类型进行寻找的），程序会报错，这个时候我们就可以和@Qualifer注解进行配合使用 这个时候出现了@Qualifer注解 @Qualifer 作用：在按照类中注入的基础之上再按照名称进行注入，它在给类成员注入时不能单独使用，但是在给方法参数注入时可以单独使用。 属性：value 用于指定注入bean的id 例如： 123456@Autowired@Qualifier(value = \"userDao2\")private IUserDao userDao;public void saveUser() &#123; userDao.saveUser();&#125; 还有一个注解： @Resource @Recource 作用是，直接按照bean的id注入，它可以独立使用 属性：name ：用于指定bean的id 12345@Resource(name = \"userDao2\") private IUserDao userDao; public void saveUser() &#123; userDao.saveUser(); &#125; 需要注意的是：以上三种注解都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。另外，集合类型的注入只能通过XML来实现。 @Value注解 作用：用于注入基本类型和String类型的数据 属性：value—用于指定数据的值，它可以使用spring中的spEl（也就是spring中的EL表达式） ​ spEl的写法 ： ${表达式} （3）用于改变作用范围的注解 他们的作用就和在bean标签中使用scope属性实现的功能是一样的 Scope：作用—用于指定bean的作用范围 属性：value：指定范围的取值，常用取值 single prototype 分别对应单例和多例 （4）和生命周期相关的注解 他们的作用就和在bean标签中使用init-method和destory-method的作用是一样的 @PreDestory 作用：用于指定销毁方法 @PostConstruct 作用：用于指定初始化方法 ==================================================Spring的新注解@Configuration 作用》：指定当前类是一个配置类 ​ 细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写 @ComponentScan ​ 作用》：用于通过注解指定spring在创建容器时要扫描的包 ​ 属性： value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包，我们使用这个注解就相当于在spring的配置文件xml中使用了 &lt;context:component-scan base-package=”lei.study”/&gt; 进行了一个包扫描的作用 @Bean注解 ​ 作用》：用于把当前方法的返回值作为bean对象存入spring的Ioc容器中 ​ 属性： name 用于指定bean的id，当不写时，默认值是当前方法的名称 ​ 细节：当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象 ​ 查找的方式和Autowired注解的作用是一样的 @Import 作用》：用于导入其他的配置类 ​ 属性：value 用于指定其他配置类的字节码 ​ 当我们使用Import的注解之后，有Import注解的类是父配置类，而导入的都是子配置类 @PropertySource ​ 作用：用于指定properties文件的位置 ​ 关键字 ： classpath 表示类路径下 ==========================================Spring中的AOP配置spring中基于XML的AOP配置步骤： 把通知Bean也交给spring容器来进行管理 使用aop:config标签表明开始AOP的配置 使用aop：aspect标签表明配置切面 ​ id属性：是给切面提供一个唯一标识 ​ ref属性：是指定通知类bean的id 在aop：aspect标签的内部使用对应标签来配置通知的类型 ​ 我们现在是让我们定义的切面方法在切入点方法执行之前执行，所以是前置通知 ​ aop：before：表示配置前置通知 ​ method属性：用于指定Logger类中哪个方法是前置通知 ​ pointcut属性：用于指定切入点表达式，改表达式的含义指的是对业务层中哪些方法进行增强 ​ 切入点表达式的写法： ​ 关键字：execution（表达式） ​ 表达式： ​ 访问修饰符 返回值 包名.包名.包名…..类名.方法名（参数列表） ​ 标准的表达式写法 execution(public void lei.study.service.impl.userServiceImpl.saveUser() 例如我们建立一个切入方法，就是打印日志信息，建立一个日志类，然后写一些方法 例如： 12345678/** * 需要注入切入点的方法，也就是在切入点之前或者之后需要执行的方法 */public class Logger &#123; public void printLogger()&#123; System.out.println(\"打印日志的方法，开始打印日志。。。\"); &#125;&#125; 把上面的方法注入到userservice中 userServiceImpl.java 12345public class userServiceImpl implements IUserService &#123; public void saveUser() &#123; System.out.println(\"userServiceImpl保存用户的操作执行了\"); &#125;&#125; 我们想把日志信息注入到saveUser（）方法之前或者是之后执行，我们就可以在spring的配置文件中，进行AOP切面的一些配置，就可以使用AOP完成相关的切面编程 在spring的配置文件中： 12345678910&lt;bean id=\"userService\" class=\"lei.study.service.impl.userServiceImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"printLogger\" class=\"lei.study.utils.Logger\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"printLogger\"&gt; &lt;!--建立切入点方法的关联--&gt; &lt;aop:before method=\"printLogger\" pointcut=\"execution(public void lei.study.service.impl.userServiceImpl.saveUser())\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 在这里我们需要注意切入点表达式的写法 表达式： ​ 访问修饰符 返回值 包名.包名.包名…..类名.方法名（参数列表） ​ 标准的表达式写法 execution(public void lei.study.service.impl.userServiceImpl.saveUser() 全通配写法 ​ 表达式的全通配写法 12 表达式的全通配写法* *..*.*(..) 解释说明：在上面的方法中，我们只对userService类中一个saveUser（）方法进行了增强，如果我们需要使用这个日之类对所有的userService中的方法都需要增强，我们不需要一个一个方法的进行编写，只需要写一个表达式的全通配写法 表达式的全通配写法 注意： ​ 在标准写法中， 访问修饰符可以省略 ： public void lei.study.service.impl.userServiceImpl.saveUser() 中的public可以省略，写成 void lei.study.service.impl.userServiceImpl.saveUser() 返回值可以使用通配符：表示任意返回值类型 1* lei.study.service.impl.userServiceImpl.saveUser() 包名可以使用通配符：表示任意包。但是有几级包，就需要写几个* 1* *.*.*.*.userServiceImpl.saveUser() 包名可以使用..表示当前包及其子包： 1* *..userServiceImpl.saveUser() 包名和方法名都可以使用*来实现通配： 1* *..*.*() 参数列表： 可以直接写数据类型 ​ 基本类型直接写名称 int ​ 引用类型写包.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以使任意类型 全通配写法： 12 表达式的全通配写法* *..*.*(..) 实际开发中： ​ 实际开发中切入点表达式的通常写法： ​ 我们可以切到业务层实现类下的所有方法 1* lei.study.service.impl.*.*(..) 在上面的例子中我们可以使用如下的写法： 12345678910&lt;!-- 表达式的全通配写法 * *..*.*(..)--&gt;&lt;aop:config&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"printLogger\"&gt; &lt;!--建立切入点方法的关联--&gt; &lt;aop:before method=\"printLogger\" pointcut=\"execution(* *..*.*(..))\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型： 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法正常执行之后执行，也和异常通知永远只能执行一个 异常通知：在切入点方法执行产生异常之后执行，它和后置通知永远只能执行一个 最终通知：无论切入点方法是否正常执行它都会在其后面执行。 环绕通知：当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 切面的配置： 需要注入切入点的方法 12345678910111213141516public class Logger &#123; public void beforePrint()&#123; System.out.println(\"前置通知，打印日志的方法，开始打印日志。。。在切入点方法执行之前执行\"); &#125; public void afterPrint()&#123; System.out.println(\"后置通知，结束打印日志。。。\"); &#125; public void printThrow()&#123; System.out.println(\"切入点方式产生异常之后，执行的异常通知\"); &#125; public void afterLogger()&#123; System.out.println(\"这是最终通知， 无论切入点方法是否正常执行都会在切入点之后执行的方法\"); &#125;&#125; 1234567891011121314151617&lt;bean id=\"userService\" class=\"lei.study.service.impl.userServiceImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"printLogger\" class=\"lei.study.utils.Logger\"&gt;&lt;/bean&gt;&lt;!-- 表达式的全通配写法 * *..*.*(..)--&gt;&lt;aop:config&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"printLogger\"&gt; &lt;!--建立切入点方法的关联--&gt; &lt;aop:before method=\"beforePrint\" pointcut=\"execution(* lei.study.service.impl.*.*(..))\"/&gt; &lt;aop:after-returning method=\"afterPrint\" pointcut=\"execution(* lei.study.service.impl.*.*(..))\"/&gt; &lt;aop:after-throwing method=\"printThrow\" pointcut=\"execution(* lei.study.service.impl.*.*(..))\"/&gt; &lt;aop:after method=\"afterLogger\" pointcut=\"execution(* lei.study.service.impl.*.*(..))\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; spring中的事物控制spring基于XML的声明式事务控制在spring中我们不用再编写关于事务的一些操作方法，我们可以直接使用xml配置的方式，对数据库连接操作中的方法进行相关事务的配置。 1234567891011spring中基于XML的声明式事务控制配置步骤 1. 配置事务管理器 2. 配置事务的通知 此时我们需要导入事务的约束 tx的名称和约束 同时也需要aop的 使用 &lt;tx:advice&gt; 配置事务的通知 id :给事务通知起一个唯一标识 transtration-manager：给事务通知提供一个事务管理器引用 3，配置AOP中的通用切入点表达式 4. 建立事务通知和切入点表达式的对应关系 5. 配置事务的属性 是在事务的通知 tx:advice 标签的内部进行配置 在spring中配置事务管理器 DataSourceTransactionManager可以配置JDBC或者是ibatis关于事务的配置 HiberateTransactionManager 可以配置整合Hiberate中关于事务的配置 1234&lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; 配置事务的通知 （以及配置事务的属性） 在配置事务的通知中，我们需要配置事务的一些属性 1234567891011121314151617&lt;!--配置事务的通知--&gt; &lt;tx:advice id=\"txAdvicce\" transaction-manager=\"transactionManager\"&gt; &lt;!--配置事务的属性 isolation=\"\" 用于指定事务的隔离级别 默认值是default ，表示使用数据库的默认隔离级别 propagation=\"\" 用于指定事务的传播行为，默认值是REQUIRED 表示一定有事务，增删改的选择，查询方法可以选择SUPPORTS read-only=\"\" 用于指定事务是否只读，只有查询方法才能设置为true。默认值是false，表示读写 rollback-for=\"\" 用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚，没有默认值，表示任何异常都回滚 no-rollback-for=\"\" 用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常事务回滚，没有默认值，表示任何异常都回滚 timeout=\"\" 用于指定事务的超时时间，默认值是-1 表示永不超时，如果指定了数值，以秒为单位 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置事务的切入点表达式以及建立切入点表达式和事务通知的对应关系 1234567&lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution(* lei.study.service.impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系--&gt; &lt;aop:advisor advice-ref=\"txAdvicce\" pointcut-ref=\"pt1\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; spring基于注解的声明式事务控制","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试，阿里","slug":"面试，阿里","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"}]},{"title":"腾讯面试整理","slug":"腾讯面试整理","date":"2020-06-08T12:26:32.000Z","updated":"2021-05-17T02:06:45.707Z","comments":true,"path":"2020/06/08/腾讯面试整理/","link":"","permalink":"http://yoursite.com/2020/06/08/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/","excerpt":"java相关：","text":"java相关： JDK中哪一些是线程安全的集合类？是怎么保证安全的？早在jdk的1.1版本中，所有的集合都是线程安全的。但是在1.2以及之后的版本中就出现了一些线程不安全的集合，为什么版本升级会出现一些线程不安全的集合呢？因为线程不安全的集合普遍比线程安全的集合效率高的多。随着业务的发展，特别是在web应用中，为了提高用户体验减少用户的等待时间，页面响应速度(也就是效率)是优先考虑的。而且对线程不安全的集合加锁以后也能达到安全的效果（但是效率会低，因为会有锁的获取以及等待）。其实在jdk源码中相同效果的集合线程安全的比线程不安全的就多了一个同步机制，但是效率上却低了不止一点点，因为效率低，所以已经不太建议使用了。 Vector：就比Arraylist多了个同步化机制（线程安全）。 Hashtable：就比Hashmap多了个线程安全。 hashtable是线程安全的,即hashtable的方法都提供了同步机制；hashmap不是线程安全的,即不提供同步机制 ；hashtable不允许插入空值,hashmap允许! ConcurrentHashMap:是一种高效但是线程安全的集合。 Stack：栈，也是线程安全的，继承于Vector。 2.什么是线程安全？线程安全问题是由什么引起的？什么是死锁？线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 死锁产生有四个必要条件，打破任意一个，就能打破死锁状态: 1 互斥条件 2 请求与保持 3 不剥夺 4 循环等待 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。 循环等待条件:若干进程间形成首尾相接循环等待资源的关系。 3.你了解哪些数据结构？栈这种数据结构能应用在哪些场景中?举几个例子说明一下栈的实际应用场景？栈的特点是什么？栈这种结构的特点：栈只能从表的一端存取数据，另一端是封闭的。在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。 使用栈进行符号的逆序输出：栈最大的特点是先进后出，所以逆序输出是栈经常用到的一个应用场景。首先把所有元素依次入栈，然后把所有元素出栈并输出，这样就实现了逆序输出。 计算后缀表达式，碰见数字就入栈，碰见符号出栈运算运算。遇见数字就入栈，遇见符号就出栈，然后把结果再入栈 语法检测，匹配括号是否成对出现:凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错。 什么是中缀表达式？ ​ 中缀表达式利于人的理解，但不便于计算机的处理。因此需要将中缀表达式转换成后缀表达式，以方便计算机处理。所谓后缀表达式就是将运算符放在运算数之后。后缀表达式也称为逆波兰表达式。 5.hashMap这种数据结构，假如让你自己去实现一个hashMap这种数据结构你会怎么去设计实现？（hashMap就是散列表，同一种说法）主要还是考的是hash表的结构，哈希表综合了数组和链表的优点，是一种寻址容易而且插入也相对容易的数据结构，哈希表既满足了数据查找方便，同时还不占用太多的内存空间，使用十分方便，哈希表有多种不同的实现方法，我们可以使用一种最常用的实现方法—拉链法来实现哈希表，这个哈希表可以理解为链表的数组。 哈希表是由数组+链表组成的，在数组中每个元素存储的是一个链表的头结点，数据存储在链表中，那么是按照怎么样的规则来进行存储的呢?一般的情况下是通过hash（key）%len获得，也就是元素的key的哈希值对数组长度取模得到。 hashMap其实是一个线性的数组实现的，所有可以理解为其存储数据的容器就是一个线性数组。 6. 算法方面了解哪些算法？排序算法中，选择排序和冒泡排序算法的区别在哪里？排序算法的稳定性是指什么？选择排序和冒泡排序的时间复杂度是多少？选择排序：是一种最简单直观的排序算法，它的工作原理是每一次从待排序的数据元素中选出最小或者是最大的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完，选择排序是不稳定的排序方法。 冒泡排序：基本思想是将数组中的每个相邻元素进行两两比较，按照小元素在前（或大元素在前）的原则确定是否进行交换。这样每一轮执行之后，最大（或最小）的元素就会被交换到了最后一位。完成一轮之后，我们可以再从头进行第二轮的比较，直到倒数第二位（因为最后一位已经是被排序好的了）时结束。这样一轮之后，第二大（或第二小）的元素就会被交换到了倒数第二位。同样的过程会依次进行，直到所有元素都被排列成预期的顺序为止。 选择排序和冒泡排序算法的区别主要在于：两种排序比较的次数是相同的，但是交换的次数，选择排序是更少的，但是通常选择排序可能更快一点，冒泡排序是每一次都可能要交换，而选择排序是比较时记下a[i]的位置，最后用来交换的。交换过程是不一样的，但是查找过程是一样的。 时间复杂度： 冒泡排序时间复杂度： N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数 综上所述：冒泡排序总的平均时间复杂度为：O(n2) 选择排序时间复杂度： 选择排序空间复杂度也是O(1)，是一种原地排序算法。 它的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O（n^2）。 选择排序不是稳定的排序算法，因为它每次都要找出剩余未排序元素中的最小值，并和前面的元素交换位置，这样就破坏了稳定性。冒泡排序是一种稳定的排序算法。 7. 排序的稳定性是指什么？冒泡排序是稳定的排序算法，你这么证明，就是如果采用数据推导的方式去证明，你会如何证明是稳定的？稳定排序是指原来相等的两个元素前后相对位置在排序后依然不变。 即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的，否则称为不稳定的。 操作系统：在操作系统中，实现多进程间通信有哪些方式？信号量是什么? 能举几个具体的使用信号量的例子吗?进程和线程的关注点是不一样的，进程是资源分配的基本单位，进程间资源是独立的，关注的是进程通信问题，线程间资源是共享的，关注的是安全问题。 操作系统进程间通信的方式有哪些？ 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，进程的亲缘关系指的是父子进程关系。 消息队列（message queue）：消息队列是消息的链表，存在在内核中并由消息队列表示符标示，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限制等缺点。 共享内存：共享内存就是映射一段内被其它进程所访问的内存，共享内存是由一个进程创建，但是多个进程都可以访问，共享内存是最快的进程间通信方式，它是针对其它进程通信方式运行效率低而专门设计的，它往往与其它通信机制，如信号量配置使用，来实现进程间的同步和通信。 套接字（socket）：套接字也是进程间的通信机制，与其它通信机制不同的是，它可以用于不同机器间的进程通信。 信号：信号是一种比较复杂的通信方式，用于通知接受进程某个时间已经发生。 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁的机制，防止某进程正在访问共享资源时，其他进程也访问该资源，因此它主要作为不同进程或者同一进程之间不同线程之间同步的手段。 数据库：数据库的事务中，事务有原子性、一致性等等，他们都是什么？那么一致性是指什么？如果保证了原子性就一定能保证一致性吗？如果我的每个操作都是原子的那么是不是数据肯定能保证是一致的？不能保证，理由是什么？说出理由?原子性：事务是数据库的逻辑工作单位,事务中的操作要么全做，要么不做。 一致性：事务执行的结果必须是使数据库从一个一致性变到另一个一致性。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。 隔离性：一个事务的执行不能干扰其他事物。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。 持久性：一个事务一旦提交，他对数据库中的数据的改变应该是永久性的。接下来的其它操作或者故障不应该对其执行结果有任何影响。 原子性和一致性的关系是什么？在事务处理的ACID属性中，一致性是最基本的属性，其他的三个属性都为了保证一致性而存在的。原子性并不能保证一致性，在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。为了保证并发情况下的一致性引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好像其他并发事务并不存在一样，用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。怎么实现隔离性呢？可以通过锁机制，悲观锁和乐观锁。 10. MySQL中有哪些方式可以提高数据的查询速度或者是效率的？索引：索引是数据库中重要的数据结构，它的根本目的就是为了提高查询速度，对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 11.Hadoop的架构是怎么样的? Hadoop是怎么保证数据是一致的,是怎么保证数据完整性的？Hadoop由HDFS、MapReduce、Yarn(资源调度)、辅助工具（HBase、Hive和ZooKeeper等）成员组成，其中最基础最重要元素为底层用于存储集群中所有存储节点文件的文件系统HDFS（Hadoop Distributed File System）来执行MapReduce程序的MapReduce引擎。 12.你熟悉MapReduce框架吗？13.你现在在做哪些工作？是如何存储的？你的优点在哪里？如果我把不同来源的数据导入spark或者是hive中，是不是也可以呢？14. 网络方面。TCP和UDP的区别是什么？TCP为什么是安全的？三次握手是什么？三次握手之后，我再发如果断了，会怎么办？ 连接方面区别：TCP是面向连接的，发送数据之前需要建立连接，UDP是无连接的，即发送数据之前不需要建立连接。 安全方面的区别：TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复且按序到达，UDP尽最大努力交付，即不保证可靠交付。 传输效率的区别：TCP传输效率相对较低，UDP传输效率高，适用于对高速传输和实时性有较高要求的通信或者广播通信。 链接对象数量的区别：TCP链接只能是点到点，一对一的，UDP支持一对一、一对多、多对一和多对多的交互通信。 15. 什么是滑动窗口，滑动窗口是用来干什么的？滑动窗口本质上是描述接受方（本地）的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。 滑动窗口协议（Sliding Window Protocol）属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。 tcp采用滑动窗口机制来实现流量控制！ 16. 操作系统Linux有了解吗？怎么看正在使用CPU的一个线程命令是什么？Linux的常用命令？17. 你看过哪些开源的底层代码？你经常访问的开源的网站是什么？","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"springMVC","slug":"springMVC","date":"2020-06-07T12:28:32.000Z","updated":"2021-05-16T11:04:06.711Z","comments":true,"path":"2020/06/07/springMVC/","link":"","permalink":"http://yoursite.com/2020/06/07/springMVC/","excerpt":"springMVC框架时基于组件的方式执行流程","text":"springMVC框架时基于组件的方式执行流程 springMVC的执行流程：（1） 首先是浏览器发出请求，发送到web.xml文件中我们配置过的前端控制器DispatcherServlet响应用户请求，DispatcherServlet根据请求的模式决定是否去找对应的映射器，DispatcherServlet是整个流程控制的中心，由它调用其他组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。 （2）DispatcherServlet请求查找Handler，然后到达处理器映射器HandlerMapping，HandlerMapping让Controller类中的方法执行。springMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式 （3）我们在对应的Controller方法中执行完对应的逻辑之后，或者把数据封装进Model中之后返回。 在Controller中 @RequesMappding注解中的参数 ​ value：用于指定请求的URL，它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件，它支持简单的表达式。要么请求参数的key和value必须和配置的一模一样 ​ 例如： param ={“accountName”} 表示请求参数必须有accountName ​ param={“money！=100”} 表示请求参数money不能是100 ​ param={“money=100”} 表示请求参数money必须是100 ​ headers：用于指定限制请求消息头的条件 ​ 注意：以上四个属性只要出现2个或者以上时，他们的关系是与的关系 请求参数的绑定SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 要求：提交表单的name和参数的名称是相同的 支持的数据类型： （1） 基本数据类型和字符串类型 （2）实体类型 JavaBean （3）集合数据类型（List、Map集合等） 常用注解","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Struts2面试整理","slug":"Struts2面试整理","date":"2020-06-07T10:26:32.000Z","updated":"2021-05-16T11:04:06.710Z","comments":true,"path":"2020/06/07/Struts2面试整理/","link":"","permalink":"http://yoursite.com/2020/06/07/Struts2%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/","excerpt":"1. 什么是Struts2？Struts2是一个用Java构建Web应用程序的开源框架。Struts2基于OpenSymphony WebWork框架。它从Struts1中得到了很大的改进，使其更加灵活，易于使用和扩展。Struts2的核心组件是Action，Interceptors和Result页面。 Struts2提供了许多方法来创建Action类并通过struts.xml或注释来配置它们。我们可以为常见任务创建自己的拦截器。Struts2附带了很多标签，并使用OGNL表达式语言。我们可以创建自己的类型转换器来渲染结果页面。结果页面可以是JSP和FreeMarker模板。","text":"1. 什么是Struts2？Struts2是一个用Java构建Web应用程序的开源框架。Struts2基于OpenSymphony WebWork框架。它从Struts1中得到了很大的改进，使其更加灵活，易于使用和扩展。Struts2的核心组件是Action，Interceptors和Result页面。 Struts2提供了许多方法来创建Action类并通过struts.xml或注释来配置它们。我们可以为常见任务创建自己的拦截器。Struts2附带了很多标签，并使用OGNL表达式语言。我们可以创建自己的类型转换器来渲染结果页面。结果页面可以是JSP和FreeMarker模板。 2. Struts2的核心组件是什么？1、前端控制器 2、OGNL/ VS：OGNL/ ValueStack 3、Action：动作 4、Result：结果 5、Interceptor：拦截器 6、Tags：标签库 3. Struts2的工作流程（1）所有请求提交给前端控制器。 （2）根据配置信息确定要调用的 Action。 （3）创建一个 ValueStack 对象（每个请求都有一个独立的 VS 对象）。 （4）创建 Action 对象，把 Action 对象放到 VS 的栈顶，将 VS 对象存入到 request 中，存储的 key 为“ struts.valueStack”。 （5）控制器调用 Action 对象接收请求参数， 并在方法中根据输入属性算输出属性。 （6）在调用 Action 之前或之后调用一系列 Interceptor。 （7）根据 Action 返回的字符串确定 Result（ 10 种类型）。 （8）调用 Result 对象，将 VS 中的数据按照特定的格式输出。 （9）很多情况下， Result 将转发到 JSP， JSP 页面用 Tags 取出数据并显示。 （10）请求处理完后，将 ValueStack 对象和 Action 对象销毁。 4. OGNL技术1.什么是OGNL?OGNL是 Object-Graph Navigation Language（对象图形导航语言）的缩写，它是一种功能强大的表达式语言。是一种表达式语言。使用这种表达式语言，你可以通过某种表达式语法，存取Java对象树中的任意属性、调用Java对象树的方法、同时能够自动实现必要的类型转化。 OGNL简介： （1）OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个开源项目。 struts2框架默认就支持Ognl表达式语言（所以struts必须引用的包：ognl.jar）； （2）struts2的ognl的作用：页面取值使用； （3）OGNL和EL的区别: EL表达式语言:用于页面取值，jsp页面取值的标准（默认可以直接使用，应用范围更加广泛）； OGNL表达式语言：struts2标签默认支持的表达式语言，必须配置struts标签使用，不能离开struts2标签直接使用； （4）OGNL 有一个上下文（Context）概念,[OgnlContext对象：OgnlContext对象是ognl表达式语言的核心]; 其实上下文就是一个MAP结构，它实现了 java.utils.Map 的接口。 （5）ognl表达式语言取值，取根元素的值，不用带#符号；ognl表达式语言取值，取非根元素的值，需要带#符号； 6：ValueStack, 即值栈对象（根元素的值存储在root中，非根元素的值存储在context中）。 （1）：值栈对象是整个struts数据存储的核心，或者叫中转站。 （2）：用户每次访问struts的action，都会创建一个Action对象、值栈对象、ActionContext对象； 然后把Action对象放入值栈中； 最后再把值栈对象放入request中，传入jsp页面。 （3）：(key: struts.valueStack)； 开发者只需要通过ActionContext对象就可以访问struts的其他的关键对象。 （ActionContext是给开发者用的，便于学习与使用。） 2. Struts2标签的使用Struts2 的很多标记就是通过访问 ValueStack 获得数据的。使用前要在页面中要引入： &lt;%@taglib uri=”/struts-tags” prefix=”s”%&gt;， prefix：表示前缀 5. 什么是Struts2中的拦截器？它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用部分的方式。在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。Struts2内置了很多拦截器，每个拦截器完成相对独立的功能，多个拦截器的组合体成为拦截器栈。最为重要的拦截器栈是系统默认拦截器栈DefaultStack。struts2默认定义了35种拦截器，默认执行20种。 1）拦截器（Interceptor）是Struts2的核心组成部分，是XWork体系的重要组件。 2）Struts2很多功能都是构建在拦截器基础之上的，例如文件的上传下载、国际化、数据类型转换和数据校验等等。 3）Struts2拦截器在访问某个Action方法之前和之后实施拦截 4）Struts2拦截器是可插拔的，拦截器是AOP（面向切面编程）的一种实现。 5）拦截器栈（Interceptor Stack）：将拦截器按一定的顺序联结成一条链，在访问被拦截的方法时，Struts2拦截器链中的拦截器就会按其之前定义的顺序依次调用。 struts2中的的功能（参数处理、文件上传、字符编码等）都是通过系统拦截器实现的。如果业务需要，当然我们也可以自定义拦截器,进行可插拔配置，在执行 Action 的方法前后、加入相关逻辑完成业务。 使用场景： （1）用户登录判断，在执行 Action的前面判断是否已经登录，如果没有登录的跳转到登录页面。 （2）用户权限判断，在执行 Action的前面判断是否具有，如果没有权限就给出提示信息。 （3）操作日志……等等 6. 在Struts2中创建Action类有哪些不同的方法？（1）方式一：直接创建一个类，可以是POJO，即原生Java类，没有继承任何类，也没有实现任何接口。这种方式使得strust2框架的代码侵入性更低，但是这种方式是理想状态，开发中并不常用。 （2）方式二：实现一个接口com.opensymphony.xwork2.Action。接口里面有execute方法，提供了action方法的规范，Action接口预置了一些字符串，可以在返回结果时使用。为了方便。这种方式也不常用。 （3）方式三：继承一个类，ActionSupport。该方式帮我们实现了一些接口 Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable 如果我们需要用到这些接口的时候，就不需要自己实现了 7. 什么是ValueStack和OGNL？****ValueStack是Struts2存储应用程序数据以处理客户端请求的存储区域。数据存储在ActionContext使用ThreadLocal的对象中，以具有特定于特定请求线程的值。 对象图导航语言（OGNL）是一种功能强大的表达式语言，用于处理存储在ValueStack上的数据。正如您在架构图中看到的，拦截器和结果页面都可以使用OGNL访问存储在ValueStack上的数据。 8. 列举Struts2中引入的一些有用的注释？****Struts2中引入的一些重要注释是： @Action创建动作类 @Actions为多个动作配置单个类 @Namespace和@Namespaces用于创建不同的模块 @Result用于结果页面 @ResultPath用于配置结果页面位置 9. 项目中继承ActionSupport并实现ModelDriven接口？****struts可以继承ActionSupport类，也可以不继承，继承的好处简单来说就是更方便实现验证，国际化等功能，与struts2的功能结合紧密，方便我们开发。 ActionSupport类的作用： 此类实现了很多实用的接口，提供了很多默认的方法，这些默认方法包括国际化信息，默认的处理用户请求的方法等，可以大大简化action的开发，在继承ActionSupport的情况下，必须有无参构造函数。 struts2不要求我们自己设计的action类继承任何的struts基类或struts接口，但是我们为了方便实现我们自己的action，大多数情况下都会继承com.opensymphony.xwork2.ActionSupport类，并重写此类里的public String execute() throws Exception方法。因为此类中实现了很多的实用借口，提供了很多默认方法，这些默认方法包括国际化信息的方法、默认的处理用户请求的方法等，这样可以大大的简化Acion的开发。 实现了ModelDriven 可以使用VO，就是提交过来的参抄数（这个参数就百是表单的数据） 可以直接驱动到action的setXXX（）里面，意思就是说 实现了ModelDriven就必须百实现getModel这个方法，该方法返回的是你的度ModelDrivern泛型中设定的实体类。其实是为了实现代码的重用，不要再定义问一次你在数据访问层定义的属性了，直接用那答个类就行了。不过有时候也回不是很需要这个东西，答比如只有一两个表单域的时候。 10. Struts国际化？****国际化（i18n）是规划和实施的产品和服务，使他们能很容易地适应特定的本地语言和文化的过程中，这个过程被称为本地化。国际化的过程有时也被称为翻译或本地化启用。国际化是缩写i18n，因为我和两端用n字打头，并有18个字符之间的第i个和最后n。 11. 如何在Struts2应用程序中上传文件？****文件上传是Web应用程序中的常见任务之一。 Struts2通过FileUploadInterceptor提供对文件上传的内置支持。 此拦截器在struts-default包中配置，并提供选项以设置文件的最大大小和可以上载到服务器的文件类型。 12. Struts2实现文件上传的步骤？****基于表单的文件上传需要下载所需要的jar包文件\\Commons-FileUpload组件******、****需要下载Common-FileUplaod** **当然MyEclipce中Struts2支持里自带有这两个包**** 基于表单的上传，在form标签中有一个必须的属性值设置：enctype 如果要做文件上传功能必须将enctype值设为multipart/form-data 修改struts2配置文件 配置struts.xml文件，重置fileUpload拦截器 &lt;interceptor-ref name=“fileUpload”&gt; ​ &lt;param name=“maximumSize”&gt;10485760 编写相应的action类 13. Struts2的核心是什么? 体现了什么思想？****Struts2的核心是拦截器,基本上核心功能都是由拦截器完成,拦截器的实现体现了AOP(面向切面编程)思想 14. 为何继承ActionSupport因为ActionSupport实现了Action接口，提供了国际化，校验功能。 ActionSupport实现了国际化功能：因为它提供了一个getText(String key)方法实现国际化,该方法从资源文件上获取国际化信息。 Action接口提供了五个常量(success,error,login,input,none)。 15. Struts2 如何定位action中的方法在xml配置文件中通过配置多个action，使用action的method指定方法。 使用通配符(*)匹配方法。 16. 模型驱动与属性驱动是什么 模型驱动使用时注意什么问题模型驱动与属性驱动都是用来封装数据的。 （1）模型驱动：在实现类中实现ModelDriven接口使用泛型把属性类封装起来，重写getModel()方法，然后在实现类里创建一个属性类的实例， 通过这个实例拿到封装进来的值，拿返回值的时候使用工具进行值拷贝。 （2）属性驱动：在实现类里定义属性，生成get与set方法，通过属性来拿值。 注意：模型驱动使用时注意的是在使用前先把属性类实例化，否则会出现空指针错误，拿返回对象的值需要用拷贝内存因为地址发生改变。 模型驱动不可以使用局部类型转换器。 17. Struts2是怎样进行值封装的？struts2的值封装实际上是采用了ognl表达式 struts2的拦截器经过模型驱动时会先判断action是否实现了ModelDriven，如果是，则拿到模型的实例放在了栈的顶部， 到属性驱动的时候会从栈里面把栈顶的实例给取出来，从页面传进来的值放在一个map集合当中， 通过map集合进行迭代会通过ognl技术把值封装到实例中。 18. OGNL是什么你在项目中如何使用它****？OGNL是：对象图形导航语言。 原ognl是单个对象的，在struts2的应用是多个对象的，struts2的类型转换也是通过ognl来实现的。 Struts2中默认的表达式语言就是ognl，struts2的取值设值都是通过ognl来实现的,struts2要依靠它的标签才可以使用ognl。 相对于jstl或者其他表达式语言，它有如下优势： （1）能够调用对象实例的方法 （2）能够调用类的静态方法 （3）操作集合对象 （4）访问Ognl上下文 取值时ognl有三个参数： （1）表达式 （2）ognl的上下文(map) （3）对象实例(值栈)。 如果表达式带#号是从上下文中(map)拿值，否则是从值栈中拿值。 设值时有四个参数： （1）表达式，（2）ognl的上下文(map)，（3）对象实例，（4）设入的值 如果表达式带#号是把值设入上下文中(map)，否则是把值设入值栈中。 在struts2中 ognl的实现关系:ActionConetxt。 ognl 3个常用的符号 # $ % # ：构造map，list集合。取ognl上下文的值。用来过滤集合。 $ ：在校验框架中取资源文件中的值。可以在配置文件中传递参数。 % ：使用百分号可以进行转义。 19. Strust2如何访问Servlet API****？答： （1）通过ActionContext可以获得request，application，session三个作用域(struts2实际上是通过适配器来把servlet的api转换为一个map， 并把这些map放在ActionContext里面)。 （2）通过ActionContext的子类ServletActionContext去获取原滋原味的API。 （3）可以通过实现ServletRequestAware接口，重写里面的setServletRequest方法可以获得request，实际上是通过set的依赖注入。 20. 什么是拦截器 说说Struts2用拦截器来干什么 说出6个拦截器来****在访问类的某个方法或者属性之前执行，拦截的是Action的请求，进行拦截然后在方法的执行前或者之后加入某些操作，如：国际化，权限，效验等与源代码无关的操作。 拦截器：国际化，表单重复提交，类型转换，自动装配，数据封装,异常处理，模型驱动，请求参数，处理类型转换错误，日志拦截器。 \\（******项目中遇到什么问题****）**** 3.使用模型驱动拿返回值的时候地址内存不一样，会拿不到值。 原因：因为struts2最开始是把创建action的实例放到ActionContext的栈顶，后来把创建模型驱动的实例放到栈顶， 而通过struts2的标签去取值会取栈顶的实例，而此时拿到的还是最开始的创建的那个实例，所以为空。 解决方式：利用原型进行对象拷贝，使用拷贝工具，BeanUtils或者是propertyUtils。 21. ActionContext是用来干什么用的？答：ActionContext是Action的上下文。 通过ActionContext这个类来可以获得:request，application，session，Locale、ValueStack,ConversionErrors （1）可以获得servlet的api：request，application，session。 （2）进行国际化：获得语言环境 Locale。 （3）收集错误信息：ConversionErrors。 （4）有个值栈来装action实例与创建的模型驱动的实例:ValueStack。 （5）ActionContext是线程安全的-用本地线程实现的。 22. Struts2是如何实现mvc的：struts2的底层视图默认是freemaker。什么mvc？****M：模型，V：视图，C：控制器 在struts2中分别对应什么？ M(模型)：除核心控制器外都属于模型，实现业务的类(service层与dao层)。 V(视图)：result,type,dispatcher默认的(jsp，freemaker，velocity，源代码等)。 C(控制器)：核心控制器与业务控制器。 mvc解决什么问题？ 解决了数据封装，类型转换，数据效验，国际化，异常处理等问题。 23. 开发项目时struts2在页面怎样拿值？从值栈中或者是ognl的上下文中取值 24. 怎么样用Struts2进行文件的上传或者下载\\上传：Struts2里面已经提供了默认的拦截器来处理上传,只要在jsp用了s:file标签,把s:from的enctype 属性设置为 multipart/form-data,然后在action里面定义三个字段 File file ,String [file]ContentType,String [file]?FileName即可,如果有多个文件上传,那么就用List来接受,然后把接受到的File构建成FileInputStream,转化成硬盘上面的文件即可(用输出流) 下载：用了resust为stream的类型,然后在action定义四个属性,默认的有个是InputStream 的类型叫inputStream的,从硬盘上面读取文件到这个流赋值即可. 25. 简单讲下struts里面的标签,说不少于5个****s:iterater ?s:property s:form s:url s:if 等等 26.默认struts2里面的标签取值都是从那里取值的****默认都是从OGNL值栈里面取值的 27. ValueStack分为那两部分,组成部分是什么,分别怎么访问****分为对象栈和ContextMap ,对象栈里面放入的是Action及其用户定义的对象,在前台可以直接访问,在contextMap里面放入的是Servlet对象转化后map,譬如requestMap,sessionMap,访问的时候前面加#即可。 28. struts2的请求处理流程\\（1）客户端发送请求。 （2）经过一系列的过滤器（如:ActionContextCleanUp、SiteMesh等）到达核心控制器（FilterDispatcher）。 （3）核心控制器通过ActionMapper决定调用哪个Action，如果不是调用Action就直接跳转到jsp页面 （4）如果ActionMapper决定调用了某个Action，核心控制器就把请求的处理交给一个代理类（ActionProxy）。 （5）代理类通过配置管理器(Configuration Manager)找到配置文件（struts.xml）找到需要调用的Action类。 （6）代理类还要创建一个Action的调度器（ActionInvocation）。 （7）由调度器去调用Action，当然这里还涉及到一些相关的拦截器的调用。 （8）Action执行完后，这个调度器还会创建一个Result返回结果集，返回结果前还可以做一些操作（结果集前的监听器）。 29. struts2源码与设计模式命令模式(发生.do请求封装成action调用execute方法)，代理模式(访问action时核心控制器把请求交给代理类(ActionProxy)去访问Action就是代理模式)， 责任链模式(访问action时经过一系列的拦截器就使用了责任链模式)，适配器(把Servlet的API通过适配器转换成Map，把Map放入ActionContext中)， 组合模式(拦截器栈和拦截器就使用到组和模式)。 源码： 服务器启动的时候容器会创建FilterDispatcher实例，进入dispatcher.init()方法，在init方法里面会初始化sturts2的一系列的配置文件，然后向服务器发送请求，进入doFilter方法，在里面通过调用dispatcher.serviceAction方法,进入到Dispatcher里面的serviceAction方法，在这里就会把servlet的api转换为map，并把它一个个的放在ActionContext中，在这里还会创建ActionProxy的实例去调用execute方法，到StrutsActionProxy的execute方法，通过DefaultActionInvocation的实例去调用invoke方法，在invoke方法里面会进行判断拦截器是否存在，如果存在就会调用intercept方法，在拦截器类(Intercept)中会通过DefaultActionInvocation实例调用里面的invock方法,它们会形成递归调用，当拦截器不存在的时候就会进入invokeActionOnly方法，判断有没有返回结果前的监听器preResultListener如果有则进去一个个执行，最后调用 executeResult()方法，创建result返回，执行execute方法，并返回视图。 30. struts2工作流程1、Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。 （1）核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。 （2）业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。 ​ Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。 \\简要执行流程：** （1）客户端初始化一个指向Servlet容器的请求； （2）这个请求经过一系列的过滤器（Filter） ​ （这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin） （3）接着FilterDispatcher被调用， ​ FilterDispatcher询问ActionMapper来决定这个请是否需要调用某个Action （4）如果ActionMapper决定需要调用某个Action， ​ FilterDispatcher把请求的处理交给ActionProxy （5）ActionProxy通过Configuration Manager询问框架的配置文件，找到需要调用的Action类 （6）ActionProxy创建一个ActionInvocation的实例。 （7）ActionInvocation实例使用命名模式来调用， ​ 在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 （8）一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。 在这个过程中需要涉及到ActionMapper （9）响应的返回是通过我们在web.xml中配置的过滤器 （10）如果ActionContextCleanUp是当前使用的，则FilterDispatecher将不会清理sreadlocal ActionContext;如果ActionContextCleanUp不使用，则将会去清理sreadlocals。 31. 拦截器和过滤器的区别？1、拦截器是基于Java反射机制的，而过滤器是基于函数回调的。 2、过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。 3、拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。 4、拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。 5、在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。 32. Struts2是如何启动的？\\1、struts2框架是通过Filter启动的，即StrutsPrepareAndExecuteFilter，此过滤器为struts2的核心过滤器； 2、StrutsPrepareAndExecuteFilter的init()方法中将会读取类路径下默认的配置文件struts.xml完成初始化操作。struts2读取到struts.xml的内容后，是将内容封装进javabean对象然后存放在内存中，以后用户的每次请求处理将使用内存中的数据，而不是每次请求都读取struts.xml文件。 33. Struts2的核心控制器是什么？它是什么作用？\\1、Struts2框架的核心控制器是StrutsPrepareAndExecuteFilter。 2、作用： 负责拦截由/*指定的所有用户请求，当用户请求到达时，该Filter会过滤用户的请求。默认情况下，如果用户请求的路径 不带后缀或者后缀以.action结尾，这时请求将被转入struts2框架处理，否则struts2框架将略过该请求的处理。 可以通过常量”struts.action.extension”修改action的后缀，如： 如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开。 34. struts2是如何管理action的？这种管理方式有什么好处？struts2框架中使用包来管理Action，包的作用和java中的类包是非常类似的。 主要用于管理一组业务功能相关的action。在实际应用中，我们应该把一组业务功能相关的Action放在同一个包下。 struts2中的默认包struts-default有什么作用？ （1）struts-default包是由struts内置的，它定义了struts2内部的众多拦截器和Result类型，而Struts2很多核心的功能都是通过这些内置的拦截器实现，如：从请求中 把请求参数封装到action、文件上传和数据验证等等都是通过拦截器实现的。当包继承了struts-default包才能使用struts2为我们提供的这些功能。 （2）struts-default包是在struts-default.xml中定义，struts-default.xml也是Struts2默认配置文件。 Struts2每次都会自动加载 struts-default.xml文件。 （3）通常每个包都应该继承struts-default包。 35. 值栈ValueStack的原理与生命周期？（1）ValueStack贯穿整个 Action 的生命周期，保存在request域中，所以ValueStack和request的生命周期一样。当Struts2接受一个请求时，会迅速创建ActionContext， ValueStack，action。然后把action存放进ValueStack，所以action的实例变量可以被OGNL访问。 请求来的时候，action、ValueStack的生命开始，请求结束，action、 ValueStack的生命结束； （2）action是多例的，和Servlet不一样，Servelt是单例的； （3）每个action的都有一个对应的值栈，值栈存放的数据类型是该action的实例，以及该action中的实例变量，Action对象默认保存在栈顶； （4）ValueStack本质上就是一个ArrayList； （5）关于ContextMap，Struts 会把下面这些映射压入 ContextMap 中： parameters ：该 Map 中包含当前请求的请求参数 request ： 该 Map 中包含当前 request 对象中的所有属性 session ：该 Map 中包含当前 session 对象中的所有属性 Application：该 Map 中包含当前 application 对象中的所有属性 attr：该 Map 按如下顺序来检索某个属性: request, session, application （6）使用OGNL访问值栈的内容时，不需要#号，而访问request、session、application、attr时，需要加#号； （7）注意： Struts2中，OGNL表达式需要配合Struts标签才可以使用。如：&lt;s:property value=”name”/&gt; （8）在struts2配置文件中引用ognl表达式 ,引用值栈的值 ，此时使用的”$”，而不是#或者%; 36. ActionContext、ServletContext、pageContext的区别？（1）ActionContext是当前的Action的上下文环境，通过ActionContext可以获取到request、session、ServletContext等与Action有关的对象的引用； （2）ServletContext是域对象，一个web应用中只有一个ServletContext，生命周期伴随整个web应用； （3）pageContext是JSP中的最重要的一个内置对象，可以通过pageContext获取其他域对象的应用，同时它是一个域对象，作用范围只针对当前页面，当前页面结束时，pageContext销毁， 生命周期是JSP四个域对象中最小的。 37. struts的工作原理（1）初始化，读取struts-config.xml、web.xml等配置文件（所有配置文件的初始化） （2）发送HTTP请求,客户端发送以.do结尾的请求 （3）填充FormBean（实例化、复位、填充数据、校验、保存） （4）将请求转发到Action（调用Action的execute（）方法） （5）处理业务（可以调用后台类，返回ActionForward对象） （6）返回目标响应对象（从Action返回到ActionServlet） （7）转换Http请求到目标响应对象（查找响应，根据返回的Forward keyword） （8）Http响应，返回到Jsp页面 38. 用自己的话简要阐述struts2的执行流程。Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。 核心控制器FilterDispatcher是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。 Struts 2的工作流程相对于Struts 1要简单，与WebWork框架基本相同，所以说Struts 2是WebWork的升级版本。基本简要流程如下： （1）客户端浏览器发出HTTP请求。 （2）根据web.xml配置，该请求被FilterDispatcher接收。 （3）根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。 （4）Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。 （5）Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。 （6）返回HTTP响应到客户端浏览器。 它是以Webwork的设计思想为核心，吸收struts1的优点，可以说 struts2是struts1和Webwork结合的产物。 struts2 的工作原理图： 一个请求在Struts2框架中的处理分为以下几个步骤：（1）客户端发出一个指向servlet容器的请求(tomcat)； （2）这个请求会经过图中的几个过滤器，最后会到达FilterDispatcher过滤器。 （3）过滤器FilterDispatcher是struts2框架的心脏，在处理用户请求时，它和请求一起相互配合访问struts2 的底层框架结构。在web容器启动时，struts2框架会自动加载配置文件里相关参数，并转换成相应的类。 如：ConfigurationManager、ActionMapper和ObjectFactory。ConfigurationManager 存有配置文件的一 些基本信息，ActionMapper存有action的配置信息。在请求过程中所有的对象（Action，Results， Interceptors，等）都是通过ObjectFactory来创建的。过滤器会通过询问ActionMapper类来查找请求中 需要用到的Action。 （4）如果找到需要调用的Action，过滤器会把请求的处理交给ActionProxy。ActionProxy为Action的代理对象 。ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action类。 （5）ActionProxy创建一个ActionInvocation的实例。ActionInvocation在ActionProxy层之下，它表示了 Action的执行状态,或者说它控制的Action的执行步骤。它持有Action实例和所有的Interceptor。 （6）ActionInvocation实例使用命名模式来调用，1） ActionInvocation初始化时，根据配置，加载Action相 关的所有Interceptor。2）通过ActionInvocation.invoke方法调用Action实现时，执行Interceptor。在 调用Action的过程前后，涉及到相关拦截器(intercepetor)的调用。 （7）一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果 通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表 示的过程中可以使用Struts2 框架中继承的标签。 39. Struts2 如何访问 HttpServletRequest、HttpSession、ServletContext 三个域对象 ?①. 与 Servlet API 解耦的访问方式 &gt; 通过 ActionContext 访问域对象对应的 Map 对象 &gt; 通过实现 Aware 接口使 Struts2 注入对应的 Map 对象 ②. 与 Servlet API 耦合的访问方式 &gt; 通过 ServletActionContext 直接获取 Servlet API 对象 &gt; 通过实现 ServletXxxAware 接口的方式使 Struts2 注入对应的对象","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试整理0406","slug":"面试整理0406","date":"2020-06-06T12:26:32.000Z","updated":"2021-05-16T11:04:06.720Z","comments":true,"path":"2020/06/06/面试整理0406/","link":"","permalink":"http://yoursite.com/2020/06/06/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%860406/","excerpt":"1.本地线程 theadlocal volital 线程锁 线程池 callable应用场景 优点1.1 什么是本地线程？Threadlocal意思就是线程本地的意思。ThreadLocal字面意思是本地线程，其实更准确来说是线程局部变量。 我们知道，在多线程并发执行时，一方面，需要进行数据共享，于是才有了volatile变量解决多线程间的数据可见性，也有了锁的同步机制，使变量或代码块在某一时该，只能被一个线程访问，确保数据共享的正确性。其中，Synchronized用于线程间的数据共享的。另一方面，并不是所有数据都需要共享的，这些不需要共享的数据，让每个线程单独去维护就行了，ThreadLocal就是用于线程间的数据隔离的。","text":"1.本地线程 theadlocal volital 线程锁 线程池 callable应用场景 优点1.1 什么是本地线程？Threadlocal意思就是线程本地的意思。ThreadLocal字面意思是本地线程，其实更准确来说是线程局部变量。 我们知道，在多线程并发执行时，一方面，需要进行数据共享，于是才有了volatile变量解决多线程间的数据可见性，也有了锁的同步机制，使变量或代码块在某一时该，只能被一个线程访问，确保数据共享的正确性。其中，Synchronized用于线程间的数据共享的。另一方面，并不是所有数据都需要共享的，这些不需要共享的数据，让每个线程单独去维护就行了，ThreadLocal就是用于线程间的数据隔离的。 ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程，获取保存的值时非常方便，ThreadLocal为变量在每个线程中都创建了一个副本，每个线程就可以很方便的访问自己内部的副本变量。 1.2 在java中守护线程和本地线程有什么区别？java中的线程分为两种：守护线程（Daemon）和用户线程（User）。任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。在java中守护线程和本地线程有什么区别呢？ 唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。 在JVM启动时候会调用main函数，main函数所在的线程是一个用户线程，这个是我们可以看到的线程，其实JVM内部同时还启动了好多守护线程，比如垃圾回收线程。那么守护线程和用户线程有什么区别那？区别之一是当最后一个非守护线程结束时候，JVM会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响JVM的退出。言外之意是只要有一个用户线程还没结束正常情况下JVM就不会退出。 如果你想在主线程结束后JVM进程马上结束，那么创建线程的时候可以设置线程为守护线程，否者如果希望主线程结束后子线程继续工作，等子线程结束后在让JVM进程结束那么就设置子线程为用户线程，Tomcat框架就是用了守护线程和用户线程联合运行起来的 1.3 volital 关键字作用？1.4 什么是线程池？线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。 Java中有三个比较常用的线程池，分别是FixedThreadPool， SingleThreadExecutor，CachedThreadPool。 1) FixedThreadPool 这是一个线程数固定的线程池，当这个线程池被创建的时候，池里的线程数就已经固定了。当需要运行的线程数量大体上变化不大时，适合使用这种线程池。固定数量还有一个好处，它可以一次性支付高昂的创建线程的开销，之后再使用的时候就不再需要这种开销。 2) SingleThreadExecutor 这是一个线程数量为1的线程池，所有提交的这个线程池的任务都会按照提交的先后顺序排队执行。单个线程执行有个好处：由于任务之间没有并发执行，因此提交到线程池种的任务之间不会相互干扰。程序执行的结果更具有确定性。 3) CachedThreadPool 一看到Cache就知道这是一个和缓存有关的线程池，每次有任务提交到线程池的时候，如果池中没有空闲的线程，线程池就会为这个任务创建一个线程，如果有空闲的线程，就会使用已有的空闲线程执行任务。有的人可能会有个疑惑：这样线程不就越来越多了吗？其实不是的，这个线程池还有一个销毁机制，如果一个线程60秒之内没有被使用过，这个线程就会被销毁，这样就节省了很多资源。CachedThreadPool是一个比较通用的线程池，它在多数情况下都能表现出优良的性能。以后编码的时候，遇事不决，用缓存（线程池）。 1.5 callable应用场景，优点是什么？创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。 这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。 如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。 而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。 2.redis mybatis 二级缓存 一级缓存 spring源码一级缓存就是同一个sqlsession中查询一致。则第一次查询到的结果缓存到内存。后续查询则直接读取缓存。 但是spring封装的方法 每一次提交事务都是打开关闭一个sqlsession。所以一级缓存用不到。 Mybatis一级缓存：Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。 Mybatis二级缓存：MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开席需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了 3. dubbo 消费者 生产者 区 组 版本号分3.1 Dubbo 4. 事务传播行为 数据库事务隔离级别4.1 数据库事务隔离级别 脏读： 脏读是指一个事务处理过程中读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。 不可重复读 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询隔离间隔中，被另一个事务修改并提交了。 例如事务T1在读取某一个数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和读脏的区别是，读脏是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务未提交的数据。 脏数据：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据(Dirty Data)，依据脏数据所做的操作可能是不正确的。 不可重复读：在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读 虚读（幻读） 虚读是事务非独立执行时发生的一种现象，例如事务T1对一个表中所有的行的某个数据项做了从1修改为2的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为1并且提交给数据库，而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生了幻觉一样，这就是幻读。 aop ioc 几种注入5.1 什么是AOPAOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。然而殊途同归，实现AOP的技术特性却是相同的，分别为： 1、join point（连接点）：是程序执行中的一个精确执行点，例如类中的一个方法。它是一个抽象的概念，在实现AOP时，并不需要去定义一个join point。 2、point cut（切入点）：本质上是一个捕获连接点的结构。在AOP中，可以定义一个point cut，来捕获相关方法的调用。 3、advice（通知）：是point cut的执行代码，是执行“方面”的具体逻辑。 4、aspect（方面）：point cut和advice结合起来就是aspect，它类似于OOP中定义的一个类，但它代表的更多是对象间横向的关系。 5、introduce（引入）：为对象引入附加的方法或属性，从而达到修改对象结构的目的。有的AOP工具又将其称为mixin。 5.2 什么是IOCIOC是一种思想，控制反转，在java开发中，就是将你设计好的对象交给容器控制，而不是显示的用代码进行对象的创建。 把创建和查找对象的控制权交给IOC容器，由IOC容器进行注入、组合对象，这样对象与对象之间是松耦合、便于测试、功能可复用（减少对象的创建和内存消耗），使得程序的整个体系结构可维护性、灵活性、扩展性变高。 使用IOC的好处：资源集中管理，实现资源的可配置和容易管理，降低了资源的依赖程度，即松耦合，便于测试，功能可复用 5.3 什么是DIDI 是指依赖注入，是IOC容器装配、注入对象的一种方式。通过依赖注入机制，简单的配置即可注入需要的资源，完成自身的业务逻辑，不需要关心资源的出处和具体实现。 Spring提供了三种主要的方式来配置IOC容器中的bean ①基于XML文件配置 ②基于注解配置 ③基于注解+java代码显示的配置 6. 数据库优化6.1 数据库优化的几种方式：一、创建索引：\\1. 要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引 。 \\2. (1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。 (2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。 (3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 二、避免在索引上使用计算在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。 三、使用预编译查询程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。 四、调整Where字句中的连接顺序DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。 五、尽量将多条SQL语句压缩到一句SQL中每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。 六、用where字句替换HAVING字句避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数 的过滤，除此之外，应该将条件写在where字句中。 七、使用表的别名当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 少哪些友列名歧义引起的语法错误。 八、考虑使用临时表暂存中间结果简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。 但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。 7. 序列化 静态属性会不会序列化 关键字 父类 是否序列化7.1 什么是序列化？序列化是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 \\8. nio aio bio \\9. java8新特性 9.1 java8的新特性 （1）Lambda 表达式 10. jvm内存模型jmm首先要说一下JVM内存空间分为五部分，分别是：方法区、堆、Java虚拟机栈、本地方法栈、程序计数器 方法区主要用来存放类信息、类的静态变量、常量、运行时常量池等，方法区的大小是可以动态扩展的， 堆主要存放的是数组、类的实例对象、字符串常量池等。 Java虚拟机栈是描述JAVA方法运行过程的内存模型，Java虚拟机栈会为每一个即将执行的方法创建一个叫做“栈帧”的区域，该区域用来存储该方法运行时需要的一些信息，包括：局部变量表、操作数栈、动态链接、方法返回地址等。比如我们方法执行过程中需要创建变量时，就会将局部变量插入到局部变量表中，局部变量的运算、传递等在操作数栈中进行，当方法执行结束后，这个方法对应的栈帧将出栈，并释放内存空间。栈中会发生的两种异常，StackOverFlowError和OutOfMemoryError,StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 本地方法栈结构上和Java虚拟机栈一样，只不过Java虚拟机栈是运行Java方法的区域，而本地方法栈是运行本地方法的内存模型。运行本地方法时也会创建栈帧，同样栈帧里也有局部变量表、操作数栈、动态链接和方法返回地址等，在本地方法执行结束后栈帧也会出栈并释放内存资源，也会发生OutOfMemoryError。 最后是程序计数器，程序计数器是一个比较小的内存空间，用来记录当前线程正在执行的那一条字节码指令的地址。如果当前线程正在执行的是本地方法，那么此时程序计数器为空。程序计数器有两个作用，1、字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，比如我们常见的顺序、循环、选择、异常处理等。2、在多线程的情况下，程序计数器用来记录当前线程执行的位置，当线程切换回来的时候仍然可以知道该线程上次执行到了哪里。而且程序计数器是唯一一个不会出现OutOfMeroryError的内存区域。 方法区和堆都是线程共享的，在JVM启动时创建，在JVM停止时销毁，而Java虚拟机栈、本地方法栈、程序计数器是线程私有的，随线程的创建而创建，随线程的结束而死亡。 11. hashcode equals 线程安全的hashmap？hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？ 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出： （1）equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。 （2）hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ 这种大量的并且快速的对象对比一般使用的hash容器中，比如hashset,hashmap,hashtable等等，比如hashset里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equal()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试，阿里","slug":"面试，阿里","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"}]},{"title":"阿里面试整理","slug":"阿里面试总结","date":"2020-06-06T10:26:32.000Z","updated":"2021-05-16T11:04:06.720Z","comments":true,"path":"2020/06/06/阿里面试总结/","link":"","permalink":"http://yoursite.com/2020/06/06/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","excerpt":"1. 类修饰词default和protected关系Java一共有四类类修饰符，private default，public protected protected 包内所有类可见，包外有继承关系的子类可见。 default表示默认，不仅本类访问，而且是同包可见。 当修饰词是private时，只有类内能够访问到，其他任何类都不能直接访问到。 当修饰词是public时，任何类内都能访问到。","text":"1. 类修饰词default和protected关系Java一共有四类类修饰符，private default，public protected protected 包内所有类可见，包外有继承关系的子类可见。 default表示默认，不仅本类访问，而且是同包可见。 当修饰词是private时，只有类内能够访问到，其他任何类都不能直接访问到。 当修饰词是public时，任何类内都能访问到。 2.参数传递，值传递和引用传递的关系，String和char数组作为入参，结果会改变吗值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。 引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。 String 比较特别，看过String 代码的都知道， String 是 final的。所以值是不变的。 函数中String对象引用的副本指向了另外一个新String对象,而数组对象引用的副本没有改变,而是改变对象中数据的内容. String作为参数传入时，因为在java中都是传递的是参数的引用，也就是按值传递的，String作为参数时，传递的是String数据的拷贝，那么方法中是不会改变数据本身的内容，char[]作为参数入参时，传递的是引用类型也就是数组的指向的引用的拷贝，引用的拷贝也是指向数组，所以对改变原数组的值。 3.异常都有几大类？运行时的空指针会抛异常吗？IO Exception异常发生需要自己去捕获？Java中的异常主要分为运行时异常runtimeExclrtion和非运行时异常IOExcletion， 运行时异常，主要是程序的编写存在问题，javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。比如数组越界异常，类未找到异常等等异常情况。 IOExcletion非运行时异常，这种异常编译器要求强制处置，要么try-cathch,要么在方法名后面抛出。要么捕获要么抛出。 4.线程池的TheadPoolExcutor核心参数,什么时候创建线程，什么时候不创建，线程达到最大上限是什么策略？什么时候加入缓存队列？ 一个完整的线程池应该具备如下要素： 任务队列：用于缓存提交的任务 线程数量管理功能：一个线程池应该很好的管理和控制线程的数量，可以通过三个参数来实现，比如创建线程池时初始的线程数量init，线程池自动扩展时最大的线程数量；在线程空闲时需要释放一定的线程但是也要维持一定的活跃数量。 5.线程状态？什么时候进入阻塞态什么时候进入等待状态？wait之后的状态可以直接回到Runnable吗？（1）. NEW 新建状态 线程刚被创建，但是还没启动，还没调用start方法（2）. Runnable 可运行状态 线程可以在Java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统处理器（3）. Blocked 锁阻塞 当一个线程试图获取一个对象锁时，而该对象锁被其他的线程持有，则该线程进入Blocked状态，当该线程持有锁时，该线程将变成Runnable状态（4）. Waiting 无限等待 一个线程在等待另一个线程执行唤醒动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者是notifyAll方法才能够唤醒。（5）. Timed Waiting 计时等待 同Waiting状态 ，，有几个方法有超时参数，调用他们将进入Timed Waiting状态，这一状态将一直保持到超时期满或者是接收到唤醒通知，带有超时参数的常用方法有Thread.sheep、Object.wait（6）. Teminated 被终止 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 6.高并发会带来什么问题？死锁的解决办法？高并发就是多个进程或者线程同时处理不同的操作。高并发会导致系统数据不正确，会出现脏数据等等问题。 对于一些大型网站，比如门户网站，在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库度、高效率的编程语言、还有高性能的Web容器。 7.Java的锁的了解，Sychronzed有哪些方法？一个类中两个Sychronized方法被两个线程锁住，分别去调用会阻塞吗？悲观锁乐观锁： 悲观锁：先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。 CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 8.设计模式知道哪些？设计原则有哪些？单例模式构造函数有何特点？静态方法初始化具体操作?为什么要加volatile?9.Spring的IOC和AOP? IoC自动注入的注解？@Autowired的功能？ 10.数据库方面除了项目之外还有哪些深入学习？试验RR级别下出现幻读？ \\1. 什么是多态？ 接口的多种不同的实现方式即为多态 在同一个方法中，这种由于参数类型不同而导致执行效果各异的现象就是多态 在Java中为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。 多态具体表现在重写和重载 多态就是类的多种表现方式 比如方法的同名不同参 子类重写父类 方法的重写和重载是Java多态性的不同表现。 重写是父类与子类之间多态性的一种表现。 重载是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载。 并且重载的方法是可以改变返回值的类型的。 \\2. 接口与抽象类的区别？ 含有abstract修饰符的类即为抽象类，抽象类不能创建实例对象。含有抽象方法的类必须定义为abstract class。在abstract class中，方法不必是抽象的，但是抽象方法必须在具体子类中实现，所以，不能有抽象构造方法或抽象静态方法。子类如果没有实现抽象父类中的所有抽象方法，则必须定义为abstract类型。抽象类需要被继承才能使用，而被final修饰的类无法被继承，所以abstract和final是不能共存的。 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。\\接口中的方法定义默认为public abstract类型**，接口中的成员变量类型默认为public static final。 \\3. 为什么会有java内存模型？ java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试，阿里","slug":"面试，阿里","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%EF%BC%8C%E9%98%BF%E9%87%8C/"}]},{"title":"参考面经","slug":"参考面经","date":"2020-06-05T12:26:32.000Z","updated":"2021-05-17T01:47:30.342Z","comments":true,"path":"2020/06/05/参考面经/","link":"","permalink":"http://yoursite.com/2020/06/05/%E5%8F%82%E8%80%83%E9%9D%A2%E7%BB%8F/","excerpt":"各公司面试题整理","text":"各公司面试题整理 一、前两道要求写出代码后两道说思路即可 第一题是自己设计一个双向链表，并实现插入 删除 一开始忘了处理头尾节点的情况，面试官让再检查，然后补上了 第二题是字符串替换，在字符串s中找到字符串p，并替换成e 这个题问了面试官说可以用暴力，就直接暴力解了，但是忘了string的insert和erase怎么用了，太菜了… 第三题如何找链表的第k个节点，思路：倒数第k个就是正数第l-k+1个，即l-(k-1),也就是说让一个游标先走k-1步，到达第k个节点，再有另一个游标从头开始，这样当第一个游标到达最后一个节点的时候，第二个游标正好在第l-(k-1)个节点，即倒数第k个节点上 第四题场景：服务器可能被IP重放攻击，要找出访问量最大的k个IP并处理，抽象成topK问题，先哈希去重，再创建小顶堆维护k个节点即可，后面又问了需要多少内存，堆需要维护的内存直接忽略不计了，因为主要的内存消耗在创建哈希表上，当时脑子有点乱，太迷了…第一次说了个8G，后来一想肯定不对，重新算了下，应该是2^32 *8B左右 二、二维矩阵中寻找元素，二维数组满足从左到右从上到下非递减， 从右上角或者左下角扫描，每次砍掉一行或者一列，时间复杂度max（m,n） 数据库的一些知识，mysql和redis，可以看我其他的面经，就不多提了 http 0.9 1.0 1.1 2.0 https tcp/udp等等 三、 https://blog.nowcoder.net/n/e5fe3fa16b774b469241029a6de4e65a#一java 这个链接比较详细 但是觉得这些参考价值一般，一和二都是直接内推的面试，注重了编程。 325搜狗1项目经验 2poi限制输入 3final 4hashmap currenthashmap 5spring特征spring事务 6mysql死锁 7jvm G1 CMS 8卷积神经网络 9linux操作 325美团1项目 2 mybitits hibenite 区别，哪个效率更高 3数据链路层和网络层设备和协议 4数据库左右连接，内连接自然连接， 5数据库二级索引 数据结构 数据怎么保存 6虚拟地址 为什么是2的64次方 7http的状态码 1gc 2三次握手 为什么三次握手 3http长连接短连接 4io多路复用 5数据库索引结构 为什么用b+树 6tcp怎么保证可靠的 7将字符串空格变为%23，从后往前解决 字节414 1==和equals 2重写equals和hashcode 3hashmap 4static和volatile 5第K大的数 6TCP可靠 7网络拥塞避免 8time-wait状态 阿里414项目，excel面向任务流 最小生成树和图 Int long大小 贪心算法 红黑树 携程1int大小integer 2gc 3jdk jre 4String stringbuilder 字符串常量池 5sychronized和volitile 6ssh 7 京东1多线程 锁区别 2设计模式，单例（保证方法无状态无状态） 3数据库优化，数据库索引哪种情况需要建立 索引失效 mysql日志 执行过程 4redis 要注意key不能过大 5线程池 参数 6oom 栈溢出，堆溢出，常量池溢出 阿里文娱 实习一面 3.12 50nin自我介绍spring 是否看过源码 Bean生命周期项目中一个难点jdk看过源码 ​树在Java的应用 红黑树 b树b+树区别 使用场景 协程与线程的关系设计一个上亿用户的登录模块设计一个单点登录排查后端性能思路小组协同开发，编码规则pb级集群日志里找重复行 编程邮件 蘑菇街 金融风控部门 实习一面 3.13 40min项目经历 订单管理，订单快照实现 为什么使用ES Activity 工作流 模板、嵌入、离开 工作分配换人 怎么实现 面向对象 注解怎么自己实现？都有哪些注解 Threadlocal Start方法与run方法，start方法底层实现 Java线程状态 new、running、waitting、time-waitting、阻塞、终结 反射的一些方法 Spring 两种反射 区别 接口 cglib Mybatis # $区别 SQL注入有哪些？可以怎么防范？从哪一层可以进行实现 Limit 参数使用 索引什么时候失效 左连接 右连接 腾讯 电脑管家深圳 简历面 3.16 20min 项目中ES、MySQL、redis的使用关系 保证redis一致性 为什么使用srio，与spring security的区别 处理大量读写请求 处理大量写请求 TF-IDF算法 阿里 企业智能事业部 3.16 20min项目的一个技术难点 cookie session http tcp Tcp拥塞 浏览器发送cookie流程 如何保证cookie安全 面向对象、解释其三个特点 数据结构快排、插入、堆排序 核心平台 人人车 核心平台 3.24 35min类加载机制 JVM数据区域 各个回收器 确定回收对象 MySQL存储引擎 Innodb mylsam分别哪种场景使用 建索引需要注意 索引失效的情况，explan Java封装继承多态 怎么实现多继承 Java各种基本类型 自动拆箱、装箱 String为什么不可变类，为何这样设计 Java里的数据结构 怎么理解线程安全 实现线程几种方式 Runable 与 callable区别 Spring IOC与Spring AOP 动态代理 Spring bean 单例、多例 作业帮 一面 3.25 50min数组Top k 快排 订单模块流程 购物车怎么实现 Redis 秒杀 watch 事务 知识图谱 短文本相似度计算 作业帮 二面 3.27 50min订单流程 减库存与生成订单顺序 elasticSearch MySQL与ES的同步 ES快20%是怎么得到的 TF-IDF详细步骤 192.168.255.255\\28 有多少个IP 自己显示器坏了，怎么得到IP 1 2 3 4 5 1 2 3的页面序号访问，内存中有4页大小的空间，LRU替换策略，最后内存里面保留的是哪几页内容 消费端1s消费一个指令，但60s最多消化10个，怎么实现？ 编程：A-Z AA-ZZ 一个整数对应列号 还了解哪些相似度计算算法 腾讯 后台 小程序 3.30 100min商品库存存在哪 redis存哪些数据、如何解决库存问题 请求读多写少，如何设计？（分布式锁、手动过期、本地缓存） 在后台使用一个异步线程的时候，如何确保不同的服务只建立、运行一个线程，而不是多个线程呢？ Redis 本地缓存 MySQL的关系 不硬件扩容的基础上，如何提高redis性能 Redis RDB，AOF以及项目中怎么用 Redis集群的配置情况 Redis 分片节点如何操作 Reids 主从同步、新master选取 ES的使用情况（项目中如何使用、使用版本、单机or集群） ES全文检索的底层原理 一个商品的不同信息是存在一个document中吗？（回答是，说我用的不是全文检索） MySQL索引方式（b树与hash索引） B树的应用，Innodb Mysriam存储引擎里索引的具体情况 Tcp接收端一直不处理收到的字节，会发生什么情况？（回答缓存、窗口，又问这些时间长会过期吗？） 服务端发送数据发给客户端后，数据经过了几次复制（用户态到内核态） Tcp协议之上的有哪些协议 HTTP与HTTPS区别与两者端口 HTTPS过程 中间人攻击是什么？https如何解决中间人攻击？ 原来使用http协议，后来升级为https，如何确保使用http时仍能访问到站点（307） 10个线程，每个加100，结果与1000的关系，如何解决？如何不适用代码块加锁（synchronized）的方式解决? 进程与线程有什么区别？ 如何控制一个进程独占一个文件？ 协程编程： 1、有序链表去重 \\2. 给定一个数组，有正数，负数，求和最大的连续子序列（动态规划，三种情况） 腾讯 后台 小程序 二面 3.31 80min Java运行时数据区域 方法区放的有什么数据 类加载机制 加载、双亲委派 静态变量什么时候初始化 解析过程 Java里的锁，synchronized的锁实现 Synchronized锁升级 Mysql索引的方式，除了hash B树还能有什么 介绍不同的存储引擎 B+树为什么比B树快 树索引的缺点 Redo undo 接收窗口（和一面类似） Tcp拥塞控制 四次挥手 二三次之间、2msl 最大报文时间 Socket编程？ 虚拟内存、段、页 Spring IOC，AOP的实现方式 Spring用到的设计模式 Redis主从同步 编程：删除倒数第n个节点 系统设计：实时输出最近一个小时内访问频率最高的10个IP，要求： 1、实时输出 2、从当前时间向前数的1个小时 3、QPS可能会达到10W/s 广联达 大数据部门 一面 30min项目中是怎么做的Mysql优化 Explain filesort？ 解释Spring IOC 与 AOP Spring 有哪些注入方式 Spring mvc 怎么做事务？ MySQL事务特点、隔离级别 MySQL锁，ABA问题 MySQL索引 具体细节 http 常用方法 https 重载与重写 String 为什么是不可变？优点是什么？ Stringbuilder 与 stringbuffer区别 Hashcode 腾讯 后台 3面 4.1 50min项目中怎么用到的事务 Redis怎么存数据 Es在项目中怎么用？与MySQL的区别在哪里？ 上次未回答出来的统计IP 100亿个数，找出中位数，4G内存 \\3******输入两棵二叉树A，B，判断B是不是A的子结构。****12345678910111213141516171819202122232425262728递归调用，public class Solution &#123; public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; if (root1 == null || root2 == null) &#123; return false; &#125; return judgeSubTree(root1, root2) || judgeSubTree(root1.left, root2) || judgeSubTree(root1.right, root2); &#125; private boolean judgeSubTree(TreeNode root1, TreeNode root2) &#123; if (root2 == null) &#123; return true; &#125; if (root1 == null) &#123; return false; &#125; if (root1.val != root2.val) &#123; return judgeSubTree(root1.left, root2) || judgeSubTree(root1.right, root2); &#125; return judgeSubTree(root1.left, root2.left) &amp;&amp; judgeSubTree(root1.right, root2.right); &#125;&#125; 操作给定的二叉树，将其变换为源二叉树的镜像。 12345递归方案：交换左右子树的节点，然后递归调用该方法。非递归：压入栈进行操作6输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）新建一个栈，将数组A压入栈中，当栈顶元素等于数组B时，就将其出栈，当循环结束时，判断栈是否为空，若为空则返回true. 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径 12345678910111213141516171819路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)递归做法public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null)return result; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) result.add(new ArrayList&lt;Integer&gt;(list));//因为在每一次的递归中，我们使用的是相同的result引用，所以其实左右子树递归得到的结果我们不需要关心， ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result1 = FindPath(root.left, target); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result2 = FindPath(root.right, target); list.remove(list.size()-1); return result; &#125;&#125; \\17二叉树深度**123456789public int TreeDepth(TreeNode root) &#123;//递归 if(root==null)&#123; return 0; &#125; int left=TreeDepth(root.left); int right=TreeDepth(root.right); return Math.max(left,right)+1;&#125;非递归 \\36 赛车问题**12345678910111213141516171819202122232425262728293031323334你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。当车得到指令 \"A\" 时, 将会做出以下操作： position += speed, speed *= 2。当车得到指令 \"R\" 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。 (当前所处位置不变。)例如，当得到一系列指令 \"AAR\" 后, 你的车将会走过位置 0-&gt;1-&gt;3-&gt;3，并且速度变化为 1-&gt;2-&gt;4-&gt;-1。现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。使用一个一维数组dp，dp[i]代表走到位置i处所需要的最小步数。因为先向前走forword步再向后走back步与先向后走back步再向前走forword步最后到达的位置相同，所以可以假设永远保持第一步是向前走的。第一步有三种情况：第一种是刚好走forword步后到达了目标位置i，则dp[i] = forword。第二种情况是向前走forword步后到达了位置i后面，这时需要再往回走，再加上回头的那一步，此时dp[i] = Math.min(dp[i], forword + 1 + dp[j - i]);（注意这里的上限是走到2 * i处）第三种情况是向前走forword步后未到达位置i处就需要返回，此时在保证返回的步数back &lt; forword的条件下遍历back，此时dp[i] = Math.min(dp[i], forword + 1 + back + 1 + dp[i - j + k])。得到转移方程后递归i，最后dp[target]即为所求值。class Solution &#123; public int racecar(int target) &#123; int[] dp = new int[target + 1]; for (int i = 1;i &lt;= target; i++)&#123; dp[i] = Integer.MAX_VALUE; for (int forword = 1;(1 &lt;&lt; forword) - 1 &lt; 2 * i; forword++) &#123; int j = (1 &lt;&lt; forword) - 1; if(j == i) dp[i] = forword; else if (j &gt; i) dp[i] = Math.min(dp[i], forword + 1 + dp[j - i]); else for(int back = 0; back &lt; forword; back++) &#123; int k = (1 &lt;&lt; back) - 1; dp[i] =Math.min(dp[i], forword + 1 + back + 1 + dp[i - j + k]); &#125; &#125; &#125; return dp[target]; &#125;&#125; \\42回溯法寻找二维数组中字符串**123456789101112131415161718192021222324252627282930313233343536373839404142用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; //标志位，初始化为false boolean[] flag = new boolean[matrix.length]; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; //循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法 if(judge(matrix,i,j,rows,cols,flag,str,0))&#123; return true; &#125; &#125; &#125; return false; &#125; //judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位) private boolean judge(char[] matrix,int i,int j,int rows,int cols,boolean[] flag,char[] str,int k)&#123; //先根据i和j计算匹配的第一个元素转为一维数组的位置 int index = i*cols+j; //递归终止条件 if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == true) return false; //若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可 if(k == str.length-1) return true; //要走的第一个位置置为true，表示已经走过了 flag[index] = true; //回溯，递归寻找，每次找到了就给k加一，找不到，还原 if(judge(matrix,i-1,j,rows,cols,flag,str,k+1) || judge(matrix,i+1,j,rows,cols,flag,str,k+1) || judge(matrix,i,j-1,rows,cols,flag,str,k+1) || judge(matrix,i,j+1,rows,cols,flag,str,k+1) ) &#123; return true; &#125; //走到这，说明这一条路不通，还原，再试其他的路径 flag[index] = false; return false; &#125;&#125; \\48会场分配问题**贪心算法，第一问题求出一个会场最大容纳数，每次贪心，选择可以进行的最早结束的会议当做下一次的选择 第二问题，最少需要多少会场，将开始时间和结束时间分别排序然后每次开始时间小于结束时间会场加一 123456789int j=0; int count = 0; for (int i=0;i&lt;n;i++)&#123; if (a[i]&lt;b[j])&#123; count++; &#125;else&#123; j++; &#125; &#125; \\49区间合并问题**对1，3 2，5 6，7 三个区间进行合并 Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); 首先使用指定排序，根据数组的第一个数据进行排序 使用list对已经合并好的区间进行存储 将list转换为数组res.toArray(new int[0][]); 1234567891011121314151617181920class Solution &#123; public int[][] merge(int[][] intervals) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if (intervals == null || intervals.length == 0) return res.toArray(new int[0][]); Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]); int i = 0; while (i &lt; intervals.length) &#123; int left = intervals[i][0]; int right = intervals[i][1]; while (i &lt; intervals.length - 1 &amp;&amp; intervals[i + 1][0] &lt;= right) &#123; i++; right = Math.max(right, intervals[i][1]); &#125; res.add(new int[]&#123;left, right&#125;); i++; &#125; return res.toArray(new int[0][]); &#125;&#125; ### 63求数组所有子集采用经典回溯法，核心如下，加入新数字，递归，去掉加入的数字，回溯 12345678910private void process(List&lt;Integer&gt;list, int[] nums, int start)&#123; lists.add(new ArrayList(list)); for(int i = start; i &lt; nums.length; i++)&#123; list.add(nums[i]); process(list, nums, i+1); list.remove(list.size()-1); &#125;&#125; \\64组合总和**题目 数组{2,3,5,7} 求和为7的组合，每个数字可以重复 和上面一样的思路，回溯法，每次加入新数字，递归，最后去除新数字 123456789101112131415161718private void process(int[] candidates, int target, List&lt;Integer&gt; list) &#123; if (target &lt; 0) &#123; return; &#125; if (target == 0) &#123; lists.add(new ArrayList&lt;&gt;(list)); &#125; else &#123; for (int i = 0; i &lt; candidates.length; i++) &#123; list.add(candidates[i]); //因为每个数字都可以使用无数次，所以递归还可以从当前元素开始 process( candidates, target - candidates[i], list); list.remove(list.size() - 1); &#125; &#125;&#125; \\67旋转数组**给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 三次翻转数组解决，第一次7654321，第二次5674321，第三次，5671234 12345swap(nums,0,nums.length-1);swap(nums,0,k-1);swap(nums,k,nums.length-1); \\68回文链表**1234567891011121314151617181920212223242526public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) &#123; return true; &#125; ListNode slow = head, fast = head; ListNode pre = head, prepre = null; while(fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; pre.next = prepre; prepre = pre; &#125; if(fast != null) &#123; slow = slow.next; &#125; while(pre != null &amp;&amp; slow != null) &#123; if(pre.val != slow.val) &#123; return false; &#125; pre = pre.next; slow = slow.next; &#125; return true; &#125; \\80乘积最大连续子数组**动态规划，记录当前最大值和最小值，因为最小值负数乘以负数会成为最大值 123456789101112public int maxProduct(int[] nums) &#123; int result=nums[0]; int min=nums[0]; int max=nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int temp=max; max=Math.max(Math.max(max*nums[i],nums[i]),min*nums[i]); min=Math.min(Math.min(temp*nums[i],nums[i]),min*nums[i]); result=Math.max(max,result); &#125; return result;&#125; \\81除自身外数组乘积**结果等于该数前面数字的乘积乘以后面数据的乘积，先循环计算该位置前面数的乘积，再循环计算前面数乘积乘以后面数乘积 1234567891011121314151617class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res=new int[nums.length]; int k=1; for(int i=0;i&lt;nums.length;i++)&#123; res[i]=k; k=k*nums[i]; &#125; k=1; for(int i=nums.length-1;i&gt;=0;i--)&#123; res[i]=res[i]*k; k=k*nums[i]; &#125; return res; &#125;&#125;","categories":[{"name":"面试整理","slug":"面试整理","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"函数式编程思想&Lambda表达式","slug":"函数式编程思想&Lambda表达式","date":"2020-03-22T12:26:32.000Z","updated":"2021-05-16T11:04:06.712Z","comments":true,"path":"2020/03/22/函数式编程思想&Lambda表达式/","link":"","permalink":"http://yoursite.com/2020/03/22/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3&Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"函数式编程的思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 面向对象的思想: ​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想: ​ 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程","text":"函数式编程的思想在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 面向对象的思想: ​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想: ​ 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 传统写法当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789101112public class Demo01Runnable &#123; public static void main(String[] args) &#123; // 匿名内部类 Runnable task = new Runnable() &#123; @Override public void run() &#123; // 覆盖重写抽象方法 System.out.println(\"多线程任务执行！\"); &#125; &#125;; new Thread(task).start(); // 启动线程 &#125;&#125; 代码分析对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 3.3 编程思想转换做什么，而不是怎么做我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 3.4 体验Lambda的更优写法借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 12345public class Demo02LambdaRunnable &#123; public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println(\"多线程任务执行！\")).start(); // 启动线程 &#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ Lambda表达式的标准格式由三部分组成： a. 一些参数 b. 一个箭头 c. 一段代码 格式 ： （参数列表） -&gt; {一些重要的方法的代码} 解释说明： （）表达是接口中抽象方法的参数列表，没有参数就空着，有参数就写出参数，各个参数之间使用逗号分隔，箭头 -&gt; 表示 把参数传递给方法体中() 。。大括号{} 中重写接口的抽象方法的方法体 带有参数和返回值的Lambda表达式我们封装一个Person类，Person类中定义姓名和年龄属性，并封装get set方法 我们进行重写Compartor接口中compare方法来对Person类按照年龄排序。 如果不使用Lambda表达式，我们使用匿名内部类的方式 1234567891011121314151617181920212223242526272829303132package LambdaExpress;import java.util.Arrays;import java.util.Comparator;public class LambdaExp &#123; public static void main(String[] args) &#123; Person[] arr = new Person[]&#123; new Person(\"小明\",20), new Person(\"小华\",18), new Person(\"小红\",29), &#125;; /** * 按照从小到大进行排序 * 升序排列 是前面的减去后边的 */ Arrays.sort(arr, new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;); for (Person person : arr) &#123; System.out.println(person); &#125; &#125;&#125; 下面我们使用Lambda表达式 123456789101112131415161718192021222324252627282930package LambdaExpress;import java.util.Arrays;import java.util.Comparator;public class LambdaExp &#123; public static void main(String[] args) &#123; Person[] arr = new Person[]&#123; new Person(\"小明\",20), new Person(\"小华\",18), new Person(\"小红\",29), &#125;; /** * 按照从小到大进行排序 * 升序排列 是前面的减去后边的 */ Arrays.sort(arr,(Person o1, Person o2) -&gt; &#123; return o1.getAge() - o2.getAge(); &#125;); for (Person person : arr) &#123; System.out.println(person); &#125; &#125;&#125; Lambda表达式：是可推到，可以省略。。凡是根据上下文推导出来的内容，都可以省略书写可以省略的内容： （参数列表）：括号中参数列表的数据类型，可以省略不写 （参数列表）：括号中的参数如果只有一个，那么类型和() 都可以省略 （一些代码）：如果{}中的代码只有一行，无论是否有返回值，都可以盛烈（{}，return，分号） 需要注意的是：要省略{} return ，分号必须一起省略 Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 函数式接口函数式接口在Java中是指：有且仅有一个抽象方法的接口。 函数式接口，即适用于函数式编程场景的接口。。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/tags/java%E5%AD%A6%E4%B9%A0/"},{"name":"Lambda表达式","slug":"Lambda表达式","permalink":"http://yoursite.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"多线程原子操作类AtomicInteger","slug":"多线程原子操作类AtomicInteger","date":"2020-03-21T12:28:32.000Z","updated":"2021-05-16T11:04:06.714Z","comments":true,"path":"2020/03/21/多线程原子操作类AtomicInteger/","link":"","permalink":"http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicInteger/","excerpt":"什么是原子操作类AtomicInteger我们知道java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。synchronized关键字可以保证可见性和有序性却无法保证原子性。而这个AtomicInteger的作用就是为了保证原子性。 AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。","text":"什么是原子操作类AtomicInteger我们知道java并发机制中主要有三个特性需要我们去考虑，原子性、可见性和有序性。synchronized关键字可以保证可见性和有序性却无法保证原子性。而这个AtomicInteger的作用就是为了保证原子性。 AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。 对于Java中的运算操作，例如自增或自减，若没有进行额外的同步操作，在多线程环境下就是线程不安全的。num++解析为num=num+1，明显，这个操作不具备原子性，多线程并发共享这个变量时必然会出现问题。 下面我们测试一下： 123456789101112131415161718192021public class AtomicintegerDemo &#123; private static int count = 0; public static void main(String[] args) &#123; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.println(count++); &#125; &#125; &#125;); threads[i].start(); &#125; &#125;&#125;我们定义了是10个线程，每个线程做五次加操作，如果程序正常并发执行的话，结果应该是0–50个数字，中间没有重复数字出现，但是运行结果显然不是，这个时候就出现了多线程的数据安全问题。 分析出现上述安全问题的原因，可能是我们没有对多线程共享的变量进行保证在多线程间的可见性，所以我们可以使用volatile关键字修饰 换成volatile修饰count变量顺带说下volatile关键字很重要的两个特性： 1、保证变量在线程间可见，对volatile变量所有的写操作都能立即反应到其他线程中，换句话说，volatile变量在各个线程中是一致的（得益于java内存模型—“先行发生原则”）； 那么换成volatile修饰count变量后，会有什么效果呢？ 试一试: 还是上述的代码，我们对变量count使用volatile关键字进行修饰 1private static volatile int count = 0;输出结果好像还是与预期的不一致，这是为什么呢？并不能得出”基于volatile变量的运算在并发下是安全的”这个结论，，，此时，这个核心点在于在java的运算中，比如count++,++count操作并不是原子性的。 对于count++的操作，其实可以分解为3个步骤。 （1）从主存中读取count的值 （2）对count进行加1操作 （3）把count重新刷新到主存 这三个步骤在单线程中一点问题都没有，但是到了多线程就出现了问题了。比如说有的线程已经把count进行了加1操作，但是还没来得及重新刷入到主存，其他的线程就重新读取了旧值。因为才造成了错误。如何去解决呢？方法当然很多，但是为了和我们今天的主题对应上，很自然的联想到使用AtomicInteger。下面我们使用AtomicInteger重新来测试一遍： 我们对上面的类继续进行改造： 把上面的代码改造成AtomicInteger原子类型，先看看效果 12345678910111213141516171819202122232425import java.util.concurrent.atomic.AtomicInteger;public class AtomicintegerDemo &#123; //private static int count = 0; private static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) &#123; Thread[] threads = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.println(count.incrementAndGet()); &#125; &#125; &#125;); threads[i].start(); &#125; &#125;&#125;最后通过运行结果我们发现，输出结果中并没有重复的数字，程序能够在多线程的状况下并发的执行，并能够正确的输出结果，这都归功于AtomicInteger.incrementAndGet()方法的原子性。 原理分析在上面的例子中，我们使用AtomicInteger 中的incrementAndGet 函数来进行自增操作，代替直接使用count++来进行自增，保证了操作的原子性。 AtomicInteger类为我们提供了很多函数。 我们先看一下我们在上面使用的increasementAndGet函数，我们直接直接查看源码 123456789 /** * Atomically increments by one the current value. * * @return the updated value */public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;在这里我们会看到，底层使用的是unsafe的getAndAddInt方法。这里你可能有一个疑问了，这个unsafe是个什么鬼，而且还有一个valueOffset参数又是什么，想要看明白，我们从源码的开头开始看起。 开头在Unsafe的上面会发现，有一行注释叫做Unsafe.compareAndSwapInt。这又是什么？ （1） compareAndSwapInt的含义 compareAndSwapInt又叫做CAS，CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。 对于CAS的解释我不准备长篇大论讲解。因为里面涉及到的知识点还是挺多的。在这里你理解了其含义就好。 （2）Unsafe的含义 在上面我们主要是讲解了CAS的含义，CAS修饰在Unsafe上面。那这个Unsafe是什么意思呢？ Unsafe是位于sun.misc包下的一个类，Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。 这里说一句题外话，在jdk1.9中，对Usafe进行了删除，所以因为这，那些基于Usafe开发的框架慢慢的都死掉了。 我们回到上面的源码中，继续进行说明，在这里也就是说，Usafe再进行getAndAddInt的时候，首先是先加1，然后对底层对象的地址做出了更改。这个地址是什么呢？这就是涉及到我们的第三个疑问参数了。 （3）valueOffset的含义 这个valueOffset是long类型的，代表的含义就是对象的地址的偏移量。下面我们重新解释一下这行代码。 unsafe.getAndAddInt(this, valueOffset, 1) + 1。这行代码的含义是，usafe通过getAndAddInt方法，对原先对象的地址进行了加1操作。现在应该明白了。我们return的时候，也是直接返回的最新的值。这一点我们对比另外一个方法incrementAndGet就能看出。 在这个方法的源代码中我们可以看到最后的+1操作没有了，也就是说，直接返回的是旧地址的值，然后再进行自增操作。如何去拿的地址的偏移量呢？是通过下面这个代码。 OK，到了这一步相信你已经知道了，usafe对a的值使用getAndAddInt方法进行了加1操作。然后返回最新的值。 对于AtomicInteger的原理就是这，主要是通过Usafe的方式来完成的。Usafe又是通过CAS机制来实现的，因此想要弄清整个原子系列的真正实现，就是要搞清楚CAS机制。 总结对于jdk1.8的并发包来说，底层基本上就是通过Usafe和CAS机制来实现的。有好处也肯定有一个坏处。从好的方面来讲，就是上面AtomicInteger类可以保持其原子性。但是从坏的方面来看，Usafe因为直接操作的底层地址，肯定不是那么安全，而且CAS机制也伴随着大量的问题，比如说有名的ABA问题等等。","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程基础","slug":"多线程基础","date":"2020-03-21T12:26:32.000Z","updated":"2021-05-16T11:04:06.715Z","comments":true,"path":"2020/03/21/多线程基础/","link":"","permalink":"http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"进程和线程进程进程是指内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程，进程也是程序的一次执行过程，是系统运行程序的基本单位 ，系统运行一个程序即是一个进程从运行到消亡的过程。 线程线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，一个进行中是可以同时有多个线程的，这个应用程序也可以称为多线程程序。","text":"进程和线程进程进程是指内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程，进程也是程序的一次执行过程，是系统运行程序的基本单位 ，系统运行一个程序即是一个进程从运行到消亡的过程。 线程线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，一个进行中是可以同时有多个线程的，这个应用程序也可以称为多线程程序。 创建线程类创建多线程程序的第一种方式：创建Thread类的子类 Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。 每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的 步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程，执行里面的run方法 void run() 使该线程开始执行，Java虚拟机调用该线程的run方法。 Java程序属于抢占式调度，哪个线程的优先级高，哪个线程优先执行，同一个优先级的，随机选择一个执行。。 123456789101112131415161718192021public class myThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"mythread\"+i); &#125; &#125;&#125; public static void main(String[] args) &#123; myThread myThread = new myThread(); myThread.start(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main\"+i); &#125; &#125; 创建线程方式二采用Runnable 也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run() 方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法，来启动线程。 1234567891011121314151617181920public class RunnableThread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"runnable\"+i); &#125; &#125;&#125; public static void main(String[] args) &#123; RunnableThread runnableThread = new RunnableThread(); Thread thread = new Thread(runnableThread); thread.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"main\"+i); &#125; &#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程 代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程 编程的基础。 创建线程的两种方式Thread和Runnable的区别简单的说，如果一个类继承Thread，则不适合资源共享，但是如果实现了Runnable接口的话，则很容易的实现资源共享。 总结：实现Runnable接口比继承Thread类所具有的优势。 适合多个相同的程序代码的线程去共享同一个资源 可以避免Java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立 线程池只能放入实现Runnable或者是Callable类线程，不能直接放入继承Thread的类 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。 线程安全线程安全如果有多个线程同时运行，而这些线程可能会同时运行这段代码，如果多个线程同时运行同一段代码时，程序每次运行结果和单线程状态下运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 例如在以电影院卖票为例，当多个窗口也就是多个线程同时对一个变量也就是票数进行操作时，如果不控制线程安全，就有可能出现相同的票被卖了两回以及卖出不存在的票等等线程变量异常问题。简单的说，就是当几个窗口之间也就是几个线程之间票数变量不同步了，这种问题称为线程不安全问题。。 注意： 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。 线程同步问题当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述中出现的多线程并发访问同一个资源的安全问题,也就是解决重复票与不存在票问题，Java中提供了同步机制 synchronized 来解决。 还以上述卖票的代码为例： 窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码 去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU 资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 有三种方法解决线程安全问题 同步代码块 同步方法 锁机制 第一种同步方法：同步代码块同步代码块： 使用synchronized 关键字用于方法中需要进行同步的某个区块中，表示只对这个区块的资源实行互斥访问。 格式： 123synchronized（同步锁）&#123;需要同步的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED) 例如卖票的例子使用同步锁实现如下： 123456789101112131415161718192021222324package Thread;public class saleTicket implements Runnable&#123; private int number = 100; Object object = new Object(); @Override public void run() &#123; synchronized (object) &#123; if (number &gt;0 ) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + \"正在卖\" + number + \"张票\"); number--; &#125; &#125; &#125; &#125;&#125; 第二种同步方法：同步方法同步方法：使用synchronized修饰的方法，就叫做同步方法，使用synchronized修饰的方法，当多个线程同时执行时，可以保证线程A执行该方法的时候，其他线程只能在方法外面等着。 格式： 1234public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 在同步方法中的同步锁是：对于非static方法，同步锁就是this，对于static方法，我们使用当前方法所在类的字节码对象（类名.class）作为同步锁。 第三种同步方法：Lock锁在Java的机制中，提供了比synchronized代码块同步，和synchronized方法更广泛的锁定操作，同步代码块/同步方法具有的功能，Lock都有，初次之外Lock还有它特有的功能，使用Lock进行同步，更能体现面向对象的思想。 Lock锁也称为同步锁，加锁与释放锁方法化了，具体的方法如下： 123public void lock() :加同步锁public void unlock() :释放同步锁 以卖票为例： 12345678910111213141516171819public class saleTirckLock implements Runnable &#123; /** * 实现卖票同步的方法 Lock锁机制 */ private int ticket = 100; Lock lock = new ReentrantLock(); @Override public void run() &#123; lock.lock(); if (ticket &gt; 0)&#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"当前卖的是：\"+ticket+\"张票\"); ticket--; &#125; &#125; lock.unlock(); &#125;&#125;","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程-CyclicBarrier","slug":"多线程-CyclicBarrier用法","date":"2020-03-21T12:26:32.000Z","updated":"2021-05-16T11:04:06.714Z","comments":true,"path":"2020/03/21/多线程-CyclicBarrier用法/","link":"","permalink":"http://yoursite.com/2020/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier%E7%94%A8%E6%B3%95/","excerpt":"CyclicBarrier 是什么现实生活中我们经常会遇到这样的情景，在进行某个活动前需要等待人全部都齐了才开始。例如吃饭时要等全家人都上座了才动筷子，旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。 在JUC包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是CyclicBarrier类。利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作","text":"CyclicBarrier 是什么现实生活中我们经常会遇到这样的情景，在进行某个活动前需要等待人全部都齐了才开始。例如吃饭时要等全家人都上座了才动筷子，旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。 在JUC包中为我们提供了一个同步工具类能够很好的模拟这类场景，它就是CyclicBarrier类。利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作 CyclicBarrier字面意思是可循环（Cyclic）的屏障（Barrier）。它主要做的事情是，让一组线程达到一个屏障（也可以叫同步点或者栏栅）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。 我们看一下CyclicBarrier与CountDownLatch的直观区别就是： CountDownLatch说白了是做减法，减到0时，被阻塞的线程被唤醒； CyclicBarrier说白了是做加法，加到固定值时，被阻塞的线程被唤醒；CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。 首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现的。因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。 在CyclicBarrier类的内部有一个计数器，每个线程在到达屏障点的时候都会调用await方法将自己阻塞，此时计数器会减1，当计数器减为0的时候所有因调用await方法而被阻塞的线程将被唤醒。这就是实现一组线程相互等待的原理，下面我们先看看CyclicBarrier有哪些成员变量 123456789101112131415161718 //同步操作锁private final ReentrantLock lock = new ReentrantLock();//线程拦截器private final Condition trip = lock.newCondition();//每次拦截的线程数private final int parties;//换代前执行的任务private final Runnable barrierCommand;//表示栅栏的当前代private Generation generation = new Generation();//计数器private int count; //静态内部类Generationprivate static class Generation &#123; boolean broken = false;&#125;上面贴出了CyclicBarrier所有的成员变量，可以看到CyclicBarrier内部是通过条件队列trip来对线程进行阻塞的，并且其内部维护了两个int型的变量parties和count，parties表示每次拦截的线程数，该值在构造时进行赋值。count是内部计数器，它的初始值和parties相同，以后随着每次await方法的调用而减1，直到减为0就将所有线程唤醒。CyclicBarrier有一个静态内部类Generation，该类的对象代表栅栏的当前代，就像玩游戏时代表的本局游戏，利用它可以实现循环等待。barrierCommand表示换代前执行的任务，当count减为0时表示本局游戏结束，需要转到下一局。在转到下一局游戏之前会将所有阻塞的线程唤醒，在唤醒所有线程之前你可以通过指定barrierCommand来执行自己的任务。 接下来我们看看它的构造器。 12345678910111213 //构造器1public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125; //构造器2public CyclicBarrier(int parties) &#123; this(parties, null);&#125;CyclicBarrier有两个构造器，其中构造器1是它的核心构造器，在这里你可以指定本局游戏的参与者数量(要拦截的线程数)以及本局结束时要执行的任务，还可以看到计数器count的初始值被设置为parties。CyclicBarrier类最主要的功能就是使先到达屏障点的线程阻塞并等待后面的线程，其中它提供了两种等待的方法，分别是定时等待和非定时等待。 1234567891011121314 //非定时等待public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); &#125;&#125; //定时等待public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125;可以看到不管是定时等待还是非定时等待，它们都调用了dowait方法，只不过是传入的参数不同而已。下面我们就来看看dowait方法都做了些什么。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 //核心等待方法private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final Generation g = generation; //检查当前栅栏是否被打翻 if (g.broken) &#123; throw new BrokenBarrierException(); &#125; //检查当前线程是否被中断 if (Thread.interrupted()) &#123; //如果当前线程被中断会做以下三件事 //1.打翻当前栅栏 //2.唤醒拦截的所有线程 //3.抛出中断异常 breakBarrier(); throw new InterruptedException(); &#125; //每次都将计数器的值减1 int index = --count; //计数器的值减为0则需唤醒所有线程并转换到下一代 if (index == 0) &#123; boolean ranAction = false; try &#123; //唤醒所有线程前先执行指定的任务 final Runnable command = barrierCommand; if (command != null) &#123; command.run(); &#125; ranAction = true; //唤醒所有线程并转到下一代 nextGeneration(); return 0; &#125; finally &#123; //确保在任务未成功执行时能将所有线程唤醒 if (!ranAction) &#123; breakBarrier(); &#125; &#125; &#125; //如果计数器不为0则执行此循环 for (; ; ) &#123; try &#123; //根据传入的参数来决定是定时等待还是非定时等待 if (!timed) &#123; trip.await(); &#125; else if (nanos &gt; 0L) &#123; nanos = trip.awaitNanos(nanos); &#125; &#125; catch (InterruptedException ie) &#123; //若当前线程在等待期间被中断则打翻栅栏唤醒其他线程 if (g == generation &amp;&amp; !g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; //若在捕获中断异常前已经完成在栅栏上的等待, 则直接调用中断操作 Thread.currentThread().interrupt(); &#125; &#125; //如果线程因为打翻栅栏操作而被唤醒则抛出异常 if (g.broken) &#123; throw new BrokenBarrierException(); &#125; //如果线程因为换代操作而被唤醒则返回计数器的值 if (g != generation) &#123; return index; &#125; //如果线程因为时间到了而被唤醒则打翻栅栏并抛出异常 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;可以看到在dowait方法中每次都将count减1，减完后立马进行判断看看是否等于0，如果等于0的话就会先去执行之前指定好的任务，执行完之后再调用nextGeneration方法将栅栏转到下一代，在该方法中会将所有线程唤醒，将计数器的值重新设为parties，最后会重新设置栅栏代次，在执行完nextGeneration方法之后就意味着游戏进入下一局。如果计数器此时还不等于0的话就进入for循环，根据参数来决定是调用trip.awaitNanos(nanos)还是trip.await()方法，这两方法对应着定时和非定时等待。如果在等待过程中当前线程被中断就会执行breakBarrier方法，该方法叫做打破栅栏，意味着游戏在中途被掐断，设置generation的broken状态为true并唤醒所有线程。同时这也说明在等待过程中有一个线程被中断整盘游戏就结束，所有之前被阻塞的线程都会被唤醒。线程醒来后会执行下面三个判断，看看是否因为调用breakBarrier方法而被唤醒，如果是则抛出异常；看看是否是正常的换代操作而被唤醒，如果是则返回计数器的值；看看是否因为超时而被唤醒，如果是的话就调用breakBarrier打破栅栏并抛出异常。这里还需要注意的是，如果其中有一个线程因为等待超时而退出，那么整盘游戏也会结束，其他线程都会被唤醒。下面贴出nextGeneration方法和breakBarrier方法的具体代码。 1234567891011121314151617181920 //切换栅栏到下一代private void nextGeneration() &#123; //唤醒条件队列所有线程 trip.signalAll(); //设置计数器的值为需要拦截的线程数 count = parties; //重新设置栅栏代次 generation = new Generation();&#125; //打翻当前栅栏private void breakBarrier() &#123; //将当前栅栏状态设置为打翻 generation.broken = true; //设置计数器的值为需要拦截的线程数 count = parties; //唤醒所有线程 trip.signalAll();&#125; 最后，我们来看看怎么重置一个栅栏： 1234567891011 public void reset() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; breakBarrier(); // break the current generation nextGeneration(); // start a new generation &#125; finally &#123; lock.unlock(); &#125;&#125;我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？ 首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。 通过一个例子来看一下CyclicBarriesLeetCode上面有一道交替打印字符串的案例，我们可以使用多线程并发包中的 CyclicBarrier类来进行实现同步控制 123456789 编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是： 如果这个数字可以被 3 整除，输出 &quot;fizz&quot;。 如果这个数字可以被 5 整除，输出 &quot;buzz&quot;。 如果这个数字可以同时被 3 和 5 整除，输出 &quot;fizzbuzz&quot;。 例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。` 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 public class FizzBuzz2 &#123; private static CyclicBarrier barrier = new CyclicBarrier(4); int n; public FizzBuzz2(int n) &#123; this.n = n; &#125; // printFizz.run() outputs \"fizz\". public void fizz(Runnable printFizz) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; if (i % 3 == 0 &amp;&amp; i % 5 != 0) &#123; printFizz.run(); &#125; try &#123; barrier.await(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // printBuzz.run() outputs \"buzz\". public void buzz(Runnable printBuzz) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; if (i % 3 != 0 &amp;&amp; i % 5 == 0) &#123; printBuzz.run(); &#125; try &#123; barrier.await(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // printFizzBuzz.run() outputs \"fizzbuzz\". public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; printFizzBuzz.run(); &#125; try &#123; barrier.await(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // printNumber.accept(x) outputs \"x\", where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException &#123; for (int i = 1; i &lt;= n; i++) &#123; if (i % 3 != 0 &amp;&amp; i % 5 != 0) &#123; printNumber.accept(i); &#125; try &#123; barrier.await(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;设立static（静态唯一)的CyclicBarrier 等待其他线程都一起触发之后，才进行下一步操作。","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"排序算法","slug":"排序算法-冒泡与选择排序","date":"2020-03-20T02:20:32.000Z","updated":"2021-05-16T11:04:06.715Z","comments":true,"path":"2020/03/20/排序算法-冒泡与选择排序/","link":"","permalink":"http://yoursite.com/2020/03/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E4%B8%8E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"排序算法总结冒泡排序与选择排序算法","text":"排序算法总结冒泡排序与选择排序算法 选择排序选择排序是一种简单直观的排序算法。选择排序的基本步骤是： 首先，第一次从一个数组中选取最小值，与数组的第一个值arr[0]交换，，第二次从剩余的数组中选取最小值，与数组的第二个值交换，…..依次类推，重复以上步骤，总共是通过n-1次，这样就得到一个按排序码从小到大排列的有序序列。 说明： 选择排序一共有数组大小-1次的排序每一轮的排序，又是一个循环，循环的规则代码先假定当前的这个数是最小的，然后和后面的数依次比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标。当遍历到数组的最后时，就得到本轮最小数和下标 Java 代码 123456789101112131415161718192021222324252627/** * 选择排序方法 * @param arr */ public static void selectSort(int[] arr)&#123; int minIndex; int min; for (int i = 0; i&lt;arr.length-1;i++)&#123; minIndex = i; min = arr[i]; for (int j= i+1;j&lt;arr.length;j++)&#123; if (min &gt; arr[j])&#123; min = arr[j]; minIndex = j; &#125; &#125; //找出最小值之后，交换位置 if (minIndex != i)&#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125; 上述代码的执行顺序 首先是定义指向最小值的下标，以及最小值的变量，因为要经过n-1次的过程。 首先初始化最小值为第一个数组，最小值下标为0。在每一次中，把最小值和每一个元素进行比较，如果较小就更新最小值，并更新最小值的下标。在每一次的比较结束，进行位置交换。上述的n-1次按照这种方式依次进行比较。 冒泡排序冒泡排序的基本思想是：通过对待排序序列从前向后遍历（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样，逐渐向上冒。。 因为在排序的过程中，各个元素不断的被移动到接近自己的位置 ，如果一趟比较下来，没有元素进行过交换，那就说明序列有序，因此在冒泡排序的过程中需要设置一个标志 flag 判断元素是否进行过交换，从而减少不必要的比较。 Java实现冒泡排序 12345678910111213141516171819202122public static void maopaoSort(int[] arr)&#123; int temp= 0; boolean flag = false; //定义一个标志变量，来表示是否发生过交换，如果一趟比较发生过交换，则置为true for (int i=0;i&lt;arr.length;i++)&#123; for (int j = 0;j&lt;arr.length-1-i;j++)&#123; if (arr[j] &gt; arr[j+1])&#123; flag = true; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; if (!flag)&#123; break; &#125;else &#123; flag = false; &#125; &#125; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"线程状态","slug":"线程状态","date":"2020-03-05T12:26:32.000Z","updated":"2021-05-16T12:47:31.649Z","comments":true,"path":"2020/03/05/线程状态/","link":"","permalink":"http://yoursite.com/2020/03/05/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/","excerpt":"线程状态在线程的生命周期中，当线程被创建并启动之后，它既不是以启动就就进入了执行状态，也不是一直处于执行状态。在线程的整个生命周期中，一共有六种线程状态。","text":"线程状态在线程的生命周期中，当线程被创建并启动之后，它既不是以启动就就进入了执行状态，也不是一直处于执行状态。在线程的整个生命周期中，一共有六种线程状态。 线程状态： NEW 新建状态 线程刚被创建，但是还没启动，还没调用start方法 Runnable 可运行状态 线程可以在Java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统处理器 Blocked 锁阻塞 当一个线程试图获取一个对象锁时，而该对象锁被其他的线程持有，则该线程进入Blocked状态，当该线程持有锁时，该线程将变成Runnable状态 Waiting 无限等待 一个线程在等待另一个线程执行唤醒动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者是notifyAll方法才能够唤醒。 Timed Waiting 计时等待 同Waiting状态 ，，有几个方法有超时参数，调用他们将进入Timed Waiting状态，这一状态将一直保持到超时期满或者是接收到唤醒通知，带有超时参数的常用方法有Thread.sheep、Object.wait Teminated 被终止 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 使用一个简单的案例实现线程状态中的同步唤醒机制 线程同步唤醒机制1234567891011121314151617181920212223242526272829303132333435363738394041424344package tongbu;/** * 使用两个线程来演示一下线程状态中的 * 等待唤醒机制 */public class synchronizedWait &#123; public static void main(String[] args) &#123; Object object = new Object(); //构造一个同步锁 new Thread()&#123; @Override public void run() &#123; synchronized (object)&#123; try &#123; System.out.println(\"消费者去买包子，报完需求，等待生产者生产包子\"); object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"消费者拿到商品\"); &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; try &#123; Thread.sleep(5000);//花费5秒生产商品 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (object)&#123; System.out.println(\"生产者生产完成\"); object.notify(); &#125; &#125; &#125;.start(); &#125;&#125; Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。例如我们子卖票的案例中，为了减少线程执行的太快，现象看不出不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠，或者是暂停执行，一减慢线程。。 其实当我们调用了sleep方法之后，当前执行的线程就进入到休眠状态，其实就是所谓的Timed Waiting 计时等待。。 线程间通信简单的说，线程间的通信就是，多个线程在处理同一个资源，但是处理的动作也就是线程的任务却不相同。比如：线程A是用来生成包子的，线程B是用来吃包子的，包子可以理解为同一资源，线程A和线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。 为什么需要线程通信呢？ 多个线程并发执行时，在默认的情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务时，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或者操作，就是多个线程在操作同一份数据时，避免对同一共享变量的争夺，也就是我们需要通过一定的手段使各个线程能有效的利用资源，而这种手段就是=====等待唤醒机制。 什么是等待唤醒机制 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 线程池什么是线程池我们在以前使用一个线程的时候，就会去创建一个线程，这样实现起来非常的简便，随时需要随时创建，但是这样就会有一个问题：如果我们在开发中并发的线程数量很多，并且每个线程都是执行一个很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁的创建线程和销毁线程是需要时间的。。那么有没有一种办法就是，使得线程可以复用，就是执行完一个任务，线程并不被销毁，而是可以继续执行其他的任务，在Java中我们可以使用线程池来达到这样的效果。。 在JDK1.5 之前，关于创建线程池我们是通过集合来进行完成的比如ArrayList linkedList等等，来创建集合，然后把创建的线程放入集合中，通过对集合的操作来达到操作线程的目的。但是在JDK1.5之后，Java集成了线程池的概念。。","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"数据结构基础（二）","slug":"数据结构基础（二）","date":"2020-03-03T13:26:32.000Z","updated":"2021-05-16T11:04:06.717Z","comments":true,"path":"2020/03/03/数据结构基础（二）/","link":"","permalink":"http://yoursite.com/2020/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"数据结构中常见面试题总结1. 单链表（1）编程实现一个单链表搜的建立/测长/打印。 如果实现单链表，我们首先需要做的就是实现一个结点的定义，在C语言或者是C++语言中，我们使用的是结构体进行定义的，在Java中我们常使用类来实现链表结点的定义， 我们可以定义一个Node类，来表示链表中的结点。首先定义Node类，在Node类中，我们需要定义存放结点值的变量以及指向下一个结点的结点。","text":"数据结构中常见面试题总结1. 单链表（1）编程实现一个单链表搜的建立/测长/打印。 如果实现单链表，我们首先需要做的就是实现一个结点的定义，在C语言或者是C++语言中，我们使用的是结构体进行定义的，在Java中我们常使用类来实现链表结点的定义， 我们可以定义一个Node类，来表示链表中的结点。首先定义Node类，在Node类中，我们需要定义存放结点值的变量以及指向下一个结点的结点。 Node.Java类 1234567891011121314 package ListStudy;//定义一个用于表示结点的类public class Node &#123; int data; //表示结点数据的变量 Node next=null; //定义一个指向自己的指针 //定义带参构造方法 public Node(int data) &#123; this.data = data; &#125; &#125; 定义完链表之后，我们需要定义实现链表中的方法，主要是实现链表的插入结点方法，测试链表的长度，打印链表中的值等方法， MyLinkedList.java 链表方法类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 package ListStudy;/** * 在该类中定义链表的基本操作 */public class MyLinkedList &#123; //首先定义链表的头结点，链表的头结点默认为空 Node head = null; /** * 定义链表中添加结点的方法 * 在本例中采用的是尾插法建立单链表的方法 * @param data */ public void addNode(int data)&#123; Node newNode = new Node(data);//首先根据值建立一个结点，然后做插入位置的判断 //首先判断插入的位置，如果头结点为空则此时需要把元素插入到头结点上 if (head == null)&#123; head = newNode; return; &#125; //如果头结点不为空则执行下面的语句 //首先定义一个结点变量用来表示头结点的值 Node temp = head; while(temp.next != null)&#123; temp = temp.next; &#125; temp.next = newNode; &#125; /** * 打印链表中的结点 */ public void printLink()&#123; //首先定义一个结点指向头结点，从头往后打印 Node temp = head; while(temp != null)&#123; //如果指向头结点的临时变量不为空，就继续把指向头结点的指针向下移动 System.out.println(temp.data + \" \"); temp = temp.next; &#125; System.out.println(); &#125; /*** * 求建立链表的长度 */ public int length()&#123; int length = 0;//定义一个变量用来记录链表的长度 Node temp = head;//定义一个变量用来指向头结点 while(temp != null)&#123; length++; temp = temp.next; &#125; return length; &#125;&#125; 上面定义完链表中结点的表示，以及链表中新增，求长，打印的方法之后，我们需要进行测试，测试方法如下： testLink.Java 测试方法类 1234567891011121314 package ListStudy;public class testLink &#123; public static void main(String[] args) &#123; MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addNode(1); myLinkedList.addNode(2); myLinkedList.addNode(3); System.out.println(\"所建立链表的长度为\"+myLinkedList.length()); myLinkedList.printLink(); &#125;&#125; （2）编程实现单链表删除结点 删除链表中的结点的方法，有按照值删除的方法和按照链表位置删除的方法 要删除结点，只需要找到要删除结点前面的结点就行 我们继续在上面链表方法类MyLinkedList中添加操作链表的方法。。 书写按值查找和按照索引位置进行查询的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//首先按照指定的值删除结点public boolean deleteNode(int value) &#123; //建立临时结点，指向当前结点，首先从头结点kaishi Node temp = head; //首先判断第一个结点是不是我们要找的结点，如果第一个结点就是需要寻找的结点，直接把下一个结点赋值给head结点 if (temp != null &amp;&amp; temp.data == value) &#123; head = temp.next; return true; &#125; //如果第一个结点不是我们要找的值，则执行下面的判断 if (temp != null) &#123; //因为删除结点的时候，我们需要找到删除结点的前驱结点，所以我们就需要判断下一个结点的值是不是我们要找的值 while (temp.next.data != value) &#123; temp = temp.next; &#125; //找到之后，我们需要把目标结点的下一个结点赋值给目标结点的上一个结点 temp.next = temp.next.next; &#125; return true; &#125; //上面删除链表中值是按照值来进行删除的，下面我们按照链表中值的索引位置来进行删除public boolean deleteNode2(int index)&#123; //首先判断索引的位置是否合法 if (index &lt; 1 || index &gt; length())&#123; return false; &#125; //如果删除结点是头结点，则直接把头结点的下一个结点赋值给头结点 if (index == 1)&#123; head = head.next; return true; &#125; //把头结点赋值给一个临时结点 Node preNode = head; Node curNode = preNode.next; //把头结点的下一个结点当做当前结点 int i = 2; while(curNode != null )&#123; if (i == index)&#123; //寻找到待删除结点 preNode.next = curNode.next; return true; &#125; //把当前结点和当前结点的后续结点同时向下移动 preNode = preNode.next; curNode = curNode.next; i++; &#125; return true;&#125; （3）编程实现单链表的排序操作。 （4）编程实现单链表的逆序 （5）给一个单链表，不知道结点N的值，怎么样只遍历一次就可以求出中间结点，写出算法","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表","slug":"线性表","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"数据结构基础（一）","slug":"数据结构基础（一）","date":"2020-03-01T12:26:32.000Z","updated":"2021-05-16T11:04:06.716Z","comments":true,"path":"2020/03/01/数据结构基础（一）/","link":"","permalink":"http://yoursite.com/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"数据结构中常见面试题总结1. 单链表（1）编程实现一个单链表搜的建立/测长/打印。 如果实现单链表，我们首先需要做的就是实现一个结点的定义，在C语言或者是C++语言中，我们使用的是结构体进行定义的，在Java中我们常使用类来实现链表结点的定义， 我们可以定义一个Node类，来表示链表中的结点。首先定义Node类，在Node类中，我们需要定义存放结点值的变量以及指向下一个结点的结点。","text":"数据结构中常见面试题总结1. 单链表（1）编程实现一个单链表搜的建立/测长/打印。 如果实现单链表，我们首先需要做的就是实现一个结点的定义，在C语言或者是C++语言中，我们使用的是结构体进行定义的，在Java中我们常使用类来实现链表结点的定义， 我们可以定义一个Node类，来表示链表中的结点。首先定义Node类，在Node类中，我们需要定义存放结点值的变量以及指向下一个结点的结点。 Node.Java类 1234567891011121314 package ListStudy;//定义一个用于表示结点的类public class Node &#123; int data; //表示结点数据的变量 Node next=null; //定义一个指向自己的指针 //定义带参构造方法 public Node(int data) &#123; this.data = data; &#125; &#125; 定义完链表之后，我们需要定义实现链表中的方法，主要是实现链表的插入结点方法，测试链表的长度，打印链表中的值等方法， MyLinkedList.java 链表方法类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 package ListStudy;/** * 在该类中定义链表的基本操作 */public class MyLinkedList &#123; //首先定义链表的头结点，链表的头结点默认为空 Node head = null; /** * 定义链表中添加结点的方法 * 在本例中采用的是尾插法建立单链表的方法 * @param data */ public void addNode(int data)&#123; Node newNode = new Node(data);//首先根据值建立一个结点，然后做插入位置的判断 //首先判断插入的位置，如果头结点为空则此时需要把元素插入到头结点上 if (head == null)&#123; head = newNode; return; &#125; //如果头结点不为空则执行下面的语句 //首先定义一个结点变量用来表示头结点的值 Node temp = head; while(temp.next != null)&#123; temp = temp.next; &#125; temp.next = newNode; &#125; /** * 打印链表中的结点 */ public void printLink()&#123; //首先定义一个结点指向头结点，从头往后打印 Node temp = head; while(temp != null)&#123; //如果指向头结点的临时变量不为空，就继续把指向头结点的指针向下移动 System.out.println(temp.data + \" \"); temp = temp.next; &#125; System.out.println(); &#125; /*** * 求建立链表的长度 */ public int length()&#123; int length = 0;//定义一个变量用来记录链表的长度 Node temp = head;//定义一个变量用来指向头结点 while(temp != null)&#123; length++; temp = temp.next; &#125; return length; &#125;&#125; 上面定义完链表中结点的表示，以及链表中新增，求长，打印的方法之后，我们需要进行测试，测试方法如下： testLink.Java 测试方法类 1234567891011121314 package ListStudy;public class testLink &#123; public static void main(String[] args) &#123; MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addNode(1); myLinkedList.addNode(2); myLinkedList.addNode(3); System.out.println(\"所建立链表的长度为\"+myLinkedList.length()); myLinkedList.printLink(); &#125;&#125; （2）编程实现单链表删除结点 删除链表中的结点的方法，有按照值删除的方法和按照链表位置删除的方法 要删除结点，只需要找到要删除结点前面的结点就行 我们继续在上面链表方法类MyLinkedList中添加操作链表的方法。。 书写按值查找和按照索引位置进行查询的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//首先按照指定的值删除结点public boolean deleteNode(int value) &#123; //建立临时结点，指向当前结点，首先从头结点kaishi Node temp = head; //首先判断第一个结点是不是我们要找的结点，如果第一个结点就是需要寻找的结点，直接把下一个结点赋值给head结点 if (temp != null &amp;&amp; temp.data == value) &#123; head = temp.next; return true; &#125; //如果第一个结点不是我们要找的值，则执行下面的判断 if (temp != null) &#123; //因为删除结点的时候，我们需要找到删除结点的前驱结点，所以我们就需要判断下一个结点的值是不是我们要找的值 while (temp.next.data != value) &#123; temp = temp.next; &#125; //找到之后，我们需要把目标结点的下一个结点赋值给目标结点的上一个结点 temp.next = temp.next.next; &#125; return true; &#125; //上面删除链表中值是按照值来进行删除的，下面我们按照链表中值的索引位置来进行删除public boolean deleteNode2(int index)&#123; //首先判断索引的位置是否合法 if (index &lt; 1 || index &gt; length())&#123; return false; &#125; //如果删除结点是头结点，则直接把头结点的下一个结点赋值给头结点 if (index == 1)&#123; head = head.next; return true; &#125; //把头结点赋值给一个临时结点 Node preNode = head; Node curNode = preNode.next; //把头结点的下一个结点当做当前结点 int i = 2; while(curNode != null )&#123; if (i == index)&#123; //寻找到待删除结点 preNode.next = curNode.next; return true; &#125; //把当前结点和当前结点的后续结点同时向下移动 preNode = preNode.next; curNode = curNode.next; i++; &#125; return true;&#125; （3）编程实现单链表的排序操作。 （4）编程实现单链表的逆序 （5）给一个单链表，不知道结点N的值，怎么样只遍历一次就可以求出中间结点，写出算法","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表","slug":"线性表","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"CGLib代理","slug":"CGLib代理技术","date":"2019-11-17T12:26:32.000Z","updated":"2021-05-16T11:04:06.708Z","comments":true,"path":"2019/11/17/CGLib代理技术/","link":"","permalink":"http://yoursite.com/2019/11/17/CGLib%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/","excerpt":"上篇博客介绍了JDK的动态代理，但是JDK的动态代理机制只能代理实现了接口的类，也就是说如果一个类必须要有接口，这样我们才能使用JDK动态代理对这个类进行代理，而不能实现接口的类就不能实现JDK的动态代理，这样就存在一定的局限性，如果一个类没有实现接口，但是一些业务需要需要进行代理怎么办呢？对于这种情况，我们可以采用CGLIB代理来实现。","text":"上篇博客介绍了JDK的动态代理，但是JDK的动态代理机制只能代理实现了接口的类，也就是说如果一个类必须要有接口，这样我们才能使用JDK动态代理对这个类进行代理，而不能实现接口的类就不能实现JDK的动态代理，这样就存在一定的局限性，如果一个类没有实现接口，但是一些业务需要需要进行代理怎么办呢？对于这种情况，我们可以采用CGLIB代理来实现。 cglib是针对类来实现代理的，其实现原理：CGLIB的底层采用ASM字节码生成框架，使用字节码技术生成代理，比使用反射生成代理的效果要高，是对指定的目标类生成一个子类，并覆盖其中方法实现增强。但是也有一点点不足，因为采用的是继承，所以不能对final修饰的类进行代理。 在这一章节中，我们还是使用以前的代码，依然还是简单的三步来实现。 第一：建立一个普普通通的业务类； 第二：写CGLIB代理类； 第三：写测试代码或者客户端调用。 这里的不同是第一步中，我们不需要在建接口了，只是一个普普通通的java类。 编写需要进行代理的类： UserInfo.java 这只是一个简单的未实现任何接口的类 ```java 12345678910111213package com.proxyMoShi.CGLibProxy;public class UserInfo &#123; public void update() &#123; System.out.println(\"这是更新操作\"); &#125; public void query() &#123; System.out.println(\"这是查询的方法\"); &#125;&#125; ``` 我们编写cglib代理类 由于Cglib是第三方的API，所以需要导入相应的Jar包，因为自己是在学习Spring的时候，学习的Cglib代理，所以导入了Spring的核心jar文件，也就包括了Cglib代理的相关Jar文件。 ```java 1import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy; ``` CGLib代理类 123456789101112131415161718192021222324252627282930package com.proxyMoShi.CGLibProxy;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibProxy implements MethodInterceptor &#123; //委托对象，运行时定类型 private Object target; public Object getInstance(Object target) &#123; this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); // 回调方法 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"执行操作之前的日志\"); Object result = methodProxy.invokeSuper(o, objects); System.out.println(\"执行操作之后的日志操作\"); return result; &#125;&#125; 通过以上代码，我们发现proxy.invokeSuper（obj,arg)是执行的关键。 ​ 使用CGLIB,需要实现 CGLib 给我们提供的 MethodInterceptor 实现类，并重写 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy，我们需要特别注意一下。CGLib 给我们提供的是方法级别的代理，也可以理解为对方法的拦截。 我们直接调用 proxy 的 invokeSuper() 方法，将被代理的对象 obj 以及方法参数 args 传入其中即可。 所以到这为止，我们的CGLIB代理类对需要代理的类进行代理的功能也就实现了。 在代理类中，Enhancer、MethodInterceptor、MethodProxy这三个类和接口是我们实现Cglib动态代理的核心。 首先Enhancer类用于创建代理实例。负责整个代理对象的生命周期。其中setSuperclass方法用于设置被代理对象。也就是代理对象的父类。 setCallback方法用于设置回调。也就是对我们代理的方法转发到这个回调上。且所有回调类必须实现MethodInterceptor接口，并且实现intercept方法。在intercept方法中，传递了4个参数： （1）Object obj ：被代理的源对象 （2）Method method ：被代理的对象调用的方法 （3）Object [] args：被调用方法的参数集合 （4）MethodProxy proxy：被调用方法的代理，可以和method完成相同的事情，但是由于内部使用了FastClass机制，而不是反射，所以效率更高。 最后一步是调用create方法,创建代理对象。 下面我们编写一个类对上面编写的类进行测试： Client.java 12345678910package com.proxyMoShi.CGLibProxy;public class Client &#123; public static void main(String[] args) &#123; CglibProxy cglibProxy = new CglibProxy(); UserInfo userinfo = (UserInfo) cglibProxy.getInstance(new UserInfo()); userinfo.query(); &#125;&#125; 运行结果： 执行操作之前的日志 这是查询的方法 执行操作之后的日志操作 Process finished with exit code 0 从运行结果中，我么可以看到写的代理类是可以正常对类进行代理的。 ### 总结： CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP，为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。 Cglib代理构建的注意事项：我们在构建的过程中首先需要引入cglib – jar文件， 但是spring的核心包中已经包括了cglib功能，所以直接引入spring-core-3.2.5.jar即可。引入功能包后，就可以在内存中动态构建子类，代理的类不能为final， 否则报错。目标对象的方法如果为final/static, 那么就不会被拦截，即不会执行目标对象额外的业务方法。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"CGLib代理","slug":"CGLib代理","permalink":"http://yoursite.com/tags/CGLib%E4%BB%A3%E7%90%86/"}]},{"title":"动态代理技术","slug":"2019-11-12-动态代理技术","date":"2019-11-12T12:56:32.000Z","updated":"2021-05-16T11:04:06.707Z","comments":true,"path":"2019/11/12/2019-11-12-动态代理技术/","link":"","permalink":"http://yoursite.com/2019/11/12/2019-11-12-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/","excerpt":"动态代理在静态代理中，如果接口需要代理，我们需要提前写好代理类，在静态代理中建立好代理类与被代理类的关系，但是如果有多个接口需要同样被代理，就需要为每一个接口写一个代理类，这样会造成代码的大量重复，这个时候我们就可以使用动态代理技术，我们通过动态代理在运行期间动态的生成业务类的代理类。 总的来说，动态代理之所以能节省代码量，在需要代理的时候进行动态代理，主要是因为动态代理的字节码是在程序运行的时候由反射机制进行动态的额生成的，动态代理不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java机制可以生成任意类型的动态代理类。","text":"动态代理在静态代理中，如果接口需要代理，我们需要提前写好代理类，在静态代理中建立好代理类与被代理类的关系，但是如果有多个接口需要同样被代理，就需要为每一个接口写一个代理类，这样会造成代码的大量重复，这个时候我们就可以使用动态代理技术，我们通过动态代理在运行期间动态的生成业务类的代理类。 总的来说，动态代理之所以能节省代码量，在需要代理的时候进行动态代理，主要是因为动态代理的字节码是在程序运行的时候由反射机制进行动态的额生成的，动态代理不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java机制可以生成任意类型的动态代理类。 动态代理的流程与上面静态代理的分析流程是一样的，首先需要建立代理对象与真实对象与代理对象之间的联系。然后实现代理逻辑。 在JDK动态代理中，要想实现代理，我们定义的代理类必须实现 InvocationHandler 接口，接口中定义了一个invoke方法，并提供接口数组用下下挂对象。 1234InvocationHandler接口： public interface InvocationHandler &#123; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable; &#125; 参数说明： ​ Object proxy：指被代理的对象。 ​ Method method：要调用的方法 ​ Object[] args：方法调用时所需要的参数 使用JDK的动态代理使用动态代理依旧需要借助一个接口才能实现代理对象，我们定义接口和实现类。依旧使用上一节中定义过的 UserInfo接口及实现类 1234public interface UserInfo &#123; public void update();//更新信息 public void query();//查询信息&#125; 12345678910111213public class UserInfoImpl implements UserInfo &#123; @Override public void update() &#123; System.out.println(\"这是更新操作\"); &#125; @Override public void query() &#123; System.out.println(\"这是查询的方法\"); &#125;&#125; 定义完接口及实现类，下面我们就需要定义一个代理类。 在下面代码中，我们通过一个变量private Object target; 表示要被代理的真实对象，我们通过bind方法来实现本例对象与真实对象之间联系。在这里使用了一个类Proxy。Proxy类的作用就是用来动态创建一个代理类对象的类，它提供了许多的方法，但是我们用的最多的就是newProxyInstance这个方法。下面看一下newProxyInstance这个方法的参数。 newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) - loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载 - interfaces, ：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就可以称为实现了该接口，这样我就能调用这组接口中的方法了 - h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象 这样建立好联系之后我们就可以使用了。 12345678910111213141516171819public class UserDomticProxy implements InvocationHandler &#123; private Object target; public Object bind(Object target)&#123; this.target = target; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; System.out.println(\"before这是之前-日志操作\"); //执行方法 result = method.invoke(target, args); System.out.println(\"after--这是之后--日期操作\"); return result; &#125;&#125; 调用客户端，传入真正的委托类。 123456789public class clientDomticProxy &#123; public static void main(String[] args) &#123; UserDomticProxy userDomticProxy = new UserDomticProxy(); UserInfo userInfo = (UserInfo) userDomticProxy.bind(new UserInfoImpl()); userInfo.query(); &#125;&#125; 运行结果： 上面就是JDK代理的实现，我们可以看出，动态代理帮我们创建出一个代理，使代理与我们的委托类之间的关联关系进行了解耦，也就是我们需要进行代理的时候再进行代理，而且一次实现代理就可以为多种接口实现代理，这样可以大大的简化我们的代码，需要时再代理就是动态代理的思想。动态代理解决了静态代理中一对一的问题，使用反射可以动态的决定由任意类型的代理去代理实际的实现接口，提高了系统的课扩展性。动态代理和AOP面向切面编程的思想是一致的。 但是动态代理也有缺点，就是每一个被代理的对象都需要时实现接口，也就是说如果如果一个类需要代理它必须是接口的实现，但是一个类没有接口如何使用代理呢，这个时候就引入了CGlib代理技术。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]},{"title":"静态代理技术","slug":"2019-07-10-静态代理技术","date":"2019-11-10T11:56:32.000Z","updated":"2021-05-16T11:04:06.706Z","comments":true,"path":"2019/11/10/2019-07-10-静态代理技术/","link":"","permalink":"http://yoursite.com/2019/11/10/2019-07-10-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF/","excerpt":"静态代理技术在讲解静态代理之前，我们先看一下代理模式的概念。最初是在设计模式课程中学习过代理模式，当时也是一知半解，但是最近再看spring中，遇到一些设计模式中的设计思想，所以这里再进行重新学习一下。","text":"静态代理技术在讲解静态代理之前，我们先看一下代理模式的概念。最初是在设计模式课程中学习过代理模式，当时也是一知半解，但是最近再看spring中，遇到一些设计模式中的设计思想，所以这里再进行重新学习一下。 ## 代理模式 代理模式在我们的程序中是常用的设计模式之一。 我们先看一下代理模式的定义：代理模式主要是为其他对象提供一种代理以控制对这个对象的访问。当我们直接访问一个对象不能完成或者是不方便直接访问一个对象时，我们可以通过一个代理对象来进行间接的访问，所访问的真实对象与代理对象需要访问相同的接口。总的来说，代理对象主要是用来增强目标对象的功能的，目标对象是我们需要进行增强的对象。 代理模式又有很多的类型，如果我们按照代理模式创建的时期来进行划分的话，可以划分为静态代理和动态代理，这里代理对象创建的时期指的是，一个对象的增强版的代理对象是提前创建好的还是需要增强的时候再创建，当然或者动态代理具有很强的灵活性。 简单的说，举一个生活中的例子，比如代理律师，就相当于代理模式中的代理对象。在遇到法律问题的时候，委托方在一个问题上可能不是那么的专业，这个时候就需要一个代理代表委托方去处理一些问题，那么就可以说这个律师就是对委托方的增强，实现一些委托方不能做到或者是不方便做到的事情。 那么进一步的说，如果一个律师随时可以被多个有需求的委托方代理，那么这就是动态代理，在需要的时候创建，如果一个律师是一个企业中的执业律师，那么这个律师证只为这一个企业服务，可以说这样的形式就是静态代理。 下面详细讲解一下静态代理 静态代理技术实现一个静态代理，只需要三步就可以完成，首先我们需要定义一个业务接口，然后定义业务接口的实现类，然后定义代理类实现业务接口并增强功能，最后写一个client去调用。 首先定义一个业务接口： 接口中定义两种方法，更新和查询方法 ``` java 1234public interface UserInfo &#123; public void update();//更新信息 public void query();//查询信息&#125; ``` 我们写一个实现类，实现这个接口： 1234567891011121314151617package com.proxyMoShi.staticProxy;public class UserInfoImpl implements UserInfo &#123; @Override public void update() &#123; System.out.println(\"这是更新操作\"); &#125; @Override public void query() &#123; System.out.println(\"这是查询的方法\"); &#125;&#125;​ 123456789101112131415161718192021222324252627下面我们写一个代理类去增强这个对象、```javapackage com.proxyMoShi.staticProxy;public class UserStaticProxy implements UserInfo &#123; private UserInfoImpl userInfo; public UserStaticProxy(UserInfoImpl userInfoimple) &#123; this.userInfo = userInfoimple; &#125; @Override public void update() &#123; System.out.println(&quot;在更新之前进行一系列的日志操作&quot;); userInfo.update(); System.out.println(&quot;在更新之后进行一系列的日志操作&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;在查询之前进行一系列的操作&quot;); userInfo.query(); System.out.println(&quot;在查询之后进行一系列的操作&quot;); &#125;&#125; 使用这个对象之后，我们就可以在执行原来对象之前或者是之后，加上执行一些方法，比如日志功能，或者是权限判断等一些操作，这样我们可以在不改变原来类的前提下对功能进行扩展。 下面我们写一个client去执行以下我们写的代理类： 12345678910111213141516package com.proxyMoShi.staticProxy;public class clientStaticProxy &#123; public static void main(String[] args) &#123; /*UserInfo userInfo = new UserInfoImpl(); userInfo.query(); userInfo.update();*/ UserInfoImpl userInfo = new UserInfoImpl(); UserStaticProxy userStaticProxy = new UserStaticProxy(userInfo); userStaticProxy.query(); userStaticProxy.update(); &#125;&#125; 执行结果： 那么上面就是静态代理的实现过程，我们不改变原来的实现类，而且实现了一些方法。 但是我们可能也发现了，在静态代理中，一个代理类只能为一个接口实现服务，如果我们要是有很多都需要代理呢？那么就需要为每一个需要代理的接口，写一个代理类，这个时候每个代理实现的功能都是相同的功能，代码存在大量的重复。那么这个时候就需要创建动态代理，动态代理与静态代理相比具有更高的灵活性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"静态代理","slug":"静态代理","permalink":"http://yoursite.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SVM与KNN分类算法（wine数据集）","slug":"2019-11-10-SVM与KNN分类算法","date":"2019-11-10T11:56:32.000Z","updated":"2021-05-16T11:04:06.707Z","comments":true,"path":"2019/11/10/2019-11-10-SVM与KNN分类算法/","link":"","permalink":"http://yoursite.com/2019/11/10/2019-11-10-SVM%E4%B8%8EKNN%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/","excerpt":"本片文章是使用分类算法KNN,和SVM支持向量机分类算法，对Wine数据集进行分类的实现。","text":"本片文章是使用分类算法KNN,和SVM支持向量机分类算法，对Wine数据集进行分类的实现。 1.1 wine数据集Wine葡萄酒数据集是来自UCI上面的公开数据集，这些数据是对意大利同一地区种植的葡萄酒进行化学分析的结果，这些葡萄酒来自三个不同的品种。该分析确定了三种葡萄酒中每种葡萄酒中含有的13种成分的数量。从UCI数据库中得到的这个wine数据记录的是在意大利某一地区同一区域上三种不同品种的葡萄酒的化学成分分析。数据里含有178个样本分别属于三个类别，这些类别已经给出。每个样本含有13个特征分量(化学成分)，分析确定了13种成分的数量，然后对其余葡萄酒进行分析发现该葡萄酒的分类。 数据集中包含两个数据文件Wine.data 包含所有数据的数据文件Wine.names 数据集描述文件我对这些数据集的处理，以及数据集分析和分类实现使用的环境是MATLAB R2017a。 1.2 wine数据集属性描述在wine数据集中，这些数据包括了三种酒中13种不同成分的数量。文件中，每行代表一种酒的样本，共有178个样本；一共有14列，其中，第一个属性是类标识符，分别是1/2/3来表示，代表葡萄酒的三个分类。后面的13列为每个样本的对应属性的样本值。剩余的13个属性是，酒精、苹果酸、灰、灰分的碱度、镁、总酚、黄酮类化合物、非黄烷类酚类、原花色素、颜色强度、色调、稀释葡萄酒的OD280/OD315、脯氨酸。其中第1类有59个样本，第2类有71个样本，第3类有48个样本。具体属性描述如下表： 1.3 原始数据集展示原始数据文件是wine.data形式的文件，这些data文件的内容是以纯文本和逗号分隔格式编码的数据。该类型文件为使用者提供了很好的分析功能，有助于实时数据研究，存储，管理和分析。这里只展示原始数据文件中前20条数据。 1.4数据处理由于我们下载的源数据中可能存在各种各样的数据，因此不经任何处理就进入处理数据很可能违背数据质量三要素的要求。用这样的数据在进行后续的数据挖掘，其可靠性可能会有很大的偏差。我们首先需要做的就是处理数据中的缺失数据或异常值。我们需要提高数据质量，对下载的原始数据进行数据清理过程。首先进行的数据清洗的步骤相对较为简单与清晰，第一步需要进行偏差检测，即检查导致偏差的因素，并识别离散值与噪声值。然后进行数据清洗，即处理缺失值与噪声。在本数据集中由于数据都是连续的，而且通过对数据集的分析可以发现，数据集中一共有178个样本，由于数据源文件中的每个样本的数据都是完整的，没有空缺值等，所以我没有对该数据源文件进行数据的清理工作。原始数据集中是178个样本值，14列属性值，但是第一列是类别标识号，所以我们需要把这一列数据拿出单独作为对比列，作为一个1781的矩阵。然后把剩余的属性作为一个待处理17813的矩阵。类别标识符为3，属性列为字符串我们也需要单独拿出作为一个13*1的属性矩阵。 Matlab数据分列处理 1234load wine.datawine=wine(:,[2:14]);wine_labels=wine(:,1);save wine wine_labels 处理后的数据集形式为下图所示，篇幅限制，只展示部分数据集。 1.5 KNN分类算法实现1.5.1 KNN算法描述k-近邻（kNN，k-NearestNeighbor）算法是一种基本分类与回归方法，KNN算法的指导思想是“近朱者赤，近墨者黑”，由你的邻居来推断出你的类别。先计算待分类样本与已知类别的训练样本之间的距离，找到距离与待分类样本数据最近的k个邻居；再根据这些邻居所属的类别来判断待分类样本数据的类别。K-近邻算法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k-邻算法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显式的学习过程即属于有监督学习范畴。k近邻算法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的“模型”。k值的选择、距离度量以及分类决策规则是k近邻算法的三个基本要素。KNN算法流程如下：就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离。其算法的描述为： 1）计算测试数据与各个训练数据之间的距离； 2）按照距离的递增关系进行排序； 3）选取距离最小的K个点 4）确定前K个点所在类别的出现频率； 5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。 1.5.2 实验设计（1）训练集和测试集的划分为了提高分类的准确率，以及实验的正常验证，需要对训练集和测试集进行划分。将第一类的1-30，第二类的60-95，第三类的131-153做为训练集，相应的训练集的标签也要分离出来，将第一类的31-59，第二类的96-130，第三类的154-178做为测试集，相应的测试集的标签也要分离出来。具体代码如下所示。 123456% 将第一类的1-30，第二类的60-95,第三类的131-153做为训练集train_data = [wine(1:30,:);wine(60:95,:);wine(131:153,:)];train_label = [wine_labels(1:30);wine_labels(60:95);wine_labels(131:153)];% 将第一类的31-59,第二类的96-130,第三类的154-178做为测试集test_data = [wine(31:59,:);wine(96:130,:);wine(154:178,:)];test_label = [wine_labels(31:59);wine_labels(96:130);wine_labels(154:178)]; 数据归一化归一化的目的就是使得预处理的数据被限定在一定的范围内比如[0,1]或者[-1,1]，从而消除奇异样本数据导致的不良影响。如果不进行归一化，那么由于特征向量中不同特征的取值相差较大，会导致目标函数变“扁”。这样在进行梯度下降的时候，梯度的方向就会偏离最小值的方向，走很多弯路，即训练时间过长。在本实验中使用的数据归一化的方法是mapminmax方法，这是MATLAB自带的归一化函数。在这里使用，用作本数据集中数据的归一化，数据预处理,将训练集和测试集归一化到[0,1]区间。 数据归一化方法如下： 1234567[mtrain,ntrain] = size(train_data);[mtest,ntest] = size(test_data);dataset = [train_data;test_data];[dataset_scale,ps] = mapminmax(dataset',0,1);dataset_scale = dataset_scale';train_data = dataset_scale(1:mtrain,:);test_data = dataset_scale( (mtrain+1):(mtrain+mtest),: ); 归一化之后的数据形式如下：归一化后训练集：归一化后测试集：归一化是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量。归一化为了加快训练网络的收敛性，以上是对数据归一化之后的展示。 （2）KNN过程123456789101112核心代码，% 选定训练集和测试集% 将第一类的1-30,第二类的60-95,第三类的131-153做为训练集train_data = [wine(1:30,:);wine(60:95,:);wine(131:153,:)];train_label = [wine_labels(1:30);wine_labels(60:95);wine_labels(131:153)];% 将第一类的31-59,第二类的96-130,第三类的154-178做为测试集test_data = [wine(31:59,:);wine(96:130,:);wine(154:178,:)];test_label = [wine_labels(31:59);wine_labels(96:130);wine_labels(154:178)]; mdl = ClassificationKNN.fit(train_data,train_label,'NumNeighbors',1);predict_label = predict(mdl, test_data);accuracy = length(find(predict_label == test_label))/length(test_label)*100 程序运行之后，生成的预测标签如下，左侧为预测分类标签，右侧为实际测试分类标签。 )1）未进行数据归一化我使用Matlab中的KNN算法进行数据集的分析与实验。首先是未进行数据归一化的数据结果。 分类准确率为70.7865%。 2）数据归一化通过上述分类结果我们发现，正确率只有百分之70左右，分类结果正确率比较低。然后，我使用mapminmax方法对数据进行归一化，归一化之后的数据结果如下所示。 1.5.3 实验结果与分析为了更加直观的看到数据效果，对分类结果使用饼状图，以及曲面图进行展示，提供数据的可视化效果。这里展示的是数据归一化之后的分类结果。 分类结果在曲面图上展示如下： 1.6 SVM算法分类实现1.6.1 SVM算法描述SVM（support Vector Mac）又称为支持向量机，是一种二分类的模型。支持向量机可以分为线性核非线性两大类。支持向量机的主要思想是建立一个最优决策超平面，使得该平面两侧距离该平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力。对于一个多维的样本集，系统随机产生一个超平面并不断移动，对样本进行分类，直到训练样本中属于不同类别的样本点正好位于该超平面的两侧，满足该条件的超平面可能有很多个，SVM正式在保证分类精度的同时，寻找到这样一个超平面，使得超平面两侧的空白区域最大化，从而实现对线性可分样本的最优分类。SVM的核心思想可以概括为两点：（1）它是针对线性可分情况进行分析，对于线性不可分的情况，通过使用非线性映射算法将低维输入空间线性不可分的样本转化为高维特征空间使其线性可分，从而使得高维特征空间采用线性算法对样本的非线性特征进行线性分析成为可能。（2）它基于结构风险最小化理论之上再特征空间中构建最优超平面，使得学习器得到全局最优化，并且在整个样本空间的期望以某个概率满足一定上界。 1.6.2 SVM实验设计（1）数据集的划分在本实验中，数据集测试集和预测集的划分依旧使用的是上一节中的划分方法。将第一类的1-30,第二类的60-95,第三类的131-153做为训练集，相应的训练集的标签也分离出来，将第一类的31-59,第二类的96-130,第三类的154-178做为测试集，相应的测试集的标签也要分离出来。（2）数据可视化为了更加直观的看数据集中数据的分布情况，首先画出测试数据的分维可视化图进行数据情况展示。 从上面三个图中，我们可以看到数据集中数据的分布情况，各个属性范围的取值情况，但是我们并不能直观的得出分类结果，所以我们需要对数据进行更进一步的分析。 （3）数据归一化 123456789归一化代码：% 数据预处理,将训练集和测试集归一化到[0,1]区间[mtrain,ntrain] = size(train_wine);[mtest,ntest] = size(test_wine);dataset = [train_wine;test_wine];[dataset_scale,ps] = mapminmax(dataset',0,1);dataset_scale = dataset_scale';train_wine = dataset_scale(1:mtrain,:);test_wine = dataset_scale( (mtrain+1):(mtrain+mtest),: ); 1234567891011121314151617%% SVM网络训练%% SVM网络训练model = libsvmtrain(train_wine_labels, train_wine, '-c 2 -g 1');%% SVM网络预测[predict_label, accuracy, libsvm_options] = libsvmpredict(test_wine_labels, test_wine, model);%% 结果分析 % 测试集的实际分类和预测分类图figure;hold on;plot(test_wine_labels,'X');plot(predict_label,'r*');xlabel('测试集样本','FontSize',12);ylabel('类别标签','FontSize',12);legend('实际测试集分类','预测测试集分类');title('测试集的实际分类和预测分类图','FontSize',12);grid on; 1.6.3 结果分析与展示运行结果：运行以上程序，我们可以发现如果不使用数据归一化对数据进行处理分类正确率只有39%。 由以上散点图可以看出，分类结果偏差较大，分类正确率很低。数据分类存在很大的失误率。 数据归一化之后： 使用SVM的分类正确率为98.8764%。 在以上图中，红色部分代表预测测试数据集分类，X代表实际测试集分类结果，从图中我们可以直观的看出，只有一个预测数据分类错误，其余基本吻合分类结果。由以上结果我们可以看出，SVM在该数据集的分类中的分类效果要好于KNN算法的分类效果。可能是由于该数据集的样本量较少，SVM算法可以解决小样本情况下的机器学习问题，提高泛化性能，可以避免神经网络结构选择和局部极小点问题。 如有问题，欢迎留言或者邮箱。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"SVM","slug":"SVM","permalink":"http://yoursite.com/tags/SVM/"},{"name":"MATLAB","slug":"MATLAB","permalink":"http://yoursite.com/tags/MATLAB/"}]},{"title":"BP神经网络与KNN分类算法（ILPD数据集）","slug":"2019-11-10-BP神经网络与KNN分类算法","date":"2019-11-10T11:56:32.000Z","updated":"2021-05-16T11:04:06.707Z","comments":true,"path":"2019/11/10/2019-11-10-BP神经网络与KNN分类算法/","link":"","permalink":"http://yoursite.com/2019/11/10/2019-11-10-BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8EKNN%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95/","excerpt":"ILPD数据集ILPD数据集来自美国加州大学一个统计学习相关的网站上（UCI）数据集的名称叫做Indian Liver Patient Dataset印度肝病患者数据集，这个数据集由三个印度的教授收集自印度安得拉邦的东北部，包含了416个肝癌病人和167个非肝癌病人共计583个肝病患者的病历数据记录。583个病人中包含441名男性病人和142名女性病人，其中任何年龄超过89岁的患者都被列为年龄90。","text":"ILPD数据集ILPD数据集来自美国加州大学一个统计学习相关的网站上（UCI）数据集的名称叫做Indian Liver Patient Dataset印度肝病患者数据集，这个数据集由三个印度的教授收集自印度安得拉邦的东北部，包含了416个肝癌病人和167个非肝癌病人共计583个肝病患者的病历数据记录。583个病人中包含441名男性病人和142名女性病人，其中任何年龄超过89岁的患者都被列为年龄90。 ILPD数据集属性描述在ILPD数据集中，该数据集包含416个肝脏患者记录和167个非肝脏患者记录。共计10个主要属性，以及583个样本数，里面有肝病患者和非肝病患者的记录。具体属性描述如下表： 原始数据集展示该数据集是一个CSV格式的数据文件，一共有538行11列数据。下图是对原始数据集的前25条数据展示： 数据的第一列代表患者年龄，第二列为患者性别。在这里性别是一个字符串形式的表示，我们在下面的数据分析中需要把数据转换为离散型的数据表示，可以方便我们的数据分析。数据的最后一行表示是否患病，1表示肝癌病人，2表示非肝癌病人。 数据处理首先进行数据的简单预处理，进行偏差检测，即检查导致偏差的因素，并识别离散值与噪声值。然后进行数据清洗，即处理缺失值与噪声，通过观察数据集我们可以发现在数据集的第二列，性别表示中男性是male表示，女性是female表示，为了能让提高我们的分类准确率，这里需要进行替换，男性male用1表示，female用2来表示。处理后的数据集表示如下： 1. BP（反向传播）算法实现BP算法描述BP算法（Back-propagation），误差反向传播算法，它的基本思想：学习过程由信号的正向传播（求损失）与误差的反向传播（误差回传）两个过程组成。网络的运行流程为：当输入一个样例后，获得该样例的特征向量，再根据权向量得到感知器的输入值，然后使用函数计算出每个感知器的输出，再将此输出作为下一层感知器的输入，依次类推，直到输出层。在多层的神经网络中，误差曲面可能有多个局部极小值，这意味着使用梯度下降算法找到的可能是局部极小值，而不是全局最小值。现在可以使用损失函数，这时可以根据损失函数来调整输出结点中的输入权向量，采用随机梯度下降算法求解，然后从后向前逐层调整权重，这就是反向传播算法计算的大致流程。BP算法是一种有监督式的学习算法，其主要步骤是是输入学习样本，使用反向传播算法对网络的权值和偏差进行反复的调整训练，使输出的向量与期望向量尽可能地接近，当网络输出层的误差平方和小于指定的误差时训练完成，保存网络的权值和偏差。具体步骤如下：（1）初始化，随机给定各连接权[w],[v]及阈值θi，rt。（2）由给定的输入输出模式对计算隐层、输出层各单元输出bj=f（wijai-θj） ct=f（vjtbj－rt）式中：bj为隐层第j个神经元实际输出；ct为输出层第t个神经元的实际输出；wij为输入层至隐层的连接权；vjt为隐层至输出层的连接权。dtk=（ytk－ct）ct（1－ct） ejk=[dtvjt] bj（1－bj）（3）选取下一个输入模式对返回第2步反复训练直到网络设输出误差达到要求结束训练。 实验设计（1）数据集划分在本数据集中，一共有538条数据，采用前400条数据进行参数训练，后138条数据进行测试数据。 1234567%读取训练数据[NUM]=xlsread('shujv','A1:K400')[A]=xlsread('shujv','A1:J400')%读取测试数据[NUMT]=xlsread('shujv','A401:K583')[C]=xlsread('shujv','A401:J583') （2）算法步骤将前400条数据作为输入，即（患者的年龄、患者的 性别性别、TB总胆红素 、DB直接胆红素、碱性磷酸酶、氨基转移酶、天冬氨酸氨基转移酶、TP总标本、ALB白蛋白 、A / G比率白蛋白和球蛋白比率）。将对应的分类结果作为输出。并用matlab自带的premnmx()函数将这些数据归一化处理。 12%特征值归一化 [input,minI,maxI] = premnmx( [A ]') ; 通过样本数据的训练，不断修正网络权值和阈值使误差函数沿负梯度方向下降，逼近期望输出。归一化之后欧的数据形式如下： 训练集归一化：测试集归一化：输入输出： 该模型由每组数据的各项指标作为输入，以分类结果作为输出输入层的节点数为10，输出层的节点数为1。隐含层设计:IW = net.IW{1,1};LW = net.LW{2,1};b1 = net.b{1}b2 = net.b{2}net是训练得到的网络，IW表示隐含层的权矩阵，维数 = 隐含层神经元个数 * 特征数，LW表示隐含层权矩阵，维数 = 1 * 隐含层神经元个数，b1输入层的阈值，b2隐含层的阈值。输入输入以及隐含层的设计如下图： 激励函数： BP神经网络通常采用Sigmoid可微函数和线性函数作为网络的激励函数。本文选择S型正切函数tansig作为隐层神经元的激励函数。而由于网络的输出归一到[ -1, 1]范围内, 因此预测模型选取S 型对数函数tansig作为输出层神经元的激励函数。代码如下： 123out1 =1./(1+exp(-n1)); % tansig函数的表达式，out1表示输入层的输出结果Z = (LW * out1) + repmat(b2,1,size(testInput,2)); out2 =1./(1+exp(-Z)); % tansig函数的表达式，out2表示输入层的输出结果 将训练样本数据归一化后输入网络, 设定网络隐层和输出层激励函数分别为tansig, 网络训练函数为traingdx, 网络性能函数为mse,隐层神经元数初设为4。设定网络参数： 网络迭代次数epochs为10000次, 期望误差goal为0.01, 学习速率lr为0.01，设置完毕，开始训练。 1234%设置训练参数net.trainparam.epochs = 10000 ;net.trainparam.goal = 0.01 ;net.trainParam.lr = 0.01 ; 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[NUM]=xlsread('shujv','A1:K400')[A]=xlsread('shujv','A1:J400') %特征值归一化[input,minI,maxI] = premnmx( [A ]') ;%构造输出矩阵s = size(A,1);output = zeros( s , 5 ) ;for i = 1 : s output( i , NUM(i,11)) = 1 ;end %创建神经网络net = newff( minmax(input) , [55 5] , &#123; 'logsig' 'logsig' &#125; , 'traingdx' ) ; %设置训练参数net.trainparam.show = 25 ;net.trainparam.epochs = 10000 ;net.trainparam.goal = 0.01 ;net.trainParam.lr = 0.01 ; %开始训练net = train( net, input , output' ) ; %读取测试数据[NUMT]=xlsread('shujv','A401:K583')[C]=xlsread('shujv','A401:J583')%测试数据归一化testInput = tramnmx ( [C]' , minI, maxI ) ; %仿真Y = sim( net , testInput ) IW = net.IW&#123;1,1&#125;; % net是训练得到的网络，IW表示隐含层的权矩阵 % 维数 = 隐含层神经元个数 * 特征数LW = net.LW&#123;2,1&#125;; % LW表示隐含层权矩阵，维数 = 1 * 隐含层神经元个数b1 = net.b&#123;1&#125; % 输入层的阈值b2 = net.b&#123;2&#125; % 隐含层的阈值t=size(testInput,2)u=IW * testInput;n1 = (IW * testInput) + repmat(b1,1,size(testInput,2));out1 =1./(1+exp(-n1)); % tansig函数的表达式，out1表示输入层的输出结果Z = (LW * out1) + repmat(b2,1,size(testInput,2)); % purelin函数就是形如 y = x，所以直接可以得到out2out2 =1./(1+exp(-Z)); % tansig函数的表达式，out1表示输入层的输出结果out3=(1./(1+exp(-LW))) * (1./(1+exp(- IW)));C= LW * IW;out4=1./(1+exp(-C));%统计识别正确率[s1 , s2] = size( Y ) ;hitNum = 0 ;for i = 1 : s2 [m , Index] = max( Y( : , i ) ) ; if( Index == NUMT(i,11) ) hitNum = hitNum + 1 ; endendsprintf('分类识别率是 %3.3f%%',100 * hitNum / s2 ) 实验结果分析网络训练完成后，进行测试集测试训练结果，与分类的正确率。实验结果：网络输出误差与训练状态图 网络训练误差图 网络训练状态 2. KNN算法分类KNN算法步骤KNN的算法原理描述与算法执行流程，我们在上一章的1.5章节已经介绍过，在这里不再重复介绍。本章节主要是KNN算法在印度肝病分类实验中的应用与分类效果。KNN算法在分析印度肝病患者数据集时的具体算法步骤如下：1）计算测试数据与各个训练数据之间的距离，也就是计算数据集中前400条训练数据与138条数据中各个属性之间的距离。2）按照距离的递增关系进行排序，然后进行后续的坐标点的选择。3）选取距离最小的K个点；4）确定前K个点所在类别的出现频率；5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。 实验设计（1）数据集分类前400行前10列作为训练数据，第11列作为测试标签，后138行前10列作为测试属性，后138行第11列作为测试标签。[NUM]=xlsread(‘shujv’,’A1:J400’)[A]=xlsread(‘shujv’,’K1:K400’) %读取测试数据[NUMT]=xlsread(‘shujv’,’A401:J538’)[C]=xlsread(‘shujv’,’K401:K538’) （2）数据归一化[mtrain,ntrain] = size(NUM);[mtest,ntest] = size(NUMT);dataset = [NUM;NUMT];[dataset_scale,ps] = mapminmax(dataset’,0,1);dataset_scale = dataset_scale’;train_data = dataset_scale(1:mtrain,:);test_data = dataset_scale( (mtrain+1):(mtrain+mtest),: ); （3）算法代码[NUM]=xlsread(‘shujv’,’A1:J400’)[A]=xlsread(‘shujv’,’K1:K400’)[NUMT]=xlsread(‘shujv’,’A401:J538’)[C]=xlsread(‘shujv’,’K401:K538’) mdl = ClassificationKNN.fit(NUM,A,’NumNeighbors’,1);predict_label = predict(mdl, NUMT);accuracy = length(find(predict_label == C))/length(C)100*测试分类标签和预测分类标签。（左侧为测试分类标签，右侧为预测分类标签）** 实验结果正确率：正确率 = 预测标签 / 测试标签accuracy = length(find(predict_label == C))/length(C)*100 由实验结果可以看出来印度肝病患者这个数据集用BP网络训练的模型，分类的准确率更高。KNN自身的优点具有：计算简单，易于理解，可解释性强；比较适合处理有缺失属性的样本；能够处理不相关的特征；在相对短的时间内能够对大型数据源做出可行且效果良好的结果。缺点是往往忽略了数据之间的相关性；BP神经网络实质上实现了一个从输入到输出的映射功能，数学理论证明三层的神经网络就能够以任意精度逼近任何非线性连续函数。这使得其特别适合于求解内部机制复杂的问题，即BP神经网络具有较强的非线性映射能力。BP神经网络在其局部的或者部分的神经元受到破坏后对全局的训练结果不会造成很大的影响，也就是说即使系统在受到局部损伤时还是可以正常工作的。即BP神经网络具有一定的容错能力。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"BP","slug":"BP","permalink":"http://yoursite.com/tags/BP/"},{"name":"KNN","slug":"KNN","permalink":"http://yoursite.com/tags/KNN/"}]},{"title":"递归算法及经典递归实现","slug":"递归算法及经典递归实现","date":"2019-08-10T02:20:32.000Z","updated":"2021-05-16T11:04:06.718Z","comments":true,"path":"2019/08/10/递归算法及经典递归实现/","link":"","permalink":"http://yoursite.com/2019/08/10/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%8F%8A%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/","excerpt":"# 递归 递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。 递归： 在定义自身的同时又出现了对自身的调用直接递归函数： 在定义函数体中直接调用自己间接递归函数： 一个函数经过一系列中间调用语句，通过其他函数调用自己，如P调用Q，Q再调用P","text":"# 递归 递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。 递归： 在定义自身的同时又出现了对自身的调用直接递归函数： 在定义函数体中直接调用自己间接递归函数： 一个函数经过一系列中间调用语句，通过其他函数调用自己，如P调用Q，Q再调用P 使用 递归算法的 前提有两个：（1） 原问题可以层层分解为类似的子问题，且子问题比原问题的规模更小。（2）规模更小的子问题具有直接解 设计递归算法的原则是用自身的简单情况来定义自身设计递归算法的方法是：（1）寻找分解方法，将原问题转化为子问题求解（2）设计递归出口，也就是说根据最小的子问题，确定递归终止的条件。 递归过程的实现递归的过程 ，递归进程和递归退层。 递归进程，也就是说递归的过程 i 到 i+1 层，系统需要做三件工作：（1）保留本层参数与返回地址；（2）给下层参数赋值（3）将程序转移到被掉函数的入口 递归退层：也就是从i+1层到i层，系统也应该完成三件工作（1）保留被调函数的计算结果（2）恢复上层参数，也就是释放被调函数的数据区（3）依照被调函数保存的返回地址，将控制转移回调用函数。、 递归函数的运行，以及递归中进层退层的实现，都需要递归机制的支持。 什么是递归机制？递归机制支持？系统设置一个递归工作栈作为递归函数运行使用的存储区，每次递归需要所需信息构成一个工作记录，包括实参，局部变量以及上一层的返回地址。每进入一层递归，就产生一个新的工作记录压入栈顶，每退出一层递归，就从栈顶弹出一个工作记录。 我们可以通过一个简单的阶乘例子来看一下递归调用机制的过程。 12345678910111213141516package com.recusion;public class printDemo &#123; public static void main(String[] args) &#123; test(4); &#125; public static void test(int n)&#123; if (n&gt;2) &#123; test(n-1); &#125; System.out.println(\"n=\"+n); &#125; &#125; 当我们的程序执行的时候，首先进入的是主方法。具体过程我们可以通过虚拟机的调用顺序来看一下详细过程 Java虚拟机主要分成三个部分：栈空间，堆空间，另外还有一个空间是代码区包括常量我们的程序执行到主方法的时候，会首先在栈中开辟一个空间 ，这个空间我们可以叫做main[ 栈 ]，在这里面调用了 test(4),根据调用规则，会另外开辟新栈。n=4 ，会进行判断，n&gt;2时，又执行test(3) ，当执行到这里的时候，下面的代码不会执行，仍然会开辟一个新的栈，继续进行判断，test（2），进行判断，然后继续开辟新的栈。继续判断，不符合之后会执行下面的指令。（会首先执行顶级的栈）所以首先会在控制台输出n=2，执行完之后弹出，继续执行下面的栈。 执行过程：图解如下 递归调用规则： 当程序执行到一个方法时，就会开辟一个独立的空间(栈) 每个空间的数据（局部变量）是独立的，由上面的过程我们可以发现，在每一个栈中，我们都有一个局部变量n=4，n=3….这些局部变量之间是相互独立的。 下面我们来看一下，递归实现阶乘的例子： 12345678//阶乘问题public static int factorial(int n)&#123; if (n == 1) &#123; return 1; &#125;else &#123; return factorial(n-1)*n; &#125;&#125; 递归能解决的问题？ 各种数学问题，如8皇后，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题（Google编程大赛） 各种各种算法也会用到递归，比如归并排序，二分查找，分治算法等 将用栈解决的问题，使用递归解决比较简单 递归使用时需要遵守的重要规则递归需要在遵守的重要规则： 执行一个方法时，就是创建一个新的受保护的独立空间（栈空间） 方法的局部变量是独立的，不会相互影响，比如上面例子中的n变量，在每一个栈空间中是独立的。 如果方法中使用的是引用类型变量，比如说是数组，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归，进入死循环。 当一个方法执行完毕，或者是遇到return。就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 递归经典算法迷宫问题迷宫问题说明：1）小球得到的路径，和程序员设置的找路策略有关，即找路的上下左右的顺序相关2）再提到小球路径时，可以先使用（下右上左），再改成（上右下左），看看路径是不是有变3）测试回溯现象 小球得到的路径，和程序设置的找路径策略有关：即找路的上下左右的顺序有关，在得到小球的路径时，可以先使用 下-右—上–左 ，如果不行再改用 上–右–下–左 ， 看看路径是不是有变化，测试回溯现象（我们可以多增加几个墙，这样可以测试回溯现象）。 Q：如何求出最短的路径？ 我们可以使用递归进行实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.recusion;public class MiGong &#123; public static void main(String[] args) &#123; //先创建一个二维数组，模拟迷宫 //写一个地图，用二维数组表示地图8行7列的二维数组 int[][] map = new int[8][7]; //在地图中我们使用1表示墙 //上下全部置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] =1; map[7][i] =1; &#125; //左右全部置为1 for(int i = 0; i &lt; 8;i++)&#123; map[i][0] = 1; map[i][6] = 1; &#125; map[3][1]=1; map[3][2]=1; //输出地图 for(int i = 0;i&lt;8;i++)&#123; for(int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+\" \"); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 setWay(map, 1, 1); //输出地图，小球走过，并标识过的地图 System.out.println(\"地图的情况，走过标记过的地图\"); for(int i = 0;i&lt;8;i++)&#123; for(int j=0;j&lt;7;j++)&#123; System.out.print(map[i][j]+\" \"); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1. map 表示地图 //2. i,j 表示从地图的哪个地方开始出发（1,1） //3. 如果小球能到 map[6][5] 位置，则说明通路找到 //4. 约定：当map[i][j] 为0表示该点没有走过，当为1表示墙,当为2时是通路可以走的，为3表示该位置已经走过但是走不通 //5. 在走迷宫时需要确定一个策略，也就是一个规则，先走下面，下面不同，再走右面，右面不同在走上面，上面不通，再走左面。如果该点走不通，再回溯 /** * 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 1 1 1 1 1 1 1 1 */ /** * map表示地图 * i，j表示从 哪个位置开始找 * 如果找到通路返回true，如果找不到返回false * @return */ public static boolean setWay(int[][] map,int i,int j)&#123; if(map[6][5] ==2 )&#123; return true; &#125;else &#123; if (map[i][j] == 0) &#123;//如果当前点还没有走过 //按照策略走 map[i][j] = 2;//假定该点可以走通 if (setWay(map, i+1, j)) &#123;//先向下走 return true; &#125;else if (setWay(map, i, j+1)) &#123;//向右走 return true; &#125;else if(setWay(map, i-1, j))&#123;//向上走 return true; &#125;else if(setWay(map, i, j-1))&#123;//向左走 return true; &#125;else &#123; //下右上左都走不通，说明这个点是不同的， map[i][j]=3; //标记为此路不同别走 return false; &#125; &#125;else&#123;//如果该点不等于0，map可能是1,2,3 1表示墙，2 走过了 3 是死路 return false; &#125; &#125; &#125; &#125; 递归经典算法八皇后问题：回溯算法八皇后问题介绍;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。在8*8格的国家象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行，同一列，或者是同一斜线上，问有多少中摆法？解法：我们可以使用回溯法进行解决。 八皇后问题算法思路分析：（1） 第一个皇后先放第一行第一列（2） 第二个皇后放在第二行的第二列，然后判断是否OK，即是判断是否冲突，如果不OK，继续放在第二列，第三列，依次把所有的列都放完，找到一个合适的。（3） 继续第三个皇后，还是第一列，第二列…..直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解。（4）当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解全部得到。（5）然后回头继续将第一个皇后放到第二列，后面继续循环执行1,2,3的步骤 需要说明的是，理论上需要创建一个二维数组表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。（也就是经过分析，我们先找出一个可能的解，在每一行中填上数组的下标，当前位置表示已经放上皇后， {0,4,7,5,2,6,1,3} 表示提前在此位置上放上八个皇后）arr[8] = {0,4,7,5,2,6,1,3} 对应的数组下标表示的是第几行，即第几个皇后，arr[i] = val ， val表示第i+1个皇后，放在第i+1行的第val+1列。 编程思路： 定义一个数组，用于保存皇后放置位置的结果，比如 arr = {0， 4 ，7，5，2，6，1，3} 编写一个方法，放置第n个皇后check()， 查看当我们放置第n个皇后，就去检测该皇后和前面已经摆放好的皇后冲突 【说明】【n 表示第n个皇后，n从0开始，arr[i] = val val的值表示第几个皇后，例如 {0,4,7,5,2,6,1,3} 中，4表示第2个皇后在第四列。（通过在这里我们可以发现，arr数组中里面存放的是列数，然后arr[n] 代表的是这个皇后在的列数 ）我们需要进行位置 判断，首先判断两个元素是否是在同一行，然后进行是否在同一行进行判断，但是我们提前定义数组的时候，使用的是一维数组表示位置，按照这种方法定义，我们就可以使用array[i] == array[n] 进行是否值在同一行进行判断。然后还需要判断是否是在同一列进行判断，使用两个位置连线的斜率绝对值等于1进行判断 】 写一个方法，可以将皇后摆放的位置输出代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.recusion;public class Queen8 &#123; //首先定义表示共有多少个皇后 int max =8; static int count=0;//用于统计总方案数 //定义数组array，保存皇后放置位置的结果，比如 arr = &#123;0,4,7,5,2,6,1,3&#125; int[] array = new int[8]; public static void main(String[] args) &#123; Queen8 queen8 = new Queen8(); queen8.check(0); System.out.println(\"一共有解法\"+count); &#125; // 放置皇后，编写一个方法，放置第n个皇后 //特别注意，check是每一次递归时，进入到check中都有一套for循环for (int i = 0; i &lt; max; i++) 因此会有回溯 private void check(int n)&#123; if (n==max) &#123; //n=8表示放置到第九个皇后，8个皇后已经放好 print(); return; &#125; //依次放入皇后，并判断是否是冲突的 for (int i = 0; i &lt; max; i++) &#123; array[n]=i; //判断当放置第n个皇后到i列时，判断是否是冲突的 if (judge(n)) &#123; //接着放n+1个皇后，即开始递归 check(n+1); //如果有8个皇后，每一层都会遍历8个列，会产生回溯现象的 &#125; //如果冲突，就继续执行array[n] =i ;即将第n个皇后，放置在本行的后移一个位置 &#125; &#125; //检测位置 编写方法，当我们放置第n个皇后时，就去检测该皇后是否和前面已经摆放好的皇后位置是否冲突 /** * n 表示第几个皇后 * @param n * @return */ private boolean judge(int n)&#123; for(int i=0;i&lt;n;i++)&#123; /** * 说明 * 1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 * 2. Math.abs(n-i)== Math.abs(array[n]-array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线上 * n = 1 放置第二列为1， n=1时，array[1]=1 * Math.abs(1-0) ==1 Math.abs(array[n]-array[i]) = Math.abs(1-0) =1 * 3. 判断是否在同一行，这一个不用判断，因为for循环中直接限制过了，没有必要进行判断了 */ if (array[i]==array[n] || Math.abs(n-i)== Math.abs(array[n]-array[i])) &#123; return false; &#125; &#125; return true; &#125; //写一个打印数据，也就是皇后放置位置的方法 private void print()&#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i]+\" \"); &#125; System.out.println(); &#125; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归算法","slug":"递归算法","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构--栈","slug":"数据结构-栈","date":"2019-07-16T02:20:32.000Z","updated":"2021-05-16T11:04:06.716Z","comments":true,"path":"2019/07/16/数据结构-栈/","link":"","permalink":"http://yoursite.com/2019/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/","excerpt":"1. 栈栈是指允许在一端就行插入或删除操作的线性表，首先需要确定的是栈是一种线性表。 1)栈的英文为 (stack) 2)栈是一个先入后出 (FILO first In Last Ou的有序列表 3)( stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端,为变化的一端,称为機项(Top),另端为固定的一端,称为底( Bottom) 4)根据栈的定义可知,最先放入中元素在機底,最后放入的元素在项,而除元素刚好相反,最后放入的元素最先删除,最先放入的元素最后删除","text":"1. 栈栈是指允许在一端就行插入或删除操作的线性表，首先需要确定的是栈是一种线性表。 1)栈的英文为 (stack) 2)栈是一个先入后出 (FILO first In Last Ou的有序列表 3)( stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端,为变化的一端,称为機项(Top),另端为固定的一端,称为底( Bottom) 4)根据栈的定义可知,最先放入中元素在機底,最后放入的元素在项,而除元素刚好相反,最后放入的元素最先删除,最先放入的元素最后删除 栈的应用场景1)子程序的调用:在跳往子程序前,会先将下个指令的地址存到堆栈中,直到子程序执行完后再将地址取出,以回到原来的程序中。 2)处理递归调用:和子程序的调用类似,只是除了備存下一个指令的地址外也将参数、区域变量等数据存入堆栈中。 3)表达式的转换与求值(实际解决)。 4)二叉树的遍历。 5)图形的深度优先{ depth- first)搜素法。 ##栈的实现 栈的顺序存储称为顺序栈，它是利用一组地址连续的存储单元存放自栈底到栈顶的数据元素 使用Java语言对栈进行一个简单实现 用数组模拟栈的使用，由于栈是一种有序表，当然可以使用数据的结构来存储栈的内容、 【思路分析】 使用数组模拟栈 定义变量top表示栈顶，初始化为-1 入栈，当有数据加入栈时，top++。stack（top）=data 出栈，从栈顶取出数据，定义变量value用来存储栈顶的数据，然后把top–，return value 需要注意的是，入栈是栈顶元素先top++，再放数据。出栈是先取数据，再top–。用Java定义一个栈，并定义栈中的各种操作方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//定义一个ArrayStack 表示栈class ArrayStack&#123; private int maxSize; //栈的大小 private int[] stack; //数组，数组模拟栈，数据放在该数组中 private int top = -1; // top表示栈顶，初始化为1 //构造方法 public ArrayStack(int maxSize)&#123; this.maxSize = maxSize; stack = new int[this.maxSize]; //我们上面定义完数组，没有进行初始化，我们需要进行初始化 &#125; //判断沾满的方法 public boolean isFull()&#123; return top == maxSize - 1; &#125; //判断栈空的方法 public boolean isEmpty()&#123; return top == -1; &#125; //入栈的操作 public void push(int value)&#123; if (isFull()) &#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; //出栈的操作，将栈顶的数据返回 public int pop()&#123; if (isEmpty()) &#123; System.out.println(\"栈空\"); new IllegalArgumentException(\"栈空,没有数据\"); &#125; int value = stack[top]; top--; return value; &#125; //遍历栈，需要从栈顶往下遍历 public void list()&#123; if (isEmpty()) &#123; System.out.println(\"栈空\"); return; &#125; for (int i = top; i &gt;=0; i--) &#123; System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]); &#125; &#125; &#125; 编写测试方法，测试操作能否正常执行 1234567891011121314public static void main(String[] args) &#123; //测试栈 //先创建一个ArrayStack对象，表示栈 ArrayStack stack = new ArrayStack(4); stack.push(2); stack.push(3); stack.push(6); stack.list(); System.out.println(stack.pop()); stack.list(); &#125; 我们使用一个计算的式子计算过程来进一步了解栈的实际应用。 eg：使用栈完成计算一个表达式的结果：722-5+1-5+3-4=？ 我们需要定义两个栈，一个是数据栈numStack，用来存放计算式中数据。一个是符号栈，用来存放计算式中的符号。 使用栈完成表达式的计算思路： 通过一个index值也就是索引，来遍历我们的表达式 如果我们发现当前索引值是一个数据，就直接入数栈 如果发现扫描到是一个符号，就分为以下情况进行考虑 如果发现当前的符号栈为空，就直接入栈 如果符号栈有操作符，就进行比较。如果当前的操作符的优先级小于或者是等于栈中的操作符，就需要从数据栈中pop出两个数，再从符号栈中pop出一个符号，进行运算，将计算得到的结果，放入数据栈，然后将当前的操作符放入符号栈。如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈中。 当表达式扫描完毕之后，就顺序的从符号栈和数据栈中pop出相应的数和符号，并运行。 最后数据栈之后一个数字，就是我们的计算结果。 我们根据上面的思路，使用编程实现计算上面中缀表达式的过程。 引入：中缀表达式形如上面定义的表达式 5+3-6/2 这样的式子就是中缀表达式，是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法。与前缀表达式（例：+ 3 4）或后缀表达式（例：3 4 +）相比，中缀表达式不容易被计算机解析，但仍被许多程序语言使用，因为它符合人们的普遍用法。 一般是转换为后缀表达式跟容易的计算。 ==++++++++++++++++++++++++++++++++++++++++++++++ 中缀表达式转换为后缀表达式的过程如下：后缀表达式也叫逆波兰表达式， 规则： 中缀表达式a + b*c + (d * e + f) * g，其转换成后缀表达式则为a b c * + d e * f + g * +。 转换过程需要用到栈，具体过程如下： 1）如果遇到操作数，我们就直接将其输出。 2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。 3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。 4）如果遇到任何其他的操作符，如（“+”， “*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “。 5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。 —+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 但是在实际应用时，中缀表达式是应用最多的，下面使用栈模拟计算机计算中缀表达式的过程。 要实现计算中缀表达式的过程，还要在上面我们定义的栈类中新增几个方法。 新增定义运算符优先级的方法： 返回运算符的优先级，优先级是程序员来定的，优先级使用数字表示，数字越大优先级越高。我们假定计算式中只含有加减乘除 123456789101112// 返回运算符的优先级，优先级是程序员来定的，优先级使用数字表示，数字越大优先级越高。//我们假定计算式中只含有加减乘除public int priority(int oper)&#123; if (oper == '*' || oper == '/') &#123; return 1; &#125;else if (oper == '+' || oper == '-') &#123; return 0; &#125;else &#123; return -1; &#125; &#125; 判断是否是运算符方法 1234//判断是不是一个运算符public boolean isOper(char val)&#123; return val == '+' || val == '-' || val =='*' || val == '/';&#125; 计算方法，从栈中弹出的两个数字需要进行运算 123456789101112131415161718192021222324252627//计算方法，从栈中弹出的两个数需要进行计算 public int cal(int num1,int num2,int oper)&#123; int result =0; switch (oper) &#123; case '+': result = num1 + num2; break; case '-': result = num2 - num1;//注意顺序，这里是num2是栈底元素 break; case '*': result = num1 * num2; break; case '/': result = num2 / num1; break; default: break; &#125; return result; &#125; 增加一个用于返回当前栈顶的值，不是真正的pop操作，用于进行栈顶元素的比较 1234//增加一个方法，可以返回当前栈顶的值，但不是真正的poppublic int peek()&#123; return stack[top];&#125; 下面我们进行程序的编写。 我们需要定义两个栈，一个是数据栈numStack，用来存放计算式中数据。一个是符号栈，用来存放计算式中的符号。 通过一个index值也就是索引，来遍历我们的表达式 如果我们发现当前索引值是一个数据，就直接入数栈 如果发现扫描到是一个符号，就分为以下情况进行考虑 如果发现当前的符号栈为空，就直接入栈 如果符号栈有操作符，就进行比较。如果当前的操作符的优先级小于或者是等于栈中的操作符，就需要从数据栈中pop出两个数，再从符号栈中pop出一个符号，进行运算，将计算得到的结果，放入数据栈，然后将当前的操作符放入符号栈。如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈中。 当表达式扫描完毕之后，就顺序的从符号栈和数据栈中pop出相应的数和符号，并运行。 最后数据栈之后一个数字，就是我们的计算结果。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class jisuanshi &#123; public static void main(String[] args) &#123; //根据上面的思路，进行代码的实现，完成表达式的运算过程 String expression = \"2+6*8-4\"; //创建两个栈，一个是数据栈，一个是符号栈 ArrayStack2 numStack = new ArrayStack2(20); ArrayStack2 operStack = new ArrayStack2(20); //定义需要的相关变量 int index = 0;//用于扫描 int num1 =0; int num2 =0; int oper = 0; //char和int类型是一样的 int result = 0; char ch = ' ';//将每次扫描得到char保存到ch中 //开始使用while循环的扫描expression while(true)&#123; //依次得到expression中的每个字符 ch = expression.substring(index, index+1).charAt(0); //判断ch是什么然后做相应的处理 if (operStack.isOper(ch)) &#123;//如果是运算符 //判断当前的符号栈是否为空 if (!operStack.isEmpty()) &#123; //如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就进行下面的操作 //再从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈 if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123; //从数据栈pop两个数进行计算 num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); result = numStack.cal(num1, num2, oper); //把运算结果入数栈 numStack.push(result); //然后把操作符入符号栈 operStack.push(ch); &#125;else&#123; //如果当前的操作符优先级大于栈中的操作符，就直接入符号栈 operStack.push(ch); &#125; &#125;else&#123; //如果为空直接入符号栈 operStack.push(ch); &#125; &#125;else&#123; //处理是数的情况。则直接入数据栈。因为上面把它转换为字符了，所以需要进行转换 numStack.push(ch - 48); &#125; //让index加1，并判断是否扫描到expression的最后 index++; if (index &gt;= expression.length()) &#123; break; &#125; &#125; //当表达式扫描完毕，就顺序的从数据栈和符号栈中pop出相应的数据和符号。并运算 while(true)&#123; //如果符号栈为空，则计算到最后的结果，数据栈中只有一个数字，这个就是结果 if (operStack.isEmpty()) &#123; break; &#125; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); result = numStack.cal(num1, num2, oper); numStack.push(result);//入栈 &#125; //将数据栈中最后的数pop出来，就是结果 int res2 = numStack.pop(); System.out.printf(\"表达式%s = %d\", expression,res2); &#125; &#125; 运算结果：表达式2+6*8-4 = 46","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/%E6%A0%88/"}]},{"title":"数据结构--线性表","slug":"数据结构-线性表","date":"2019-07-10T02:20:32.000Z","updated":"2021-05-16T11:04:06.716Z","comments":true,"path":"2019/07/10/数据结构-线性表/","link":"","permalink":"http://yoursite.com/2019/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"线性结构是最简单最直接的数据关系，数据元素之间一一对应。","text":"线性结构是最简单最直接的数据关系，数据元素之间一一对应。 线性表的概念线性表是由n个类型相同数据元素的有限序列。 线性表的特点： 同一性：线性表是由同类数据元素组成的，每一个a必须是同一数据对象 有穷性：线性表是由有限个数据元素组成，表长度就是表中数据元素的个数 有序性：线性表中相邻数据元素之间存在着序偶关系抽象数据类型的使用： 由于抽象数据类型定义了相应模型上的基本 运算集，可如同使用整形类型的加减乘除运算集合一样，只要列出线性表抽象数据类型LinearList 就可以直接使用其上的基本运算集 抽象数据类型的使用：抽象数据类型一经定义，就可以多次使用在实际问题中可利用线性表抽象数据类型的9种基本运算的组合实现对线性表进行合并、分拆、排序等多种需求。 1、线性结构的特点 线性结构是最简单、最基本的结构，数据元素间是一一对应关系。 2、线性表定义 是由n个数据元素的有限序列。除第一个和最后一个元素以外，其余的每个元素都只有唯一的直接前驱和直接后继。 3、线性表抽象数据类型定义 线性表ADT包括抽象数据类型的名称及数据元素、结构关系、基本操作集合三部分。 线性表的顺序存储结构节点顺序存，节点线性化 类型和变量的区别： 例如：两室一厅就是一个类型的定义，是一个类型是一个规格，这样301,302 这种门牌号都可以使具有这种规格的空间，这就是变量。 自定义类型定义了一种规格，如顺序表的数据类型定义SeqList typedef struct { ElemType elem[MAXSIZE] //线性表占用的数组空间 int last; //线性表的最后一个元素在数组中的位置下标 }SeqList;(2)变量是规格类型的具体空间,两种定义方式 将L定义为 Seql list:类型的变量,如 Seqlist L 将顺序表定义为一个变量。使用的时候我们可通过属性访问方式L.elem[i-1]访问顺序表中序号为i的元素ai。 将L定义为指向 Seqlist类型的指针变量,如 SeqList *L 可通过指针访问方式L-&gt;elem[i-1]访问顺序表中序号为i的元素ai。 类型是一种规格的定义，而变量是一种空间的定义。 线性表的基本运算增删改查 在上面的定义中，我们通过一个结构体，进行了一个简单线性表的定义，我们在C语言或者C++z中可以通过一个结构体来进行定义，在Java中没有结构体，我么可以通过一个类来进行线性表的表示。 使用Java语言先定义一个线性表 ，然后我们再定义其中的基本操作 Java JDK中有ArrayList和LinkedList两个类很好的实现了顺序存储和链式存储。因此学习数据结构的最好方式是去研究JDK源码。 我们可以看一下Java中ArrayList和LinkedList的区别： ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。ArrayList是数组队列，相当于动态数组；LinkedList为双向链表结构，也可当作堆栈、队列、双端队列 当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。 当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。 从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 下面使用Java实现一个顺序表 首先定义一个线性表，并定义线性表中的插入删除的相关的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.shunxubiao;/*** * * @author lei * */public class MyArrayList &#123; //定义一个用来保存数据的数组 private Object arr[]; //定义一个空数组，用来初始化空数组 private Object[] DEFAULT_EMPTY = &#123;&#125;; //数组的初始容量，我们可以参照ArrayList源码，数组的初始容量为10 private static final int DEFAULT_SIZE = 10; //数组的大小,也就是数组的最大容量 private int maxSize; //定义线性表的大小，线性表的当前个数 private int size; //带参构造方法，提供能构造指定容量的空列表 public MyArrayList(int inittalSize)&#123; if (inittalSize &gt; 0) &#123; this.arr = new Object[inittalSize]; this.maxSize = inittalSize; &#125;else if (inittalSize == 0) &#123; this.arr = DEFAULT_EMPTY; &#125;else &#123; throw new IllegalArgumentException(\"不能为负，非法容量\"+inittalSize); &#125; &#125; //空参构造，用来初始化一个空数组 public MyArrayList()&#123; this.arr = DEFAULT_EMPTY; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 //往线性表中指定位置插入数据//在指定位置插入元素，首先就是需要判断插入位置是否正确，然后判断数组长度是否越界，//如果已经满了我们需要重新增加数组的长度，一般是增加1.5倍长度，ArrayList JDK源码中也是增加1.5倍的数组长度。//然后移动数组元素，空出需要插入的位置，最后把数据插入到数组中。 //在数组的指定位置插入元素。public void insert(int i,Object elem)&#123; //首先判断数组插入的位置是否合法 if (i &lt; 0) &#123; new IllegalArgumentException(\"插入位置不合法\"); &#125; if(i &gt; size)&#123; new IllegalArgumentException(\"插入位置越界，当前数组的大小为：\"+size); &#125; Object oldArr[]; Object newArr[];//用来存放扩容后的容量 //如果当前线性表中数组为满的，需要增加数组的存储空间 if (i == maxSize) &#123; oldArr = arr; newArr = new MyArrayList[(int) (maxSize*1.5)]; //把旧数组中的元素赋值到新的数组中 for (int j = 0; j &lt; newArr.length; j++) &#123; newArr[j] = oldArr[j]; &#125; maxSize = (int) (maxSize*1.5); arr = newArr; &#125; //如果插入的位置是最后一个元素，不需要移动元素 if (i == size) &#123; arr[i] = elem; size++; return; &#125; //如果插入的不是最后一个位置，需要移动元素，先移动位置，空出带插入位置元素 for (int j = size;j &gt; i;j--) &#123; arr[j] = arr[j-1]; &#125; //移动完之后，插入元素 arr[i] = elem; size++; //查看数组中的元素 for (int j = 0; j &lt; arr.length; j++) &#123; System.out.print(\" \" +arr[j]); &#125; &#125; 时间复杂度分析： 最好情况：在线性表的末尾插入，（i = size）元素后移的语句将不再执行，时间复杂度为O(1) 最坏情况：在表头插入，（即i=0）元素后移的语句将执行n次，时间复杂度为O(n) 平均情况：n/2 因此，线性表插入算法的时间复杂度为O(n) 123456789101112131415161718192021222324252627282930313233343536 //移除指定位置的元素public void remove(int i,Object elem)&#123; //首先判断移除的位置时候合法 if (i &lt; 0) &#123; new IllegalArgumentException(\"插入位置为负，不合法\"); &#125; if (i &gt; size) &#123; new IllegalArgumentException(\"移除位置超越数组长度，当前长度为：\"+size); &#125; //判断是否是移动的最后一个元素，如果是最后一个元素不需要移动元素 if (i == size-1) &#123; arr[i] = null; size--; return; &#125; //一般情况的处理 arr[i] = null; //移动元素 for (int j=i; j&lt;size-1;j++) &#123; arr[j] = arr[j+1]; &#125; arr[size-1]=null;//最后一个元素为空 size--; //查看数组中的元素 if (arr != null) &#123; System.out.println(\"\"); for (int j = 0; j &lt; arr.length; j++) &#123; System.out.print(\" \" + arr[j]); &#125; &#125; &#125; 时间复杂度分析： 最好情况：在线性表的末尾移除，（i = size）元素后移的语句将不再执行，时间复杂度为O(1) 最坏情况：在表头移除，（即i=0）元素后移的语句将执行n次，时间复杂度为O(n) 平均情况：n-1/2 因此，线性表插入算法的时间复杂度为O(n) 1234567891011//清空数据public void clear() &#123;if (arr != null) &#123;for (int i = 0; i &lt; size; i++) &#123;arrs[i] = null;&#125;&#125;size = 0;&#125; 上面是最一种线性表的操作，下面再看一下线性表中对两个顺序表的合并操作。 【编写算法】:有两个顺序表LA和LB,其元素均为递增有序排列,编写算法,将两个有序表合并成一个递增有序的顺序表LC 【算法思路】 1)初始化:LC为空表,设LC表的指示器k=0 设两个指示器i,j分别指向表LA和LB的当前位置,初值均为0。 2)比较循环:将LA.elem[]和LB.elem[]两元素进行比较,较小元素放入表LC中,且该表的指示器和G表的指示器k均加1移向下一个位置。如此下去,直到LA或LB表中一个表处理完毕为止。都是当前位置的元素做比较。 3)复制循环:将未处理完的表中剩余元素通过循环逐一复制到LC表中。 【算法分析】由于两个待归并的表LA、LB本身就是有序表,且表LC的建立采用的是尾插法建表,插入时不需要移动元素,所以算法的时间复杂度O(LA-&gt;last+LB-&gt;last) 上面的代码，我们依旧使用Java进行实现。 我们首先定义一个线性表的结构，也就是定义一个线性表的类，线性表中定义一个数组然后定义一个指向数组最后一个元素的变量，提供该类的初始化有参构造方法。 SeqList.java 123456789101112131415package com.hebing;public class SeqList &#123; public int[] array1; public int last; public SeqList(int[] array1) &#123; this.array1=array1; if(array1!=null) &#123;//判断是否为空 last=array1.length; &#125; &#125; &#125; 然后写线性表的合并方法，定义一个合并的类，我们按照上面的算法思路实现这个合并类。定义一个空表C 用来存放合并后的类。然后对表A和表B中的元素依次判断放到表C中。 Combine.java 12345678910111213141516171819202122232425262728package com.hebing;public class Combine &#123; public void Combine(SeqList A,SeqList B,SeqList C) &#123; int a=0,b=0,c=0; while(a&lt;A.last&amp;&amp;b&lt;B.last) &#123; if(A.array1[a]&lt;B.array1[b]) &#123; C.array1[c++]=A.array1[a++]; &#125;else &#123; C.array1[c++]=B.array1[b++]; &#125; &#125; while(a&lt;A.last) &#123; C.array1[c++]=A.array1[a++]; &#125; while(b&lt;B.last) &#123; C.array1[c++]=B.array1[b++]; &#125; C.last=c; &#125; &#125; 测试方法： 1234567891011121314151617181920212223package com.hebing;import java.util.ArrayList;public class test &#123; public static void main(String[] args) &#123; SeqList a = new SeqList(new int[] &#123; 5,6,9 ,11&#125;); SeqList b = new SeqList(new int[] &#123; 2,8,10&#125;); SeqList c = new SeqList(new int[a.array1.length + b.array1.length]); Combine cob=new Combine(); cob.Combine(a, b, c); for(int i=0;i&lt;c.array1.length;i++) &#123; System.out.print(c.array1[i]+\" \"); &#125; &#125;&#125; 线性表的链式存储上面学习的顺序存储结构是：一组连续单元依次存放表中各个元素顺序存储结构的特点：便于随机存取，不适合动态的变化。 逻辑上相邻的元素在物理存储位置上也相邻。链式存储结构中，逻辑上相邻的元素在物理存储上不一定相邻。因此设计出结点来对应线性表的元素及元素之间的关系。结点包括两部分 ：结点本身数据信息，元素之间的关联关系。线性表采用链式方式将结点链接起来的存储结构称为链表。 链式存储结构中结点包括两部分不仅包括结点本身信息,还要包括关联关系部分。线性表采用链式方式将结点链接起来的存储结构称为链表。 链式存储结构分为单链表、循环单链表、双向链表和静态链表。 从链接方式看,可分为单链表、循环链表和双向链表 从实现角度看,可分为动态链表和静态链表。 单链表结构 链表中的结点包括数据域和指针域两个域 数据域data用来存储结点的值 指针域next用来存储结点本身的信息,邻接关系由后继指针指示其位置。 线性链表(单链表): 用一组任意的存储单元存放线性表的结点，每个结点的唯一后继依靠一个结点指针维持。 (这组存储单元可以是连续的也可以是不连续的、甚至是零散的存储在内存的任何位置。即链表结点的逻辑顺序和物理顺序不一定相同。) 头指针H指向第一个结点。 最后一个结点的指针域为“空”（NULL） *注意: 链表中头指针，头结点，首结点的关系 链表中头指针指向单链表开始（H） 带头结点的链表中，头指针指向头结点，头结点指向首结点。 无头结点的链表中，头指针指向首结点。* 单链表的基本运算链表是一种重要的数据结构，在Java中，HashMap等集合的底层结构都是链表结构。 链表以结点作为存储单元，这些存储单元可以是不连续的。每个结点由两部分组成：存储的数值+前序结点和后序结点的指针。即有前序结点的指针又有后序结点的指针的链表称为双向链表，只包含后续指针的链表为单链表 链表是一种线性表但是并不会按顺序来存储元素 Java中单链表采用Node实体类类标识，其中data为存储的数据，next为下一个节点的指针： 1234567891011121314151617package com.lianbiao;/** * 链表结点的实体类 * */public class Node &#123; Node next = null;//下一个结点int data;//结点数据public Node(int data)&#123;this.data = data;&#125;&#125; 往链表中插入元素 网链表中插入元素有两种方法，一种是采用头插法。一种是采用尾插法，头插法就是每次网表头插入元素，尾插法就是从表单额末尾依次插入元素。 采用尾插法，必须增加一个节点用来指示链表的末尾节点。 用Java实现尾插法建立链表： 123456789101112131415161718192021/**链表的根结点*/ Node root = null; /** * 链表添加结点: * 找到链表的末尾结点，把新添加的数据作为末尾结点的后续结点 * @param data */ public void addNode(int data)&#123; Node newNode = new Node(data); if(root == null)&#123; root = newNode; return; &#125; Node temp = root; while(temp.next != null)&#123; temp = temp.next; &#125; temp.next = newNode; &#125; ​ 删除链表中的数据 删除链表中的数据，有两种方式进行删除，首先我们可以删除指定位置上的元素。我们还可以按值删除链表中的元素。 首先按值删除链表中的元素。 删除结点，主要是查找删除结点的前驱结点。然后改变前驱结点的指向就可以了。 123456789101112131415161718 public boolean deleteNodeData(int data)&#123; Node curNode = root; if (curNode != null &amp;&amp; curNode.data == data) &#123; root = curNode.next; return true;&#125; if (curNode != null ) &#123; while(curNode.next.data != data)&#123; curNode = curNode.next; &#125; curNode.next = curNode.next.next;&#125; return true; &#125; 按位置删除链表中的元素 123456789101112131415161718192021222324public boolean deleteNode(int index)&#123; if(index&lt;1 || index&gt;length())&#123;//待删除结点不存在 return false; &#125; if(index == 1)&#123;//删除头结点 root = root.next; return true; &#125; Node preNode = root; Node curNode = preNode.next; int i = 1; while(curNode != null)&#123; if(i==index)&#123;//寻找到待删除结点 preNode.next = curNode.next;//待删除结点的前结点指向待删除结点的后结点 return true; &#125; //当先结点和前结点同时向后移 preNode = preNode.next; curNode = curNode.next; i++; &#125; return true;&#125; 求单链表的长度操作 在顺序表中,线性表的长度是它的属性,数组定义时就已确定 在单链表中,整个链表由“头指针”来表示,单链表的长度在从头到尾遍历的过程中统计计数得到 【算法思路】采用“数”结点的方法求出单链表的长度。即从“头”开始“数”用指针p依次指向各个结点,一直“数”到最后一个结点(p-&gt;nextNUL),从而得到单链表的长度 顺链头开始,计数器j初值为0 当前指针ρ指向链表L的首元结点 p=L-&gt;next p依次往后(计数j+)直到表尾(p==NULL) 求表长度的操作就是计算单链表中数据结点的个数，需要从第一个结点开始顺序访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问出空节点为止。 java代码实现 1234567891011121314/** * 求链表的长度 * @return */public int length()&#123; int length = 0; Node curNode = root; while(curNode != null)&#123; length++; curNode = curNode.next; &#125; return length;&#125; 输出链表中的数据 123456789101112/** * 打印结点 */public void printLink()&#123; Node curNode = root; while(curNode !=null)&#123; System.out.print(curNode.data+\" \"); curNode = curNode.next; &#125; System.out.println();&#125; 反转链表 在反转指针前一定要保存下个结点的指针 123456789101112131415/** * 反转链表，在反转指针前一定要保存下个结点的指针 */ public void reserveLink()&#123; Node curNode = root;//根结点 Node preNode = null;//前一个结点 while(curNode != null)&#123; Node nextNode = curNode.next;//保留下一个结点 curNode.next = preNode;//指针反转 preNode = curNode;//前结点后移 curNode = nextNode;//当前结点后移 &#125; root = preNode; &#125; 反向输出链表 反向输出链表有三种方式 方式一：先反转链表，再输出链表，需要链表遍历两次 方式二：把链表中的数字放入栈中再输出，需要维护额外的栈空间 方式三：依据栈的思想，通过递归来实现，就是将先执行的数据压如栈中，再一次出栈 12345678//反转链表 public void reservePrt(Node node)&#123; if(node != null)&#123; reservePrt(node.next); System.out.print(node.data+\" \"); &#125; &#125; 在不知道头结点的情况下删除指定结点 删除结点的重点在于找出其前结点，使其前结点的指针指向其后结点，即跳过待删除结点， 1、如果待删除的结点是尾结点，由于单链表不知道其前结点，没有办法删除2、如果删除的结点不是尾结点，则将其该结点的值与下一结点交换，然后该结点的指针指向下一结点的后续结点 1234567891011121314public boolean deleteSpecialNode(Node n)&#123;if(n.next == null)&#123;return false;&#125;else&#123;//交换结点和其后续结点中的数据int temp = n.data;n.data = n.next.data;n.next.data = temp;//删除后续结点n.next = n.next.next;return true;&#125;&#125; 总结： 1.单链表主要的有点是，不需要对数据元素的最大个数进行预设，可以无限量地存储数据元素。 2.单链表插入和删除时，不需要移动大量的数据元素，可提高效率。 单链表主要的缺点是，每个节点中需要有一个指针，因此单链表的空间利用率略低于顺序表， 循环链表定义：即首尾相接的链表 结构：尾结点的指针域指向头结点或表的首元结点。 特点：表中所有结点都链接在一个环上 循环单链表和单链表的区别在于，表中最后一个结点不是指向null ，而是改为指向头节点中，从而整个链表形成一个环。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/%E6%A0%88/"}]},{"title":"MongoDB基本配置","slug":"MongoDB入门","date":"2019-03-02T04:20:32.000Z","updated":"2021-05-16T11:04:06.709Z","comments":true,"path":"2019/03/02/MongoDB入门/","link":"","permalink":"http://yoursite.com/2019/03/02/MongoDB%E5%85%A5%E9%97%A8/","excerpt":"MongDB是一个文档型数据库，里面包含一些术语和概念，我们先来了解一下MongoDB的基本概念，再看一下中间的基本操作","text":"MongDB是一个文档型数据库，里面包含一些术语和概念，我们先来了解一下MongoDB的基本概念，再看一下中间的基本操作 1.1 基础概念在mongoDB中是通过数据库、集合、文档、的方式来管理数据、先看一下mongoDB与关系型数据库的一些概念对比： SQL术语/概念 MongoDB术语/概念 解释说明 database database 数据库 table collection 数据库表/集合 row document 数据库行/文档 column field 数据字段/域 index index 索引 table joins 表连接（MongDB不支持表连接） primary key primary 主键，MongoDB自动在每个集合中添加_id的主键 一个mongodb实例可以创建多个数据库 一个数据库可以创建多个集合 一个集合可以包含多个文档 1.2 连接mongodbmongodb的使用方式是客户服务器模式，即使用一个客户端连接mongodb数据库（服务端）。 命令模式mongodb://[username:password@]host1[:port1][,host2[:port2],…[,hostN[:portN]]][/[database][? options]] mongodb:// 固定前缀username：账号，可不填password：密码，可不填host：主机名或ip地址，只有host主机名为必填项。port：端口，可不填，默认27017/database：连接某一个数据库?options：连接参数，key/value对 例如： mongodb://localhost 连接本地数据库27017端口 mongodb://root:123456@localhost 使用用户名root密码为123456连接本地数据库27017端口 mongodb://localhost,localhost:27018,localhost:27019，连接三台主从服务器，端口为27017、27018、2701 我们直接在命令行输入mongo 就可以使用输入命令来操作mongodb数据库了 1.3 数据库使用 查询数据库 show dbs 查询全部的数据库 db 显示当前数据库 创建数据库命令格式 use DATABASE_NAME 例子： use test02 执行这一行命令之后，如果有test02数据库则切换到此数据库中，如果没有则创建 这里我们需要注意的是，新创建的数据库不会显示，因为这个数据库中至少需要包含一种集合。 删除数据库 命令格式 db.dropDatabase() eg： 删除test02数据库 先切换到数据库中 use test02 在执行删除 db.dropDatabase() 1.4 集合MongoDB中的集合相当于数据库中的表。一个数据库可以创建多个集合，一个集合是将相同类型的文档管理起来。 创建集合 db.createCollection(name,options) name:新创建的集合名称 options：创建参数 删除集合 db.collection.drop() 例子： db.student.drop() 删除student集合 1.5 文档1.5.1 插入文档mongodb中的文档格式是json格式吗，下边就是一个文档，包括两个key：_id 主键和name { &quot;_id&quot; : ObjectId (&quot;5b2cc4bfa6a44812707739b5&quot;), &quot;name&quot; : &quot;郑州大学&quot; }插入命令： db.COLLECTION_NAME.insert(document)`每个文档默认以_id作为主键，主键默认类型为ObjectId（对象类型），mongodb会自动生成主键值。 例子 db.student.insert({&quot;name&quot;:&quot;郑州大学&quot;,&quot;age&quot;:10})注意：同一个集合中的文档的key可以不相同！但是建议设置为相同的。 1.5.2 更新文档命令格式： db.collection.update( &lt;query&gt;, &lt;update&gt;, &lt;options&gt; ) query:查询条件，相当于sql语句的where update：更新文档内容 options：选项 替换文档 将符合条件 “name” “郑州大学” 的第一个文档替换为 {“name”：“郑州大学学生”，“age”：10} db.student.update({&quot;name&quot;:&quot;郑州大学&quot;}，{“name”：“郑州大学学生”，“age”：10}) $set修改器 使用$set修改器指定要更新的key，key不存在则创建，存在则更新。 将符合条件 “name”:”郑州大学”的所有文档更新name和age的值。 db.student.update({&quot;name&quot;:&quot;郑州大学&quot;},{$set:{&quot;name&quot;:&quot;郑州大学学生&quot;,&quot;age&quot;:10}},{multi:true}) multi：false表示更新第一个匹配的文档，true表示更新所有匹配的文档 1.5.3 删除文档命令格式： db.student.remove(&lt;query&gt;) query：删除条件，相当于sql语句中的where 删除所有文档 db.student.remove({}) 删除符合条件的文档 db.student.remove({&quot;name&quot;:&quot; 郑州大学&quot;}) 1.5.4 查询文档命令格式： db.collection.find(query, projection) query：查询条件，可不填 projection：投影查询key，可不写 查询全部 db.student.find() 查询符合条件的记录 查询name等于 “郑州大学”的文档 db.student.find({&quot;name&quot;,&quot;郑州大学&quot;}) 投影查询 只显示name和age两个key，_id主键不显示 db.student.find({“name”：“郑州大学”},{name：1，age：1，_id:0}) 1.6 用户1.6.1 创建用户mongo&gt;db.createUser( { user: &quot;&lt;name&gt;&quot;, pwd: &quot;&lt;cleartext password&gt;&quot;, customData: { &lt;any information&gt; }, roles: [ { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } | &quot;&lt;role&gt;&quot;, ... ]} )例子：创建root用户，角色为root use admin db.createUser( { user : &quot;root&quot;, pwd : &quot;123456&quot;, roles:[{role:&quot;root&quot;,db:&quot;admin&quot;}] } )内置角色如下： 1. 数据库用户角色：read、readWrite; 2. 数据库管理角色：dbAdmin、dbOwner、userAdmin 3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 4. 备份恢复角色：backup、restore； 5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、 dbAdminAnyDatabase 6. 超级用户角色：root1.6.2 认证登录如果不配置认证， 我们登陆mongo数据库的时候，是不需要进行账号密码登陆的。 为了安全需要，Mongodb要打开认证开关，即用户连接Mongodb要进行认证。1、在mono.conf中设置 auth=true2、重启Mongodb3、使用账号和密码连接数据库 1）mongo.exe连接 mongo.exe ‐u root ‐p 123456 ‐‐authenticationDatabase admin 2）Studio 3T连接 输入账号密码进行登陆。Windows下Mongodb最初未开启认证，如何开启authentication博客分类： mongodb cmd-&gt; regedit-&gt; HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services-&gt;MongoDB （mongodb注册的名称，我的是MongoDB) 在它的ImgPath中，我们修改一下，加入 –auth 如下 “E:\\develop Software\\Mongodb\\mongodb-win32-x86_64-2.2.3\\mongodb-win32-x86_64-2.2.3\\bin\\mongod.exe” -dbpath “E:\\develop Software\\Mongodb\\mongodb-win32-x86_64-2.2.3\\mongodb-win32-x86_64-2.2.3\\data\\db” –logpath “E:\\develop Software\\Mongodb\\mongodb-win32-x86_64-2.2.3\\mongodb-win32-x86_64-2.2.3\\data\\log\\mongodb.log” –auth –service 1.6.3 查询所有用户查询当前库下的所有用户 show users1.6.4 删除用户db.dropUser(“用户名”) 例子： 删除 test1用户 db.dropUser(&quot;test1&quot;)1.6.5 修改用户语法格式 db.updateUser( “&lt;username&gt;” { customData : { &lt;any information&gt; }, roles : [ { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } | &quot;&lt;role&gt;&quot;, ... ], pwd: &quot;&lt;cleartext password&gt;&quot; }, writeConcern: { &lt;write concern&gt; })先创建test1用户 db.createUser( { user:&quot;test1&quot;, pwd:&quot;test1&quot;, roles:[{role:&quot;root&quot;,db:&quot;admin&quot;}] } )修改test1用户的角色为readWriteAnyDatabase use admin db.updateUser(&quot;test1&quot;,{roles:[{role:&quot;readWriteAnyDatabase&quot;,db:&quot;admin&quot;}]})1.6.6 修改密码语法格式 db.changeUserPassword(&quot;username&quot;,&quot;newPasswd&quot;)例子：修改test1用户的密码为123 use admin db.changeUserPassword(&quot;test1&quot;,&quot;123&quot;）每一个集合中的不同文档是可以有不同的域，这是比较灵活的，但是有时候为了保证性能，同一个集合中文档，域设置成一样的。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"SSM框架整合案例","slug":"2019-01-02-SSM框架整合案例","date":"2019-01-02T03:20:32.000Z","updated":"2021-05-16T11:04:06.706Z","comments":true,"path":"2019/01/02/2019-01-02-SSM框架整合案例/","link":"","permalink":"http://yoursite.com/2019/01/02/2019-01-02-SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"本片文章主要是对ssm框架的整合（springMVC+spring+mybatis） 1. 搭建整合环境1.1整合说明：编程环境：IDEAMavenSSM整合可以使用多种方式，咱们会选择XML + 注解的方式","text":"本片文章主要是对ssm框架的整合（springMVC+spring+mybatis） 1. 搭建整合环境1.1整合说明：编程环境：IDEAMavenSSM整合可以使用多种方式，咱们会选择XML + 注解的方式 1.2整合的思路 先搭建整合的环境 先把Spring的配置搭建完成 再使用Spring整合SpringMVC框架 最后使用Spring整合MyBatis框架 1.3创建数据库和表结构本文主要是对ssm整合的一个环境搭建，所以使用了MySQL创建了一张account表进行测试 123456create database ssm; use ssm; create table account( id int primary key auto_increment, name varchar(20), money double ); 1.4 创建maven工程未解决maven项目刚开始创建过慢问题，我们可以创建项目的时候增加如下键值对archetypeCatalog internal项目创建成功，创建需要的目录文件 然后在pom文件中导入相应的依赖jar包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;finalName&gt;ssmZhengHe&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 编写实体类123456789101112131415161718192021222324252627282930313233343536373839404142package zzu.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 编写dao接口12345678910111213141516171819package zzu.dao;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import zzu.domain.Account;import java.util.List;/** * controllerDao层接口 */@Repositorypublic interface AccountDao &#123; //查找账户 public List&lt;Account&gt; findAll(); //保存账户信息 public void saveAccount(Account account);&#125; 编写service接口和实现类12345678910111213package zzu.servlice;import zzu.domain.Account;import java.util.List;public interface AccountService &#123; //查找账户 public List&lt;Account&gt; findAll(); //保存账户信息 public void saveAccount(Account account);&#125; service实现类 1234567891011121314151617181920212223package zzu.servlice.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import zzu.dao.AccountDao;import zzu.domain.Account;import zzu.servlice.AccountService;import java.util.List;public class AccountServiceImpl implements AccountService &#123; //查找所有的账户信息 public List&lt;Account&gt; findAll() &#123; System.out.println(\"这是service业务层的操作\"); return null &#125; //保存账户信息 public void saveAccount(Account account) &#123; &#125;&#125; 2.spring框架代码的编写配置完基本环境和建立好必要的domain包和dao包接口之后，我们先进行spring框架的搭建 在ssmZhengHe项目中创建applicationContext.xml的配置文件，编写具体的配置信息。 applicationContext.xml的配置文件123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;!--配置不需要注解扫描的包,spring的注解扫描，我们需要扫描的是service层和dao层，不需要扫描Controller层，对service层和dao层使用依赖注入--&gt; &lt;context:component-scan base-package=\"zzu\"&gt; &lt;!--配置要忽略的注解--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; spring框架的配置文件编写完之后，我们首先对spring框架进行测试。检测一下spring的配置是否起作用。 我们配置完spring框架之后，就可以对service实现类进行依赖注入，在AccountServiceImpl.java中加入@Service（“accountService”） 编写测试类，看spring配置文件，使用Junit单元测试 123456789101112public class testSpring &#123; @Test public void test1()&#123; //加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); //获取对象 AccountService as = (AccountService) ac.getBean(\"accountService\"); as.findAll(); &#125;&#125; 运行结果可以看到，spring配置正常加载 3. springMVC框架的代码编写首先编写springMVC的配置文件，springmvc.xmlspringmvc.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解扫描，只扫描Controller包--&gt; &lt;context:component-scan base-package=\"zzu\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器对象 往哪一个路径去跳转--&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--需要解析的视图前缀文件路径--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;!--controller中返回的文件的后缀名称--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- 配置spring开启注解mvc的支持 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 在web.xml文件中配置加载springmvc.xml配置文件web.xml文件中 1234567891011121314151617&lt;!--配置前端控制器--&gt; &lt;!-- 配置前端控制器：服务器启动必须加载，需要加载springmvc.xml配置文件 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 服务器启动的时候，让DispatcherServlet对象创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在web.xml中配置DispatcherServlet过滤器解决中文乱12345678910111213&lt;!--配置解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 测试SpringMVC的框架搭建是否成功1.编写前端页面index.jsp1&lt;a href=\"account/findAll\"&gt;查询账户&lt;/a&gt; 2. 创建AccountController类，编写方法，进行测试123456789101112131415161718192021222324252627282930package zzu.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import zzu.domain.Account;import zzu.servlice.AccountService;import java.util.List;/** * 账户web层 */@Controller@RequestMapping(\"/account\")public class AccountController &#123; /** * 查找所有的账户信息 */ @RequestMapping(\"/findAll\") public String findAll()&#123; System.out.println(\"web层查询所有的账户信息执行了\"); return \"list\"; &#125; &#125; 3.正确运行，springMVC框架配置正确 4. Spring整合SpringMVC的框架spring整合springMVC框架的目的是，在controller层能调用service对象的方法，说明整合成功。 上面步骤测试的时候，我们用Junit测试加载过spring的配置文件，能正常加载，但是我们需要在项目启动的时候就去加载spring的配置文件，这样才能进行依赖注入**在项目启动的时候，就去加载applicationContext.xml的配置文件，在web.xml中配置 ContextLoaderListener监听器（但是该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文件，但是我们的配置文件放在了src下resources资源文件夹下，所以我们还需要配置配置文件的路径）。 ** 123456789&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--设置配置文件的路径--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 在controller中注入service对象，调用service对象的方法进行测试controller层 123456789101112131415161718/** * 账户web层 */@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired private AccountService accountService; /** * 查找所有的账户信息 */ @RequestMapping(\"/findAll\") public String findAll()&#123; System.out.println(\"web层查询所有的账户信息执行了\"); accountService.findAll(); return \"list\"; &#125;&#125; 运行结果，service层的findall方法能成功执行，所用对象注入成功 5. 搭建mybatis框架代码1.在web项目中src下resources文件中编写SqlMapConﬁg.xml的配置文件，编写核心配置文件SqlMapConﬁg.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--连接数据库--&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--持久层所在的包--&gt; &lt;!-- 该包下所有的dao接口都可以使用 --&gt; &lt;package name=\"zzu.dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意：我们使用代理 dao的方式来操作持久层，所以此处 Dao的实现类就是多余的了 编写完mybatis的配置文件，我们需要mybatis配置文件是否能正常加载 首先我们需要在持久层Dao层进行查询语句的编写在AccountDao接口的方法上添加注解，编写SQL语句AccountDao.java 123456789101112131415161718192021package zzu.dao;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import zzu.domain.Account;import java.util.List;/** * controllerDao层接口 */public interface AccountDao &#123; //查找账户 @Select(\"select * from account\") public List&lt;Account&gt; findAll(); //保存账户信息 @Insert(\"insert into account (name,money) values(#&#123;name&#125;,#&#123;money&#125;)\") public void saveAccount(Account account);&#125; 然后编写测试类，Junit测试testMybatis.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package zzu.test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import zzu.dao.AccountDao;import zzu.domain.Account;import java.io.InputStream;import java.util.List;public class TestMybatis &#123; /** * 测试账户查询的功能 */ @Test public void run1() throws Exception &#123; InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session= factory.openSession(); AccountDao dao = session.getMapper(AccountDao.class); List&lt;Account&gt; list = dao.findAll(); System.out.println(list); session.close(); in.close(); &#125; /** * 添加账户信息 */ @Test public void run2() throws Exception &#123; //加载配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //创建SqlSessionFactory对象 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //创建sqlsession对象 SqlSession session= factory.openSession(); //获取AccountDao接口的代理对象 AccountDao dao = session.getMapper(AccountDao.class); //添加数据 Account account = new Account(); account.setName(\"熊大\"); account.setMoney(300d); dao.saveAccount(account); session.commit(); session.close(); in.close(); &#125;&#125; 经过测试，程序能正常查询出数据库中account表中的信息，mybatis框架编写正确。下面就是把mybatis框架与spring框架进行整合。 6. spring框架整合mybatis框架spring框架与mybatis框架整合的目的就是把mybatis框架的配置文件sqlMapconfig.xml加载进spring配置文件applicationContext.xml文件中 添加过mybatis配置信息的spring配置文件applicationContext.xml完整文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;!--配置不需要注解扫描的包,spring的注解扫描，我们需要扫描的是service层和dao层，不需要扫描Controller层，对service层和dao层使用依赖注入--&gt; &lt;context:component-scan base-package=\"zzu\"&gt; &lt;!--配置要忽略的注解--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;!--Spring整合MyBatis框架--&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/ssm\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactory工厂--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置AccountDao接口所在包--&gt; &lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"zzu.dao\"/&gt; &lt;/bean&gt; &lt;!--配置Spring框架声明式事务管理--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" isolation=\"DEFAULT\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* zzu.servlice.impl.*ServiceImpl.*(..))\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意：把mybatis的配置信息添加进spring进行管理之后，mybatis的配置文件sqlMapConfig.xml配置文件中，sqlMapConfig.xml的配置文件就可以删除不用了。只需要用applicationContext.xml就可以了 ** 在AccountDao接口中添加@Repository注解** 12345678910111213141516171819202122package zzu.dao;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import zzu.domain.Account;import java.util.List;/** * controllerDao层接口 */@Repositorypublic interface AccountDao &#123; //查找账户 @Select(\"select * from account\") public List&lt;Account&gt; findAll(); //保存账户信息 @Insert(\"insert into account (name,money) values(#&#123;name&#125;,#&#123;money&#125;)\") public void saveAccount(Account account);&#125; 在AccountServiceImpl.java中 1234567891011121314151617181920212223242526package zzu.servlice.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import zzu.dao.AccountDao;import zzu.domain.Account;import zzu.servlice.AccountService;import java.util.List;@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; //查找所有的账户信息 public List&lt;Account&gt; findAll() &#123; System.out.println(\"这是service业务层的操作\"); return accountDao.findAll(); &#125; //保存账户信息 public void saveAccount(Account account) &#123; accountDao.saveAccount(account); &#125;&#125; 在AccountControlle.java中 123456789101112131415161718192021/** * 账户web层 */@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired private AccountService accountService; /** * 查找所有的账户信息 */ @RequestMapping(\"/findAll\") public String findAll(Model model)&#123; System.out.println(\"web层查询所有的账户信息执行了\"); List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(\"list\",list); return \"list\"; &#125;&#125; 把查询的结果，在返回的list.jsp页面进行展示list.jsp页面 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: Lei Date: 2019/6/1 Time: 9:49 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;查询出所有的账户信息&lt;/h1&gt;&lt;c:forEach items=\"$&#123;list&#125;\" var=\"account\"&gt; $&#123;account.name&#125; $&#123;account.money&#125;&lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 能正常运行，执行成功 以上框架整合完毕，但是只是执行查询操作，如果想进行插入更新操作，还需要配置事务在刚才applicationContext.xml文件中已经声明过，在这里重复声明： 123456789101112131415161718&lt;!--配置Spring框架声明式事务管理--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" isolation=\"DEFAULT\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* zzu.servlice.impl.*ServiceImpl.*(..))\"/&gt; &lt;/aop:config&gt; 保存更新操作index.jsp中 123456&lt;a&gt;测试保存操作&lt;/a&gt; &lt;form action=\"account/saveAccount\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; 密码：&lt;input type=\"text\" name=\"money\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"保存\" &gt;&lt;br&gt; &lt;/form&gt; AccountController.java中 123456789101112/** * 保存账户信息 * @param account * @param request * @param response * @throws IOException */ @RequestMapping(\"/saveAccount\") public void saveAccount(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+\"/account/findAll\"); &#125; 到此，经过测试，三个框架都能正常运行，框架整合完毕。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"Docker容器化","slug":"Docker容器化","date":"2019-01-02T03:20:32.000Z","updated":"2021-05-16T11:04:06.708Z","comments":true,"path":"2019/01/02/Docker容器化/","link":"","permalink":"http://yoursite.com/2019/01/02/Docker%E5%AE%B9%E5%99%A8%E5%8C%96/","excerpt":"1. Docker简介1.1 什么是Docker 从传统意思上来讲也是一种虚拟化技术。 Docker项目的目标是实现一种轻量级的操作系统解决方案。Docker的基础是Linux容器LXC等技术。Docker方便了环境的部署和安装。","text":"1. Docker简介1.1 什么是Docker 从传统意思上来讲也是一种虚拟化技术。 Docker项目的目标是实现一种轻量级的操作系统解决方案。Docker的基础是Linux容器LXC等技术。Docker方便了环境的部署和安装。 Docker的优点： 如果使用Docker 只需要把别人安装好的镜像拉去下来就可以直接使用，上手方便。 鼓励使用面向服务的架构，绝大多数的微服务都是通过Docker来进行部署的。 传统的虚拟机我们需要分配本机的硬件配置资源，在本机上配置虚拟机的数量是有限制的。 但是使用Docker是共享我们主机的资源。 1.2 Docker组件 客户端和服务器端 &nbsp;&nbsp;&nbsp;&nbsp;Docker是一个客服端服务器架构CS架构程序，Docker客户端只需要向Docker服务器或者是守护进程发出请求，服务器或者是守护进程将完成所有工作并返回结果。Docker提供了一套命令行工具以及RESTful API、你可以在任意一台宿主主机上运行Docker守护进程和客户端。&nbsp;&nbsp;&nbsp;&nbsp;Docker守护进程就是Docker的服务端，主要是管理Docker容器的。Docker客户端主要是为了连接Docker的守护进程，通过客户端来进行操作Docker容器。 Docker镜像和容器 镜像是构建Docker的基石，用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的构建部分。例如我们可以通过一个MySQL镜像来创建多个MySQL容器。镜像相当于我们创建的类，容器相当于我们通过类创建的对象。 2. 安装docker在CentOS下安装Docker（1）首先yum包更新到最新 Sudo yum update（2）安装需要的软件包，yum-util 提供 yum-config-，anager功能，另外两个是devicemapper驱动依赖的 Sudo yum install -y yum-utils device-mapper-persistent-data lvm2（3）设置yum源为阿里云 Sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（4）安装docker Sudo yum install docker-ce（5）安装后查看docker的版本 Docker -v设置USTC的镜像 USTC是老牌的Linux镜像服务的提供者了。USTC docker mirror 的优势之一就是不需要注册，值真正的公共服务。编辑该文件： Vi /etc/docker/daemon.json在该文件中输入如下内容： { “registry-mirrors”:[“https://docker.mirror.ustc.edu.cn”] }启动Docker Systemctl start docker停止Docker Systemctl stop docker重启docker Systemctl restart docker查看docker的状态 systemctl status docker设置开机自启动 Systemctl enable docker3. 镜像相关的命令查看镜像 docker images 可以查看我们已经安装好的镜像 搜索镜像 docker search centos 我们可以基于搜索的结果进行镜像的下载 针对搜索的结果各个属性的名称进行说明Name是仓库名称，DESCRIPTION:镜像描述STARS:用户的评价OFFICIAL：是否是官方提供的镜像。ATTOMATED 是否是docker hub 自动创建流程所创建的 拉取镜像：拉取镜像就是从中央仓库中下载镜像到本地 docker pull 镜像名称例如需要下载centos7镜像 docker pull centos：7删除镜像： 按照镜像id进行删除镜像 Docker rmi 镜像ID删除所有的镜像 Docker rmi `docker images -q` (注意这里不是单引号)#4. 容器相关的命令 [root@iZwz92dpr9gpgasbo4gg15Z lib]# docker ps可以查看运行中的容器 创建与启动容器 创建容器命令 docker run -i ：表示运行容器 -t ：表示容器启动后会进入命令行。加入这两个参数后，容器创建就能登录进去，即分配一个伪终端。 --name ：为创建的容器命名 -v ：表示目录映射（1）交互式方式创建容器 Docker run -it --name=容器名称 镜像名称：标签/bin/bash创建好后我们可以通过ps命令查看，可以看到启动的容器。 Docker run -i -t --name=mycentos centos:7 /bin/bash [root@iZwz92dpr9gpgasbo4gg15Z ~]# docker run -i -t --name=mycentos centos /bin/bash [root@e4202738a947 /]# ^C [root@e4202738a947 /]# 这个时候我们可以发现，前面的名称不一样了，说明我们现在已经进入centos这个容器中了 我们查看目录，也可以发现和宿主机的目录结构一样，说明我们是在宿主机的基础上又虚拟了一台服务器。我们重新打开窗口可以看到 Docker ps 命令 [root@iZwz92dpr9gpgasbo4gg15Z lib]# docker ps CONTAINER IDIMAGE COMMAND CREATED STATUS PORTS NAMES e4202738a947centos &quot;/bin/bash&quot; 4 minutes ago Up 4 minutesmycentos可以对docker的运行状态进行查看。我们在docker虚拟机上运行exit 然后我们就退回到宿主机上了退出宿主机之后，docker是运行还是关着的？然后我们通过ps命令查看，发现容器处于关闭状态。*结论：如果我们通过交互式的命令来创建容器，当我们使用exit命令退出之后，随之的容器也进行自动关闭状态。 * （2）以守护式方式来创建容器 docker run -di --name=容器名称 镜像名称：标签登录守护式容器方式： Docker exec -it 容器名称（或者是容器ID） /bin/bash [root@iZwz92dpr9gpgasbo4gg15Z ~]# docker run -di --name=mycentos2 centos 4a7d23fda453c40b61138e63753e84833069fd79a9af82de03f6ceab52d50e16 [root@iZwz92dpr9gpgasbo4gg15Z ~]# 出现字符串说明容器创建成功。我们的命令行还是处于宿主机的状态，这个时候我们通过docker ps命令来查看容器状态 如何进入容器呢？ ocker exec -it 容器名称 /bin/bash Docker exec -it mycentos2 /bin/bash [root@iZwz92dpr9gpgasbo4gg15Z ~]# docker exec -it mycentos2 /bin/bash [root@4a7d23fda453 /]# ^C这个时候如果我们通过exit命令退出容器之后，然后通过docker ps命令查看所有运行的容器，我们可以发现，容器还是处于运行状态。 这就是两种创建方式的区别 4.1停止与启动容器停止容器： Docker stop 容器名称（或者容器ID）启动容器： docker start 容器名称（或者容器ID） [root@iZwz92dpr9gpgasbo4gg15Z ~]# docker ps -a CONTAINER IDIMAGE COMMAND CREATED STATUS PORTS NAMES 4a7d23fda453centos &quot;/bin/bash&quot; 8 minutes ago Up 8 minutesmycentos2 e4202738a947centos &quot;/bin/bash&quot; 21 minutes ago Exited (1) 15 minutes ago mycentos [root@iZwz92dpr9gpgasbo4gg15Z ~]# docker stop 4a7d23fda453 4.2 文件拷贝有时候我们需要把文件或者是目录拷贝进容器中，或者是把容器中的文件拷贝出来。文件拷贝进容器命令cp docker cp 需要拷贝的文件或者目录 容器名称：容器目录也可以将文件从容器中拷贝出来 docker cp 容器名称：容器目录 需要拷贝的文件或目录都是在宿主机上户进行操作 4.3 目录挂载我们进行上面文件拷贝的时候操作容器中的或者是宿主机中的内容时，有事不是很方便的操作，这个时候我们可以通过目录挂载的方式进行操作。 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机中的某个目录文件从而去影响容器。创建容器 添加-v参数 后边为宿主机目录：容器目录 例如 Docker run -di -v /usr/local/myhtml :/usr/local/myhtml --name=mycentos3 centos注意：如果你共享的是多级目录，可能会出现权限不足的提示这是因为centos中的安全模式selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题。 4.4 查看容器IP地址我们可以通过以下命令来查看容器运行中的各种数据 Docker inspect 容器名称 （容器ID） 也可以直接执行下面的命令直接输出IP地址 Docker inspect --format=’{{.NetworkSettings.IPAddress}}’ 容器名称 （容器ID）4.5 删除容器Docker rm 容器名称（容器ID） 如果容器是正在运行中无法进行删除。 5. 应用部署##5.1 MySQL部署（1）拉取MySQL镜像 Docker pull centos/mysql-57-centos7（2）创建容器 Docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p ：代表端口映射吗，格式为宿主机映射端口：容器运行端口 -e ：代表添加环境变量，MYSQL_ROOT_PASSWORD是root用户的登录数据库的密码 （3）进入mysql容器 Docker exec -it tensquare_mysql /bin/bash（4）登录mysql Mysql -u root -p创建mysql容器： [root@iZwz92dpr9gpgasbo4gg15Z local]# docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 centos/mysql-57-centos7 0babaf900514d06b02ffdec0a51ca1ad32d7e2cb7f8753b804740502ad95c764 [root@iZwz92dpr9gpgasbo4gg15Z local]# docker ps -a我们可以通过宿主机的端口映射，通过访问宿主机的方式来进行访问容器 5.2 Tomacat部署（1）拉取镜像 Docker pull tomcat：7-jre7（2）创建容器创建容器 -p表示地址映射 Docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7这里为了项目很好的部署我们可以做一个项目映射主机usr/local/webapps映射容器内的usr/local/tomcat/webapps 如果没有文件会自动创建 5.3 Nginx部署（1）拉取镜像 Docker pull nginx（3）创建nginx容器 Docker run -di --name=mynginx -p 80:80 nginx5.4 Redis部署（1）拉取镜像 Docker pull redis（2）创建容器 Docker run -di --name=myredis -p 6379:6379 redis6. 迁移和备份6.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 Docker commit mynginx mynginx_i mynginx是容器名称 mynginx_i表示镜像名称要保存为的镜像。6.2 镜像备份我们可以通过以下命令将镜像保存为tar文件。可以在另一台机器上进行部署 Docker save -o mynginx.tar mynginx_i mynginx_i 表示镜像的名称我们在另一台机器上可以进行压缩文件转化为镜像 Docker load -i mynginx.tar文件名称 这个时候就可以把文件恢复成镜像6. DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。基础镜像一般是系统级的镜像，比如我们可以在centos镜像的基础上再配置其他的镜像。我们构建镜像一般是在一个镜像的基础上创建另一个镜像。 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过dockerfile文件构建一个新的镜像开始工作了 对于运维人员：在部署时，可以实现应用的无缝移植 6.1 常用命令 命令 作用 FROM image_name.tag 定义了使用哪个基础镜像构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量（可以写多条） RUN command 是Dikerfile的核心部分（可以写多条） ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能进行压缩 WORKDIR path_dir 设置工作目录 下面我们通过dockerfile来构建一个镜像，jdk的镜像 使用的基础镜像是centos7镜像 首先创建一个文件 [root@iZwz92dpr9gpgasbo4gg15Z ~]# mkdir -p /usr/local/dockerjdk8 我们在这个文件下进行dockerfile 来创建一个镜像，并把jdk8的压缩包也放进这个文件下使用ftp上传工具把jdk压缩包放进这个文件夹下 sftp:/usr/local/mytestdocker&gt; put E:\\CHDEvaluation.war 然后把jdk压缩包放进dockerjdk8这个文件下然后创建文件，这个名称必须是Dockerfile D是大写的 [root@iZwz92dpr9gpgasbo4gg15Z dockerjdk8]# vi Dockerfile Dockerfile 我们可以在Dockerfile文件中增加以下内容： FROM centos:7 #基础镜像 MAINTAINER leikaibo #作者名称 WORKDIR /usr RUN mkdir /usr/local/javatest ADD jdk-8u191-linux-i586.tar.gz /usr/local/javatest #把我们上传的文件添加到目录中 # 以下是设置环境变量 ENV JAVA_HOME=/usr/local/javatest/jdk1.8.0_191 ENV JRE_HOME=$JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/bin/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH ~ 然后执行命令 docker build -t=&apos;jdk1.8&apos; . -t代表指定镜像的名称 .代表去当前目录中去找Dockerfile文件执行完之后，我们可以通过docker images来查看镜像 [root@iZwz92dpr9gpgasbo4gg15Z dockerjdk8]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEjdk1.8 latest baa98f17d615 16 seconds ago 599MBnginx latest e445ab08b2be 2 weeks ago 126MBtomcat 7-jre7 47c156f4d4e3 2 months ago 359MBcentos/mysql-57-centos7 latest e35b3f7a4ea0 4 months ago 452MBcentos 7 9f38484d220f 4 months ago 202MBcentos latest 9f38484d220f 4 months ago 202MB","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Docker容器化","slug":"Docker容器化","permalink":"http://yoursite.com/tags/Docker%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Shell编程","slug":"Shell编程","date":"2018-06-01T03:20:32.000Z","updated":"2021-05-16T11:04:06.710Z","comments":true,"path":"2018/06/01/Shell编程/","link":"","permalink":"http://yoursite.com/2018/06/01/Shell%E7%BC%96%E7%A8%8B/","excerpt":"Shell编程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shell是一个命令行解释器,它为用户提供了一个向 Linux内核发送请求以便运行程序的界面系统级程序,用户可以用Shl来启动、挂起、停止甚至是编写一些程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shell还是一个功能相当强大的编程语言,易编写,易调试,灵活性较强。Shel是解释执行的脚本语言,在Shel中可以直接调用 Linux系统命令。","text":"Shell编程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shell是一个命令行解释器,它为用户提供了一个向 Linux内核发送请求以便运行程序的界面系统级程序,用户可以用Shl来启动、挂起、停止甚至是编写一些程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shell还是一个功能相当强大的编程语言,易编写,易调试,灵活性较强。Shel是解释执行的脚本语言,在Shel中可以直接调用 Linux系统命令。 一、Shell基础1. 第一个脚本1. 输出命令：echo 【选项】 【输出内容】 选项 -e 加上-e表示支持反斜线控制的字符转换2. 第一个脚本vi hello.sh \\#!/bin/Bash 表示写的脚本是shell脚本--主要是声明作用在这里#不是注释 \\#leikaibi 这里的#表示注释功能 echo -e “这里写需要打印的内容” 保存退出3. 执行脚本1. 赋予执行权限，chmod 755 hello.sh 命令 赋予脚本hello.sh脚本执行权限。然后通过路径/hello.sh来执行 2. 第二种方式。通过 bash hello.sh 来执行。注意：如果运行在Windows下编写的脚本，会提示文件格式错误，这个时候我们就需要对文本中出现的特殊字符进行格式转换，直接在Linux命令行运行dos2unix 【文件名】 这个时候就可以对该文件进行格式转换（如果这个命令没有安装，使用yum -y install dos2unix 进行安装就可以） 2. base的基本功能1. 历史命令和命令补全功能history 可以查询所有的历史命令 history 【选项】【历史命令保存文件】 vi .bash_history 可以查看所有的历史命令保存文件 按一下tab 键进行代码的补全 按两下tab键 可以对所有需要补全的代码进行罗列展示2. 命令别名与快捷键alias 别名 =&apos;原命令&apos; # 设置命令别名 alias vi =‘vim’ 这种别名只会临时生效，如果想要别名永久生效 需要更改配置文件 **快捷键** Ctrl + C 强制终止当前的命令 Ctrl + L 清屏，相当于clear命令 Ctrl + U 删除或者剪切光标之前的命令。如果是输入了一个很长的命令不需要使用退格键一个一个的删除，使用这个快捷键更加的方便。 Ctrl + K 删除或者剪切光标之后的内容 Ctrl + Y 粘贴Ctrl + U 或者Ctrl + K 剪切的内容 Ctrl + D 退出当前终端 3. 输入输出与重定向输出重定向 就是把原本应该输出到屏幕上内容输出到文件保存在文件中​​ | 动作 | 命令 |说明|​ | —— |:——–:| :—–:|​ | 标准输出重定向 | 命令 &gt; 文件名 | 以覆盖的方式，把命令的正确输出，输出到制定的文件或者是设备中 |​ | 标准输出重定向 | 命令 &gt;&gt; 文件名 | 以追加的方式，把命令的正确输出，输出到指定的文件或者是设备中 |​ | 标准错误输出重定向 |错误命令 2&gt; 文件名 | 以覆盖的方式，把命令的错误输出，输出到指定的文件或者是设备中。 |​ | 标准错误输出重定向 | 错误命令 2&gt;&gt;文件名 | 以追加的方式，把命令的错误输出，输出到指定的文件或者是设备中。| ​​ 例如：执行 ls命令，我们就可以对ls命令输出的内容进行保存。ls &gt;abc 就代表把ls要输出的内容保存到文件abc中，如果是 ls&gt;&gt; abc 就会把输出的内容追加到文件abc中。​ 注意：如果命令格式错误，就需要在&gt;前加上2 例如 lst 2&gt; abc​ 但是在实际的使用过程中，我们不会提前知道命令格式是正确的还是错误的，所以以上两种命令的用处不大。 ===通常使用的是以下命令，把正确命令和错误命令都可以同时的保存： | 动作 | 命令 |说明| | ------ |:--------:| :-----:| | 正确输出和错误输出同时保存 | 命令 &gt; 文件名 | 以覆盖的方式，把命令的正确输出，输出到制定的文件或者是设备中 | | 正确输出和错误输出同时保存 | 命令 &gt;&gt; 文件名 | 以追加的方式，把命令的正确输出，输出到指定的文件或者是设备中 |​​ 输入重定向​ 本来的输入是通过键盘直接输入的，现在我们通过文件的方式来输入，这就是输入重定向。 命令格式： wc 【选项】【文件名】 选项： -c 统计字节数 -w 统计单词数 -l 统计行数 4. 多命令顺序执行与管道符命令；命令 多个命令顺序执行，命令之间没有逻辑联系 命令1 &amp;&amp; 命令2 逻辑与 命令1执行完之后，命令2才会继续往下执行 **管道符** 命令1 | 命令2 命令1的正确输出作为命令2的操作对象5. 通配符和特殊符号？ 匹配一个任意字符 \\* 匹配0个或者多个任意字符，也就是 可以匹配任何内容 [ ] 匹配中括号中任意一个字符，例如：[abc] 代表一定匹配一个字符，或者是a，或者是b，或者是c。 [ - ] 匹配 括号中任意一个字符，- 代表一个范围，例如 [a-z] 代表匹配一个小写的字母 **Bash中的其他特殊符号** ‘ ’ 单引号，在单引号中的所有的特殊符号 如 “$” “\\” 都是没有特殊含义的 “ ” 双引号 在双引号中特殊符号都是没有特殊含义。但是”$” “\\” 是例外的。拥有调用变量的值。 例如给变量赋值 name = sc ‘ ’ 反引号的作用，反引号括起来的是系统命令。在bash中会优先的执行它。它的作用和$() 作用是一样的，不过推荐使用的是$() ，因为反引号在使用的过程中容易看错。 \\# 在bash中 #开头的代表注释 $ 在调用变量的值，如果需要调用变量的的值的时候，需要使用$加变量名 的方式来获取到变量的值。3. Bash的变量1. 用户自定义变量&amp;emsp;&amp;emsp;在bash中，变量的默认类型都是字符串类型的，如果要进行数值运算，就需要指定变量 类型为数值型。 **注意：** - 变量是用等号连接，而且等号左右两端不能有空格 - 变量的值如果有空格，需要使用单引号或者是双引号包括 - 在变量的值中，可以使用 \\ 转义符 - 如果是把命令的结果作为变量赋值给变量，则需要使用单引号或者是$() 包括命令 变量的定义： 比如定义一个变量名为name的变量 name =” hello bianliang”,调用的时候，我们可以使用echo来调用 echo $name ![](https://i.imgur.com/VcpmtBC.jpg) name=&quot;hello bianliang&quot; echo $name 输出结果：hello bianliang 调用的时候只需要记住，在变量名之前加$符号 变量查看 set 变量删除 unset name 2. 环境变量主要保存的是和系统操作环境相关的数据。 用户自定义变量只在当前的shell中生效，而环境变量会在当前shell和这个shell的所有子shell中生效，如果把环境变量写入相应的 配置文件中那么这个环境变量就会在所有的shell中生效。 **设置环境变量** Export 变量名=变量值 #申明变量 例如我们定义两个变量 name=lei export sex =nan 我们通过set命令查看变量就会查看到两个已经定义好的变量，但是这个时候如果我们再进入一个bash（通过命令bash 进入， 我们可以通过pstree来查看进程数） env # 专门的用来查看变量的命令 Unset 变量名 # 删除环境变量3. 位置参数变量这种变量只要是用来向脚本当中传递参数或者是数据的，变量名不能自己定义，变量的作用是固定的，只能更改里面的值 | 位置参数变量 | 作用 | | ------ |:--------:| | $n | n在这里代表的是数字，$0 代表命令本身，$1--$9 代表的是第一到第九个参数，十个以上的参数需要用大括号 例如${10} | $* | 这个命令代表命令行中所有的参数，$* 把所有的参数看成一个整体 | $@ |这个命令也代表的是命令行中所有的参数，不过不同的是$@ 把每个参数区别对待 | $# | 这个命令代表命令行中所有参数的 个数我们通过一个简单的例子来查看一个使用方法，我们写一个bash&nbsp;Canshu.sh定义两个参数，然后输出两个参数的和 #!/bin/bash sum1=$1 sum2=$2 sum=$(($sum1+$sum2)) echo “sum is : $sum” 然后使用命令echo 给这个sh 赋予执行权限 Chmod 755 canshu.sh执行canshu.sh 并向这个sh传入两个参数 11 22 求和[root@iZwz92dpr9gpgasbo4gg15Z sh]# ./canshu.sh 11 22下面通过一个简单的sh来看一个几个位置参数的区别。Canshu2.sh \\#!/bin/bash echo $# echo $* echo $@ 赋予执行权限 [root@iZwz92dpr9gpgasbo4gg15Z sh]# chmod 755 canshu2.sh 输出结果： [root@iZwz92dpr9gpgasbo4gg15Z sh]# ./canshu2.sh 11 22 33 44 55 66 6 11 22 33 44 55 66 11 22 33 44 55 66 注意：$* 和$@的区别，具体的区别可以在for 循环中看出$*中的所有参数看成是一个整体，所有在for循环中只会循环一次$@ 中的每个参数都看成是相互独立的，所以$@ 中有几个参数，就会循环几次 例如： #!/bin/bash for x in &quot;$*&quot; do echo $x done for y in &quot;$@&quot; do echo $y done运行结果： [root@iZwz92dpr9gpgasbo4gg15Z sh]# chmod 755 canshu3.sh [root@iZwz92dpr9gpgasbo4gg15Z sh]# ./canshu3.sh 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 ###4.预定义变量 | 预定义变量 | 作用 | | ------ |:--------:| | $?| 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令是正确的；如果这个变量的值是非0（具体是哪一个数，由命令自己决定），则证明上一个命令执行不正确了。| | $$ | 当前进程的进程号| | $! | 后台运行的最后一个进程的进程号(PID)| 例如使用echo $? 我们就可以打印出 来看看上一条命令是否正确执行Echo $$ 查看当前进程号pid 接受键盘输入Read【选项】【变量名】选项：-p 提示信息—在等待read输入时，输出提示信息-t 秒数 read命令会一直等待用户输入，使用此选项可以指定等待时间-n 字符数： read命令只接受指定的字符数， 就会在执行-s 隐藏输入的数据，适用于机密信息的输入 4.base的运算符1. 数值运算和运算符Declare 声明变量类型 declare 【+/-】【选项】【变量名】 - 给变量设定类型属性 + 取消变量的类型属性 -i 将变量声明为整数型（integer） -x 将变量声明为环境变量 -p 显示指定变量的被生命的类型 数值运算：方法一： aa=11 bb=22 declare -i cc=$aa+$bb #将变量aa和bb 进行数值运算、方法二：使用expr或者let数值运算工具方法三：使用 $（（运算式）） 或者是 $[运算式]ff =$(($aa+$bb))推荐 使用方法三 2.变量测试和内容替换主要的作用是通过判断x的值来判断y是否有值 ##5. 环境变量配置文件1.环境变量配置文件简介Source命令Source 配置文件或者 .配置文件 环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH HISTZIZE PSI HOSTNAME等默认环境变量2.环境变量配置文件作用 /etc/下的环境变量对所有的用户都是生效的 /etc/profile /etc/profile.d/*.sh 二、Shell编程1. 基础正则表达式正则表达式和通配符 正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式,所以只能使用shell自己的通配符来进行匹配了。 通配符匹配的是文件名，正则表达式是指在一个文件中搜索符合要求的字符串 基础正则表达式 前一个字符匹配0次或任意多次. 匹配除了换行符外的任意一个字符^ 匹配行首 ^hell 匹配以hello开头的行 在搜索文件时， 我们可以通过grep命令来进行匹配 grep “aa*” 文件名 # 匹配至少包含一个a的行 grep “s..d” 文件名 # 会匹配在字母s和d之间一定有两个字符的单词2.字符截取命令Cut字段提取命令cut 【选项】 文件名 选项： -f 列号 提取第几列 -d 分隔符 按照指定分隔符分割列 注意：一般cut命令不独立使用，都是跟管道符grep命令配合使用 命令 df -h 查看分区使用率Printf命令 格式化打印命令，如果想要学习awk命令 需要先学习printf命令 输出类型 %ns ：输出字符串 n是数字代表输出几个字符 %ni 输出整数，n是数字指输出几个字符 %m.nf 输出浮点数在awk命令输出中支持print和printf命令Print： print命令会在每个输出之后自动加入一个换行符（Linux默认是没有print命令的，只能在awk中使用） Printf命令是标准格式输出命令，并不会自动增加换行符，如果需要换行，需要手动增加换行符。 Awk命令 命令格式 Awk ‘条件1{动作1} 条件2{动作2}...’ 文件名条件：一般使用条件关系表达式作为条件 X&gt;10 判断变量x是否大于10 X&gt;=10 大于等于 X&lt;=10 小于等于动作： 格式化输出 流程控制语句、 例如： 使用awk 命令输出df -h磁盘信息的第一列和第五列第六列 awk &apos;{print $1 &quot;\\t&quot; $5 &quot;\\t&quot; $6}&apos; [root@iZwz92dpr9gpgasbo4gg15Z ~]# df -h | awk &apos;{print $1 &quot;\\t&quot; $5 &quot;\\t&quot; $6}&apos; Filesystem Use% Mounted /dev/vda1 27% / devtmpfs 0% /dev tmpfs 0% /dev/shm tmpfs 1% /run tmpfs 0% /sys/fs/cgroup tmpfs 1% /run/user/0 [root@iZwz92dpr9gpgasbo4gg15Z ~]# *BEGIN 命令 * [root@iZwz92dpr9gpgasbo4gg15Z ~]# awk &apos;BEGIN{print{&quot;zhe shi yi ge begin &quot;} {print $1}&apos; 在所有的命令执行之前先执行begin命令Sed命令 sed命令是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 Sed是几乎包括在所有的UNIX平台当然也包括Linux的轻量级流编辑器。Sed主要是用来将数据进行选取、替换、删除、新增的命令。 和vi的区别，vi只能用来修改文件中的内容。Sed不仅能修改文件而且还可以直接修改命令的结果。在shell脚本中sed是一个非常重要的编辑器 命令格式:Sed 【选项】 ‘ 【动作】’ 文件名 选项： -n ：一般sed命令会把所有数据都输出到屏幕上，如果加上这个选项，则只会把sed命令处理过的行输出到屏幕上 -e ：允许对输入数据应用多条sed命令编辑 -i ：用sed修改结果直接修改读取数据的文件，而不是由屏幕直接输出动作： a\\: 追加，在当前行后添加一行或者多行。添加多行时，除最后一行外，每行末尾都需要用\\ 代表数据完结 Sed ‘2a zhuijia de neirong’ 文件名 这样我们就在文件中的第二行的后面追加了我们输出的内容 c\\ : 行替换 i\\: 行插入 Sed ‘2i charu’ 文件名 在第二行之前插入了一个内容为charu的内容 d\\: 删除，删除指定的行 P: 打印，打印指定的行 h 拷贝模板块的内容到内存中的缓冲区。 H 追加模板块的内容到内存中的缓冲区。 g 获得内存缓冲区的内容，并替代当前模板块中的文本。 G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l 列表不能打印字符的清单。 n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p 打印模板块的行。 P(大写) 打印模板块的第一行。 q 退出Sed。3.字符处理命令排序命令 Sort 【选项】 文件名 选项 -f ：忽略大小写 -n ：以数值型进行排序，默认的是使用的字符串型进行排序 -r ：反向排序 -t ：指定分隔符，默认的分隔符是制表符 -k n[,m] : 按照指定的字段范围排序，从第n个字段开始，m字段结束，默认是到行尾。统计命令wc Wc 【选项】文件名 选项： -l 只统计行数 -w 只统计单词数 -m 只统计字符数4.条件判断按照文件类型进行判断 -b：判断文件是否存在，并且是否为块设备文件 -c：判断该文件是否存在，并且是否是字符设备文件 -d：判断该文件是否存在，并且是否是目录文件 -e：判断该文件是否存在 -f：判断该文件是否存在。并且是否是普通文件判断格式： test -e /root/install.log 可以判断root目录下install.log文件是否存在或者 [ -e /root/install.log] 也可以进行判断 两个文件之间进行比较 文件1 -nt 文件2 ：判断文件1的修改时间是否比文件2的新 文件1 -ot 文件2: ：判断文件1的修改时间是否比文件2的旧 文件1 -ef 文件2 ： 判断文件1是否和文件2的inode号是否一致，可以理解为两个文件 是否是同一个文件。这个判断用于判断硬链接是很好的方法。两个整数之间的比较 整数1 -eq 整数2 ：判断整数1是否和整数2相等 整数1 -ne 整数2 ：判断整数2是否和整数2不相等 整数1 -gt 整数2 ：判断整数1是否大于整数2 整数1 -lt 整数2 ：判断整数1是否小于整数2 整数1 -ge 整数2 ：判断整数1是否大于等于整数2 整数1 -le 整数2 ：判断整数1是否小于等于整数2字符串的判断 -z 字符串 ：判断字符串是否为空 -n 字符串 ：判断字符串是否为非空 字符串1==字符串2 ：判断字符串1是否和字符串2相等 字符串1！=字符串2：判断字符串1是否和字符串2不相等多重条件判断 判断1 -a 判断2 ：逻辑与，判断1和判断2都成立，最终的结果才为真 判断1 -o 判断2 ：逻辑或，判断1和判断2有一个成立，最终的结果就为真 ！判断 ： 逻辑非，使原始的判断式取反5.流程控制1.if语句我们在进行判断的时候；[-e /root] 判断root文件是否存在，如果存在我们可以通过命令行 echo $? 返回0 就说明存在，如果返回的是非0，就说明不存在。或者[-e /root] &amp;&amp;echo yes || echo no 单分支if条件语句 If [条件判断式] ; then 程序 fi 或者 If [ 条件判断式] then 程序 fi注意：是以if 开头 以fi 结尾条件判断式中就是使用test命令判断，所以中括号和条件判断式之间必须有空格then后面跟的是符合条件之后执行的程序，可以放在[] 之后，用；分割，也可以换行写入，就不需要了 双分支if条件语句 If [条件判断式] then 条件成立时，执行的程序 else 条件不成立时，执行的另一个程序 Fi多分支if条件语句 If [条件判断1] then 条件成立时，执行的程序 elif 条件判断2成立时，执行程序2 else 当所有条件都不成立时，最后执行此程序 Fi 2.case语句case只能判断一种条件关系，而if语句可以判断多种条件关系、 Case $变量名 in “值1”) “执行语句” ：： “值2”) “执行语句” ... Esac3.for循环语法格式： For 变量 in 值1 值2 值3 ... Do 程序 Done","categories":[{"name":"Linux与Shell编程","slug":"Linux与Shell编程","permalink":"http://yoursite.com/categories/Linux%E4%B8%8EShell%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-05-01T02:20:32.000Z","updated":"2021-05-16T11:04:06.709Z","comments":true,"path":"2018/05/01/Linux常用命令/","link":"","permalink":"http://yoursite.com/2018/05/01/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Linux常用命令","text":"Linux常用命令 文件处理命令mkdir 创建目录 mkdir -p 可以递归创建 pwd 显示当前目录 cd .. 回到上一级目录 rmdir 删除空目录 cp -rp 源文件或者是目录 目标目录----复制文件 touch 创建空文件 cat 查看文件 more 分页显示文件内容 -- 按空格或者是f可以一页一页往下翻，按回车一行一行往下翻，按q退出 ，按b返回上一屏 less 分页显示内容 , 可以上下翻页。而且输入/ 可以进行搜索，搜索完可以进行标记 ln -s 源文件 目标文件 为文件创建连接，连接类型分为软连接和硬链接文件搜索命令find 搜索范围 匹配条件否例如 find /etc -name init 在etc文件夹下搜索init名称的文件 文件压缩和解压缩命令gzip 文件 就可以对该文件进行压缩gzip只能压缩文件不能压缩文件夹，而且是不保留源文件的 打包文件夹：使用 tar -cvf 【压缩后文件名】【目录文件名】.tar.gz 一般是先打包在压缩后的文件名 我们可以直接使用命令 【】tar -zcf 123.tar.gz 123 直接对文件夹123进行打包并进行压缩 解压缩：-x 解包 -v显示详细信息 -f 指定解压文件 -z解压缩例如; tar -zxvf 123.tar.gz 命令详解 tar-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -xf all.tar这条命令是解出all.tar包中所有文件，-t是解开的意思 压缩tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压tar -xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar -xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip 总结1、.tar 用 tar -xvf 解压2、.gz 用 gzip -d或者gunzip 解压3、.tar.gz和.tgz 用 tar -xzf 解压4、.bz2 用 bzip2 -d或者用bunzip2 解压5、.tar.bz2用tar -xjf 解压6、.Z 用 uncompress 解压7、.tar.Z 用tar -xZf 解压8、.rar 用 unrar e解压9、.zip 用 unzip 解压","categories":[{"name":"Linux与Shell编程","slug":"Linux与Shell编程","permalink":"http://yoursite.com/categories/Linux%E4%B8%8EShell%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"OraclePL/SQL高级编程(块 过程 动态PL/SQL)","slug":"2018-04-20-OraclePLSQL高级编程(块-过程-动态PLSQL)","date":"2018-04-20T06:56:32.000Z","updated":"2021-05-16T11:04:06.705Z","comments":true,"path":"2018/04/20/2018-04-20-OraclePLSQL高级编程(块-过程-动态PLSQL)/","link":"","permalink":"http://yoursite.com/2018/04/20/2018-04-20-OraclePLSQL%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(%E5%9D%97-%E8%BF%87%E7%A8%8B-%E5%8A%A8%E6%80%81PLSQL)/","excerpt":"1.PLsql是什么？ PL/SQL(procdure language/sql) : 是对oracle标准的一个sql语言的扩展，是在oracle数据库上进行编程的语言。","text":"1.PLsql是什么？ PL/SQL(procdure language/sql) : 是对oracle标准的一个sql语言的扩展，是在oracle数据库上进行编程的语言。 2.为什么要用PL/SQL？ （1）SQL语句不能进行模块化编程， 例如淘宝：如果仅用sql语句的话，那么下一个订单可能需要发送好几条SQL语句 这样不方便， 写好一个模块，专门完成下订单的功能，当需要下订单的时候，只需要传入参数，调用模块就可以了 （2）执行速度上：传统的sql，涉及到sql语句的网络传输时间，还有一个是dbms对sql语句的一个编译的时间 效率不高 PLsql：sql语句是写在数据库中的只需要编译一次，并且还是省去了sql语句的网络传输时间，效率比较高 （3）安全性的问题：sql语句如果直接写在程序或者客户端中，在网络传输的过程中会产生一些不安全因素 比如sql注入等。PLSQL：sql语句是写在数据库里面的，不需要网络传输，避免了这个问题 （4）传统sql浪费带宽，而plsql节省带宽 PLSQL的缺点 PL/SQL的一致性不好。（oracle的存储过程，放到其他数据库中不能用，需要重新编写） 4.快速入门： 问题：编写一个过程，往emp表中中插入一条记录 12345create procedure prol is begin insert into emp(empno,ename,sal,deptno) values(1011,'lili',3000,20); end; 如何调用：exec prol; 总结; (1)语法 注意过程中，语句后面需要加分号 语句最后 / 结束 1234567create procedure 过程名(参数1 参数类型1，参数2 参数类型2) is 变量定义begin执行部分 exception 异常处理部分 end; （2）过程调用的方法 1234567exec 过程名（参数1，参数2...）问题：创建一个过程：输入一个员工编号，删除emp表中对象的员工记录create procedure pro2(no number) isbegin delete from emp where empno=no;end; –注意：数据类型不能加长度 –===== show error 可以查看错误是什么 –出现编译错误 show error 可以查看错误的详细信息 也可以把错误的编号复制到百度上 –5.PL/SQL可以做什么事情？ 创建 过程 函数，包（包体） 触发器==&gt;&gt;基础都是块编程6.PL/SQL块编程（1）注释：单行注释：– 多行注释 /* */ （2）标识符的命名规范： 当定义变量的时候，以v_ 比如v_ename 当定义常量的时候 以c_开头 当定义游标的时候，用_cursor结尾 当定义例外（异常）的时候，用e_开头 ​ （3）块结构 declare(可选) 声明变量，常量，游标，例外和复杂的数据类型 begin 执行部分 ：要执行的PL/SQL语句和SQL语句 exception 异常处理部分：主要处理各种错误 end; 案例（只包括执行部分的SQL块）输出一个Hello Worder！ 1234begin dbms_output.put_line('Hello Word'); end; set serveroutput on 注意（1）dbms_output.put_line(内容)；Oracle 中的输出语句 -- dbms_output是Oracle所提供的包（类似于JAVA的包）该包中包含了一些过程put_line是dbms_output --的一个过程 --包含定义部分和执行部分的PL/SQL块案例：根据用户的输入的雇员编号，输出该雇员的名字 123456declare V_ename varchar2(10); begin select ename into v_ename from emp where empno=&amp;no; dbms_output.put_line('姓名是'||v_ename); end; --注意：变量的定义：变量名 变量类型 （长度）; --select ename into e_ename from emp where empno=&amp;no --select....into...from 表示是对变量e_ename赋值 --empno=&amp;no 符号表示需要从键盘接收一个empno，案例：将上述PL/SQL块改为一个过程 123456create (replace) procedure pro3 (v_empno number) is --(replace)有就替换，没有就创建v_ename emp.ename%type;begin select ename into v_ename from emp where empno=v_empno; dbms_output.put_line('姓名是'||v_ename);end; --总结：过程中，变量定义是出现在is和begin之间的，没有declare --emp.ename%type 表示v_ename 的类型和emp表的ename的数据类型和长度完全相同 案例：包含定义部分，执行部分和例外处理部分的PL/SQL块 问题：如果在上述案例输入了不存在的员工编号，这个时候会报错，怎么处理？ 123456789declare v_ename emp.ename%type; begin select ename into v_ename from emp where empno=&amp;no; dbms_output.put_line('姓名是'||v_ename); exception when no_data_found then dbms_output.put_line('你输入的编号不存在'); end; --异常处理的结构基本语法： exception when 异常名称 then /* 对异常处理的代码 */ when 异常名称 then /* 对异常处理的代码 */ --有些时候，异常还用来做逻辑跳转案例：输入员工编号，显示员工姓名，如果我们输入一个不存在的员工编号，就在emp表中插入一条记录 –(1002,’马大哈’) 1234567891011121314151617181920 declare v_ename emp,ename%type; begin select ename into v_ename from emp where empno=&amp;no; dbms_output.put_line('姓名是'||v_ename); exception when no_data_found then insert into emp(empno,ename)values(1002,'马大哈'); end;declare v_ename emp.ename%type; v_ename emp.empno%type:=&amp;no; begin select ename into v_ename from emp where empno=v_empno; dbms_output.put_line('姓名是'||v_ename); exception when no_data_found then insert into emp(empno,ename)values(1002,'马大哈'); end; 变量的赋值：在PL/SQL中变量的赋值是用 ：= 例如v_ename emp.ename%type:=’JONE’; 123456declare v_emp emp%rowtype; begin select *into v_emp from emp where empno=7839; dbms_output.put_line('姓名是'||v_emp.ename||'工资是'||v_emp.sal); end; --总结一下：%rowtype表示记录类型，v_ename emp%rowtype --使用：v_emp.ename(字段名)7.过程的进一步讲解–（1）过程中，不但可以指定输入参数，也可以指定输出参数 create procedure 过程名(参数1 参数类型1，参数2 参数类型2) is 变量定义 begin 执行部分 exception 异常处理部分 end; --注意1：过程可以指定多个输入和输出参数，分别是参数 in 参数类型：参数 out 参数类型 --注意2：如果没有指明的情况下，默认的是in（即输入参数） 编写一个过程，可以输入员工的姓名，新的工作，可以修改雇员的工资 1234create procedure pro4(name in varchar2,new_sal in number) is begin update emp set sal=new_sal where ename=name; end; 一下是我在学习的过程中，具体的案例，结合案例对PLSQL的流程控制做进一步的说明 PL/SQL的流程控制–案例1：编写一个存储过程，输入一个雇员姓名，如果该员工工资低于2000，给该员工工资增加10% 123456789create or replace procedure updateSal(spName varchar2) isv_sal emp.sal%type;begin select sal into v_sal from emp where ename=spName; if v_sal&lt;2000 then update emp set sal=sal*1.1 where ename=spName; end if;end;exec updateSal('SMITH'); 总结：if...then...end if;如果if后面的条件满足，则执行then后面的语句–案例2：编写一个存储过程，输入一个雇员姓名，若奖金非空，在原基础上加100，若奖金为0或空，把奖金设为200 12345678910create or replace procedure updateComm(spName varchar2) isv_comm emp.comm%type;begin select nvl(comm,0) into v_comm from emp where ename=spName; if v_comm=0 then update emp set comm=200 where ename=spName; else update emp set comm=comm+100 where ename=spName; end if;end; 总结：if...then...else...end if;如果if后条件成立，执行then后面语句，否则执行else后面语句–案例3：编写一个存储过程，如果职位是president,工资+1000，manager，+500,其它岗位+200 123456789101112create or replace procedure updateSal1(spName varchar2) isv_job emp.job%type;begin select job into v_job from emp where ename=spName; if v_job='PERSIDENT' then update emp set sal=sal+1000 where ename=spName; elsif v_job='MANAGER' then update emp set sal=sal+500 where ename=spName; else update emp set sal=sal+200 where ename=spName; end if;end; 总结：if 条件1 then 执行语句1 elsif 条件2 then 执行语句2 else 执行语句3 end if;–案例4：创建一张表users，循环插入10条记录 12345678910create table users(id number(3),name varchar2(10));create or replace procedure insertTable(spName varchar2) isv_num number:=1;begin loop insert into users values(v_num,spName); v_num:=v_num+1; exit when v_num=11; end loop;end; 总结：loop...end loop:首先定义一个循环变量，其次在loop和end loop之间一定要写退出循环的条件，否则就是死循环。–案例5:编写一个存储过程，可以输入用户名，并循环往users表中添加10条记录 12345678create or replace procedure insertTable1(spName varchar2) isv_num number:=11;begin while v_num&lt;=20 loop insert into users values(v_num,spName); v_num:=v_num+1; end loop;end; --总结：while 循环条件 loop 执行内容;循环控制语句;end loop; 注意：必须有退出循环的条件，否则是死循环–案例6：使用for循环实现案例5功能 123456create or replace procedure insertTable2(spName varchar2) isbegin for i in 21..30 loop insert into users values(i,spName); end loop;end; 总结：for 循环变量 in 21..30(序列，表示21到30的一个序列)loop...end loop;–案例7：用三种循环语句实现1+2+…+100 1234567891011declarev_counter number:=1;v_sum number:=0;begin loop v_sum:=v_sum+v_counter; v_counter:=v_counter+1; exit when v_counter=101; end loop; dbms_output.put_line('和是：'||v_sum);end; 12345678910declarev_counter number:=1;v_sum number:=0;begin while v_counter&lt;=100 loop v_sum:=v_sum+v_counter; v_counter:=v_counter+1; end loop; dbms_output.put_line('和是：'||v_sum);end; 12345678declarev_sum number:=0;begin for i in 1..100 loop v_sum:=v_sum+i; end loop; dbms_output.put_line('和是：'||v_sum);end; –案例8：case语句，从键盘接受一个输入，如果输入A，输出优秀，输入B，输出良好，输入C输出中等，其它情况，输出不及格 1234567891011121314declarev_grade char(2):=&amp;grade;begin case v_grade when 'A' then dbms_output.put_line('优秀'); when 'B' then dbms_output.put_line('良好'); when 'C' then dbms_output.put_line('中等'); else dbms_output.put_line('不及格'); end case;end; –总结：case 变量 when 值1 then 操作1；when 值2 then 操作2;…else 操作; end case; 2.动态SQL:动态SQL：编译期间SQL 语句是不确定的，并且在运行时允许发生变化–应用场合：要执行一个DDL语句时;需要增加程序的灵活性时;使用包DBMS_SQL动态执行SQL语句时–案例1：编写pl/sql块，创建一张test001(id number(2),name varchar2(10)); 123begin execute immediate 'create table test001(id number(2),name varchar2(10))';end; 总结：PLSQL块中不能直接执行DDL语句，所以可以用动态sql去执行–execute immediate sql语句 12345declarestmt varchar2(200):='create table test002(id number(2),name varchar2(10))';begin execute immediate stmt;end; –案例2：编写一个pl/sql块，往test001中插入一条记录，要求值是从键盘输入 123456declarev_id test001.id%type:=&amp;id;v_name test001.name%type:=&amp;name;begin execute immediate 'insert into test001 values(:1,:2)' using v_id,v_name;end; –总结：execute immediate sql语句 using 值1，值2，…;–:1,:2：需要用到变量的地方用:1,:2来代替 –案例3：查询test001，从键盘接收id，输出其姓名 1234567declarev_id test001.id%type:=&amp;id;v_name test001.name%type;begin execute immediate 'select name from test001 where id=:1' into v_name using v_id; dbms_output.put_line('姓名是：'||v_name);end; 总结：execute immediate sql语句 into 变量1 using 变量2; (1)sql语句中没有select...into... (2)where id=:1:1是占位符，表示这个地方在运行的时候需要有一个值替代–案例4：从键盘输入一个员工编号，查询该员工的姓名和工资，如果工资小于2000元，那么给他增加500，返回增加后的工资。 1234567891011declarev_empno emp.empno%type:=&amp;no;v_ename emp.ename%type;v_sal emp.sal%type;begin select ename,sal into v_ename,v_sal from emp where empno=v_empno; if v_sal&lt;2000 then execute immediate 'update emp set sal=sal+500 where empno=:1 returning sal into :2' using v_empno returning into v_Sal; end if; dbms_output.put_line('新工资是：'||v_Sal);end; 总结：execute immediate sql语句 using 变量1 returning into 变量2; update emp set sal=sal+500 where empno=:1 returning sal into :2 意思是更新sal,返回更新后的工资。–案例5：从键盘接受一个员工编号，删除该员工信息 declare v_empno emp.empno%type:=&amp;no; begin execute immediate &apos;delete from emp where empno=:num&apos; using v_empno; end;总结：占位符在这里可以是:num形式 3.异常处理–案例1：编写一个PL/SQL块，查询emp表中员工的工资 12345678910declarev_sal emp.sal%type;begin select sal into v_sal from emp;exception when too_many_rows then dbms_output.put_line('找到多条记录！'); when others then dbms_output.put_line('未知异常！');end; 用户抛出异常。案例2：从键盘输入一个empno,查询该员工的工资，如果工资小于2000，报异常。 12345678910111213declarev_sal emp.sal%type;v_empno emp.empno%type:=&amp;no;myexp exception;begin select sal into v_sal from emp where empno=v_empno; if v_sal&lt;2000 then raise myexp; end if;exception when myexp then dbms_output.put_line('工资太少了，该加工资了！');end; 总结：（1）declare中预定义一个异常;(2)在执行部分，触发异常raise myexp;（3）在exception中处理异常。​​​","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle数据库实例和数据库、系统用户的区别","slug":"2018-03-12-Oracle数据库实例和数据库、系统用户的区别","date":"2018-03-12T05:56:32.000Z","updated":"2021-05-16T11:04:06.705Z","comments":true,"path":"2018/03/12/2018-03-12-Oracle数据库实例和数据库、系统用户的区别/","link":"","permalink":"http://yoursite.com/2018/03/12/2018-03-12-Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"1 引言（1）为什么要使用数据库？淘宝网订单数据保存什么地方的？文件，数据库文件保存数据不方便：（1）安全性问题（2）不利于查询和管理（3）不利于海量数据的存储（4）文件在程序中不容易控制","text":"1 引言（1）为什么要使用数据库？淘宝网订单数据保存什么地方的？文件，数据库文件保存数据不方便：（1）安全性问题（2）不利于查询和管理（3）不利于海量数据的存储（4）文件在程序中不容易控制 （2）什么是数据库？数据库：数据的仓库，数据库是一个软件，是专家们设计出来的便于进行数据管理的软件。可以类比图书馆：图书馆：存放图书的 数据库：存放数据的 数据库 磁盘上存储的数据的集合 在物理上表现为数据文件、日志文件和控制文件等 在逻辑上以表空间形式存在 必须首先创建数据库，然后才能使用Oracle（3）数据库的三层结构 （4）主流数据库微软：sqlserver 和 access(小巧，免费，不占资源，数据量不大，系统功能不多，安全性要求不高的时候，可以使用) Mysql:MySQL（开源的）较轻量级的数据库 Ibm:db2(主要做海量数据的存储和处理) Oracle:Oracle 大型数据库，比较安全，服务好 Sysbase:(专注于Linux下的开发，金融领域用比较多) （5）项目中如何去选择数据库？1.项目标的是什么？2.功能要求 3.安全性和稳定的要求 4.多少人用？（考虑并发） 5.操作系统（Linux/Unix/Windows/MacOS） Oracle的服务：必须开启的服务：OracleService OracleOraDb11g_home1TNSListener 如果使用企业管理器，还需启动：OracleDBConsoleorcl 2.数据库和数据库实例的概念数据库 磁盘上存储的数据的集合在物理上表现为数据文件、日志文件和控制文件等在逻辑上以表空间形式存在必须首先创建数据库，然后才能使用Oracle 数据库实例 每个启动的数据库都对应一个数据库实例，由这个实例来访问和控制数据库 为了运行数据库，Oracle系统所运行的所有进程和分配的内存结构的组合体 注意：数据库：磁盘上，永久的 数据库实例：内存中的，临时的。 数据文件，控制文件，日志文件，表空间： 数据文件 扩展名是.DBF，用于存储数据库数据的文件 数据库表和数据文件不存在一对一对应关系 l控制文件 扩展名是.CTL，是数据库启动及运行所必需的文件 默认包含3个控制文件，各个控制文件内容相同 l日志文件 扩展名是.LOG，它记录了对数据的所有更改信息 多个日志文件组之间循环使用 l表空间 每个Oracle数据库都是由若干个表空间构成，用户在数据库中建立的所有内容都被存储到表空间中 创建数据库时会自动创建若干表空间 每个Oracle数据库都是由若干个表空间构成，用户在数据库中建立的所有内容都被存储到表空间中 创建数据库时会自动创建若干表空间：SYSAUX SYSTEMTEMP USER UNDO,分别对应Oradata目录下的5个DBF文件。","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle数据库中的函数、视图和索引","slug":"2018-02-20-Oracle数据库中的函数、视图和索引","date":"2018-02-20T06:56:32.000Z","updated":"2021-05-16T11:04:06.704Z","comments":true,"path":"2018/02/20/2018-02-20-Oracle数据库中的函数、视图和索引/","link":"","permalink":"http://yoursite.com/2018/02/20/2018-02-20-Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E3%80%81%E8%A7%86%E5%9B%BE%E5%92%8C%E7%B4%A2%E5%BC%95/","excerpt":"1. Oracle函数Oracle SQL 提供了用于执行特定操作的专用函数。这些函数大大增强了 SQL 语言的功能。函数可以接受零个或者多个输入参数，并返回一个输出结果。 Oracle 数据库中主要使用两种类型的函数：","text":"1. Oracle函数Oracle SQL 提供了用于执行特定操作的专用函数。这些函数大大增强了 SQL 语言的功能。函数可以接受零个或者多个输入参数，并返回一个输出结果。 Oracle 数据库中主要使用两种类型的函数： 1. 单行函数：对每一个函数应用在表的记录中时，只能输入一行结果，返回一个结果，比如： MOD(x,y)返回 x 除以 y 的余数（ x 和 y 可以是两个整数，也可以是表中的整数列）。常用的单行函数有：对每一个函数应用在表的记录中时，只能输入一行结果，返回一个结果，比如： MOD(x,y)返回 x 除以 y 的余数（ x 和 y 可以是两个整数，也可以是表中的整数列）。常用的单行函数有： 字符函数：对字符串操作。 数字函数：对数字进行计算，返回一个数字。 转换函数：可以将一种数据类型转换为另外一种数据类型。 日期函数：对日期和时间进行处理。 2. 聚合函数：聚合函数同时可以对多行数据进行操作，并返回一个结果。比如 SUM(x)返回结果集中 x 列的总合。聚合函数同时可以对多行数据进行操作，并返回一个结果。比如 SUM(x)返回结果集中 x 列的总合。 字符函数字符函数接受字符参数，这些参数可以是表中的列，也可以是一个字符串表达式。下表列出了常用的字符函数。 数字函数数字函数接受数字参数，参数可以来自表中的一列，也可以是一个数字表达式。 说明： ROUND(X[,Y])，四舍五入。在缺省 y 时，默认 y=0；比如： ROUND(3.56)=4。y 是正整数，就是四舍五入到小数点后 y 位。 ROUND(5.654,2)=5.65。y 是负整数，四舍五入到小数点左边|y|位。 ROUND(351.654,-2)=400。 TRUNC(x[,y])，直接截取，不四舍五入。在缺省 y 时，默认 y=0；比如： TRUNC (3.56)=3。y 是正整数，就是四舍五入到小数点后 y 位。 TRUNC (5.654,2)=5.65。y 是负整数，四舍五入到小数点左边|y|位。 TRUNC (351.654,-2)=300。 日期函数日期函数对日期进行运算。常用的日期函数有：1.SYSDATE:显示系统当前日期 例：select sysdate from dual ADD_MONTHS(date,n)，在某一个日期 date 上，加上指定的月数 n，返回计算后的新日期。date 表示日期， n 表示要加的月数。 例：select add_months(sysdate, 6) six_month_later from dual; LAST_DAY(date)，返回指定日期当月的最后一天。例：select last_day(sysdate) from dual; 4.NEXT_DAY(date,char)：返回date日期的下一个周几，周几是由char决定的。 例：select NEXT_DAY(SYSDATE, ‘星期三’) from dual;Char:中文环境中用中文，英文环境中用英文。5.MONTHS_BETWEEN(DATE1,DATE2):计算date1和date2两个日期间的间隔。注意是date1-date2 例：select months_between(sysdate, ’17-1月-17’) from dual;例：计算emp表中职员入职多少个月。 ROUND(d[,fmt])，返回一个以 fmt 为格式的四舍五入日期值， d 是日期， fmt 是格式模型。默认 fmt 为 DDD，即月中的某一天。 12345如果 fmt 为“YEAR”则舍入到某年的 1 月 1 日，即前半年舍去，后半年作为下一年。如果 fmt 为“MONTH”则舍入到某月的 1 日，即前月舍去，后半月作为下一月。例：select round(to_date(‘2009-09-25’, ‘yyyy-mm-dd’), ‘MONTH’) round_date from dual;例：select round(to_date(‘2009-09-25’, ‘yyyy-mm-dd’), ‘YEAR’) round_date from dual;例：select round(to_date(‘2009-09-25’, ‘yyyy-mm-dd’)) round_date from dual; 与 ROUND 对应的函数是TRUNC(d[,fmt])对日期的操作， TRUNC 与 ROUND 非常相似，只是不对日期进行舍入，直接截取到对应格式的第一天。 例：select TRUNC(to_date(‘2009-09-25’, ‘yyyy-mm-dd’), ‘MONTH’) trunc_date from dual; 例：select TRUNC (to_date(‘2009-09-25’, ‘yyyy-mm-dd’), ‘YEAR’) trunc_date from dual; 例：select TRUNC (to_date(‘2009-09-25’, ‘yyyy-mm-dd’)) trunc_date from dual; EXTRACT(fmt FROM d)，提取日期中的特定部分。fmt 为： YEAR、MONTH、DAY、HOUR、MINUTE、SECOND。其中 YEAR、MONTH、DAY可以为 DATE 类型匹配，也可以与TIMESTAMP 类型匹配；但HOUR、MINUTE、SECOND 必须与 TIMESTAMP 类型匹配。例：EXTRACT 函数示例 12345678Select sysdate “date”,Extract(year from sysdate) “year”Extract(month from sysdate) “month”Extract(day from sysdate) “day”Extract(hour from systimestamp) “hour”Extract(minute from systimestamp) “minute”Extract(second from systimestamp) “second”From dual; 转换函数转换函数将值从一种数据类型转换为另外一种数据类型。常用的转换函数有： TO_CHAR(d|n[,fmt])把日期和数字转换为制定格式的字符串。 fmt 是格式化字符串，日期的格式化字符串前面已经学习过。代码演示：TO_CHAR 对日期的处理SQL&gt; SELECT TO_CHAR(SYSDATE,’YYYY”年”MM”月”DD”日” HH24:MI:SS’) “date” FROM DUAL; TO_DATE(x [,fmt])将一个格式字符串转换成日期 NVL(x,value)如果 x 为空，返回 value，否则返回 x。案例 7：对工资是 2000 元以下的员工，如果没有发奖金，每人奖金 100 元。 123代码演示：NVL 函数SQL&gt; SELECT ENAME,JOB,SAL,NVL(COMM,100) FROM EMP WHERE SAL&lt;2000;ENAME JOB SAL NVL(COMM,100) NVL2(x,value1,value2)如果 x 非空，返回 value1，否则返回 value2。案例 8：对 EMP 表中工资为 2000 元以下的员工，如果没有奖金，则奖金为 200 元，如果有奖金，则在原来的奖金基础上加 100 元。 123代码演示：NVL2 函数SQL&gt; SELECT ENAME,JOB,SAL,NVL2(COMM,comm+100,200) &quot;comm&quot;2 FROM EMP WHERE SAL&lt;2000; COALESCE(expr1[,expr2[,expr3]]…)返回参数列表中第一个非空的表达式的结果。 1例：select ename,sal,comm,COALESCE(sal+comm,sal)salary FROM emp WHERE deptno=30; LNNVL(condition)：通常用在where子句中，返回那些不满足condition条件或者判断条件为NULL的记录。所有LNNVL也可以认为是is null 或is not true。 12例：获取奖金数小于500的员工的信息Select ename,comm from emp where lnnvl(comm&gt;=500); 1.DECODE(expr, search1,result[, search2, result2…][, default])DECODE用于比较参数expr的值，如果匹配到哪一个search条件，就返回对应的result结果。可以有多组search和result的对应关系，如果任何一个search条件都没有匹配到，返回最后default的值。Default参数是可选的，如果没有提供default参数值，当没有匹配到时，返回NULL。 123例：查询职员表，根据职员的职位计算奖金，当职位分别是MANAGER,ANALYST,SALESMAN时，奖励金额分别是薪水的1.2倍，1.1倍，1.05倍。如果不是这三个职位，则奖励金额为领取薪水值Select ename,job,sal, decode(job,’MANAGR’,sal*1.2, ‘ANALYST’,sal*1.1,’SALESMAN’,sal*1.05,sal)bonus from emp; 总结：函数可以嵌套使用–==========字符函数：处理字符串======== 第一组–ascii chr select ascii(&apos;a&apos;) from dual; select char(97) from dual;–lower upperinitcap–求大写A 的ascii select ascii (upper(&apos;a&apos;)) from dual;–求小写a的ascii select ascii (lower(&apos;A&apos;)) from dual;–Initcap select initcap(ename) from emp; 第二组–ltrim rtrim trim–注意事项 Ltrimrtrim 是字符级别的截取，在截取的时候，按照字符去匹配 select Ltrim(&apos;ellen&apos;,&apos;e&apos;) from dual; select rtrim(&apos;ellenellneen&apos;,&apos;ne&apos;) from dual; select trim(&apos;ne&apos;,from &apos;ellenellneen&apos;) from dual;–会报错，，trim的截取集只能是一个字符 select trim(&apos; ellen&apos;) from dual; --去空格--第三组–Lpad rpad 字符串补位函数 左补齐 select lpad(&apos;hao&apos;,2,&apos;ni&apos;) from dual; select lpad(&apos;hao&apos;,5,&apos;ni&apos;) from dual; select lpad(&apos;hao&apos;,10,&apos;ni&apos;) from dual;右补齐 select rpad (&apos;ni&apos;,1,&apos;hao&apos;) from dual; select rpad (&apos;ni&apos;,5,&apos;hao&apos;) from dual; select rpad (&apos;ni&apos;,10,&apos;hao&apos;) from dual;其他组–concat–字符串连接：和连接运算符作用一致 select concat (&apos;Dear&apos;,ename) from emp;–legth：查询emp员工表中员工姓名为5个字符的员工信息 select *from emp where length(ename)=5;–substr:求子串 select substr(&apos;Hello word&apos;,3) from dual; select substr(&apos;Hello word&apos;,3,5) from dual;–replace:字符串替换 select replace(&apos;shelly&apos;,&apos;el&apos;,&apos;en&apos;) from dual;可以分组去记 –===============数学函数=================== –sign :求符号 select sign(-5) from dual;–ceil: 求上整 select ceil(5.6) from dual;–floor 求下整 select floor(5.6) from dual;–round 四舍五入 select round(3.14) from dual select round(3.14,1) from dual select round(3.1415926,4) from dual select round(356,-2) from dual --一般是不用的–trunc：截断 select trunc(3.1415926,4) from dual; select trunc(356,-2) from dual–=============日期函数====================== --sysdatesystimestamp（比sysdate）更精确 select sysdate from dual; --add_months(date,1)1表示月份 select add_months(sysdate,1) from dual; --month_between(date,date) select months_between(sysdate,hiredate) from emp; select month_between(sysdate,add_months(sysdate,1)) from dual;​ –last_day(date) select last_day(sysdate) from dual; select last_day(‘08-2月-2018’)from dual; --next_day(date,char) select next_day(sysdate,&apos;星期二&apos;) from dual;–round 四舍五入–trunc：截断也可以对日期进行操作 select trunc(sysdate,&apos;MONTH&apos;) from dual; select round(sysdate,&apos;MONTH&apos;) from dual; select round(date&apos;2018-01-16&apos;,&apos;MONTH&apos;) from dual;—extract: select extract(year from sysdate) as 年, extract(month from sysdate) as 月, extract (day from sysdate) as 日, extract (hour from systimestamp) as 时, extract (minute from systimestamp) as 分, extract(second from systimestamp) as 秒 from dual;–===========转换函数================ to_char to_date–nvl nvl2–问题：对emp表中的员工奖金为空，那么给200元奖金，如果奖金不为空，那么在原有奖金基础上加100 update emp set comm=nvl2(comm,comm+100,200);–问题：查询emp表中所有员工的月收入 select ename，sal+nvl(comm,0) as 月收入 from emp; select ename,coalesec(sal+comm,sal) as 月收入 from emp;–decode–案例：按照职位提升工资，如果是MANAGER，工资是原来的1.5倍，如果是ANALYST工资是原来的1.2倍–如果是SALERSMAN工资是原来的1.1倍，默认情况下，工资是原来的1.05倍 update emp01 set sal=decode(job,&apos;MANAGER&apos;,sal*1.5,&apos;ANALYST&apos;,sal*1.2 ,&apos;SALERMAN&apos;，sal*1.1,sal*1.05)2. 数据库中的视图（1）什么是视图？视图是一张虚表，就是对select查询的结果给取了一个名字。select查询的表称为基表视图不会存储数据，数据存储在基表中，视图只是保存一个映射关系 create view test as select ename,sal,job from emp;（2）视图的作用1.简化复杂查询 2.限制数据访问 –简化复杂查询–举例：查询每个部门的员工人数和部门名称 select d.dname,count(*) from dept d,emp e where d.deptno=e.deptno group by d.dname;可以创建视图存储上述结果 create view numEmp as select d.dname,count(*) co from dept d,emp e where d.deptno=e.deptno group by d.dname; 问题：查询人数大于3的部门的名称和员工信息 select *from numEmp where co&gt;3;–创建视图的时候，如果遇到select语句中有聚合函数，需要给聚合函数别名 --限制数据访问举例 create user hope identified by 123456; grant connect to hope; grant select on scott.emp to hope; --现在是可以看见整张表 create view empSimple as select empno,ename,job,mgr,hiredate,deptno from emp;–注意事项：（1）对于视图的查询和表的查询是一样的 （2）视图中不包含数据，视图只是一个映射关系（3）当基表发生改变时，视图也会随之改变 （3）怎么创建和删除视图语法： create view 视图名(可以起别名) as select...from ...【with read only】 --with read only 表示视图是一个只读视图，只能查询，不能修改–分类：简单视图（创建视图的时候可以指定一个别名） create view v_emp(“工号”,“姓名“) as select empno,ename from emp; ‘ create or replace view v_emp(&quot;编号&quot;,&quot;姓名‘) as select empno,ename from emp with read only;注意事项：别名，要么没有引号，要是有引号就必须是双引号 “ “** question：能不能对视图进行DML操作insert update delete？ 能，但是不是所用的视图都能进行DML操作 牵扯到视图的分类（1）非只读的简单视图可以进行DML操作，事实上是对基表的操作 create or replace view test as select empno,ename from emp; insert into test values(1010,&apos;sheely&apos;)可以看到基表里面多了一条记录 是不是所有的简单视图都可以进行DML操作呢？不是的 create or replace view test as select ename,sal from emp; insert into test values(&apos;haloo&apos;,5000)执行不了，不允许插入 原因是：违反了基表的主键约束 结论：针对视图的DML操作，不能违反基表的约束，所以并不是所有的简单的都可以（2）带有with read only 和复杂视图 连接视图不能进行ＤＭＬ操作 -修改视图 replace： 没有就创建，有的话就修改 视图的分类简单视图：简单查询语句（不涉及到连接和聚合函数） 复杂视图：牵扯到聚合函数，但是不涉及到表连接 连接视图：涉及到表连接的视图 –连接视图举例： CREATE view emp_dept as select e.*,d.* where e.deptno=d.deptno;（4）什么是索引？类比图书的目录：索引是一种加快数据访问速度的机制索引需要占用磁盘空间的，维护索引需要资源开销，所以索引并不是越多越好 索引的分类：（1）单列索引（2）复合索引 –单列索引 create index idx_ename on emp(ename) 语法：create index 索引名on 表名(字段名1，字段名2)–复合索引 create index idx_ename_deptno on emp(ename,deptno);–唯一索引 create unique index idx_ename on emp(ename); --注意;在某一字段上创建一个唯一索引，自动会在该字段创建一个唯一约束 --删除：drop index 索引名 drop index idx_ename;’ --重建 alter index idx_ename rebuild;注意事项：如果定义了主键约束和唯一约束，那么Oracle会再自动的创建一个唯一索引 +++++++原创博文，转载请注明出处。+++++++++","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle数据库的基本操作添加/修改约束以及表结构的修改序列","slug":"2018-02-10-Oracle数据库的基本操作--添加修改约束以及表结构的修改&序列","date":"2018-02-19T08:56:32.000Z","updated":"2021-05-16T11:04:06.701Z","comments":true,"path":"2018/02/19/2018-02-10-Oracle数据库的基本操作--添加修改约束以及表结构的修改&序列/","link":"","permalink":"http://yoursite.com/2018/02/19/2018-02-10-Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C--%E6%B7%BB%E5%8A%A0%E4%BF%AE%E6%94%B9%E7%BA%A6%E6%9D%9F%E4%BB%A5%E5%8F%8A%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%AE%E6%94%B9&%E5%BA%8F%E5%88%97/","excerpt":"1.约束表的约束往表中插入数据的时候，可能出现一些问题，比如：重复插入数据，内容不对（性别）——-如何保证数据库表中数据的完整性和一致性呢？约束常见的约束：主键（primary key），外键（foreign key）,唯一（unique）,非空（not null）,默认（default）,用户自定义（check）","text":"1.约束表的约束往表中插入数据的时候，可能出现一些问题，比如：重复插入数据，内容不对（性别）——-如何保证数据库表中数据的完整性和一致性呢？约束常见的约束：主键（primary key），外键（foreign key）,唯一（unique）,非空（not null）,默认（default）,用户自定义（check） 2. 约束分类—–常见的约束有： 主键约束（primary key）， 外键约束（foreign）， 唯一（unique），非空（not null） 默认（default） 用户自定义约束（check）2.1 primary key 主键约束 什么是主键约束？ 主键约束就是给表定义一个主键，什么是主键？？主键只要是用来保证表记录的唯一非空的。 主键（PRIMARY KEY ）约束：唯一的标识表中的每一行，不能重复，不能为空。 创建主键或唯一约束后，ORACLE 会自动创建一个与约束同名的索引（UNIQUENES 为UNIQUE 唯一索引）。需要注意的是：每个表只能有且有一个主键约束。 什么是主键约束？主键约束就是给表定义一个主键，什么是主键？ --主键主要是用来保证表记录的唯一非空的。建表的时候添加主键 12create table student(stuno number(4) primary key,stuname varchar2(10),age number(2),addr varchar(50));insert into student values(1001,'zhang',18,'luoyang'); 再次插入相同记录，违法主键约束，不允许插入 123SQL&gt; insert into student values(1001,'zhang',18,'luoyang');insert into student values(1001,'zhang',18,'luoyang')ORA-00001: 违反唯一约束条件 (SYS.SYS_C0010797) 如果主键为null也不允许插入，同样是违反了主键约束 12SQL&gt; insert into student values(null,'zhang',18,'luoyang');insert into student values(null,'zhang',18,'luoyang') 创建一张课程表： 1create table course(cno number(4) primary key,cname varchar2(20),cscore number(2)); –创建一张成绩表：学号和课程号共同作为一个主键，称为联合主键一张表只能有一个主键 123create table score(sno number(4),cno number(4),score number(5,2)，constraint pk_score primary key (sno,cno));drop table course;create table course(cno number(4) constraint pk_course primary key ,cname varchar2(20),cscore number(2)); 特别说明：不推荐大家使用复合主键。2.2 unique 唯一唯一（UNIQUE ）约束：在表中每一行中所定义的这列或这些列的值都不能相同。必须保证唯一性。否则就会违法约束条件。用于指定列的值不能重复，可以为 null 1234举例：create table user2(id number unique,name varchar2(30));insert into user2 values(1,111);//id 输入重复的值是会报错注意：oracle 中 中 unique 可以为 null ，而且允许多行为 nul 唯一约束： –问题：student(sno,sname,age,addr,idcard)主键：sno，idcard(身份证号)：可以为空，但是如果写的话要求唯一–创建唯一约束： (1)创建唯一约束方法一 123456create table student(sno number(4) primary key,sname varchar2(20) not null,age number(3),addr varchar2(50),idcard number(18) unique); 2)创建唯一约束方法二 123456create table student(sno number(4) primary key,sname varchar2(20) not null,age number(3),addr varchar2(50),idcard number(18) constraint uk_idcard unique); （3）创建唯一约束方法三 123456create table student(sno number(4) primary key,sname varchar2(20) not null,age number(3),addr varchar2(50),idcard number(18),constraint uk_idcard unique(idcard)); 2.3 not null 非空非空（NOT NULL ）约束：顾名思义，所约束的列不能为 NULL 值。否则就会报错 123举例：create table user1(id number,name varchar2(30) not null);insert into user1 values(001,'');//会报错 –非空约束和默认约束 123456create table student(sno number(4) primary key, --主键约束sname varchar2(20) not null, --非空约束age number(3) default 18, --默认约束addr varchar2(50),idcard number(18) unique); --唯一约束 2.4 foreign key 外键约束 references外键（FOREIGN KEY ）约束：用来维护从表（Child Table）和主表（Parent Table）之间的引用完整性.能够维护数据库的数据一致性，数据的完整性。防止错误的垃圾数据入库； 用于定义主表和从表之间的关系，外键约束要定义在从表上，主表则必需具有主键约束或是 e unique 约束，当定义外键约束后，要求外键列数据必需在主表的主键列存在或是为 null 外键约束 外键 在另外一张表中是主键student(sno sname,age,addr.udcard) 主键snocourse （cno，cname ccouse）主键snoscore （sno cno score）主键（sno ，cno） 外键：一个是sno 一个是cno——–外键是做什么用的？如果student中没有学号1001学生信息，那么score中也不应该有该学生成绩 在score插入数据的时候，如果学生student中不存在对应学号或者课程表中不存在对应课程 则不允许插入 1234567891011create table class(id number primary key,name varchar2(32));create table stus(id number primary key,name varchar2(36) not null,classid number references class(id));特别说明：froeign key 外键的细节1 、外键指向主键列；2 、外键可以指向 unique 列；3 、建表时先建主表，再建从表；删除表先删从表，再删主表。4 、外键列属性值要与主键或 unique 列属性值的类型保持一致5 、外键列的值，必需在主键列中存在。但外键列的值允许为 null **外键约束：外键：在另外一张表中是主键** –student(sno,sname,age,addr,idcard) 主键：sno–course(cno,cname,cscore) 主键：cno–score(sno,cno,score)主键： (sno,cno) 外键：sno 外键: cno 外键做什么用？如果student表中没有1001学生信息，那么score表中也不应该有该学生的成绩。 往成绩表插入数据的时候，如果学生表中不存在对应的学号，或者课程表中不存在对应的课程，则不允许插入 1234567891011create table student(sno number(4) primary key,sname varchar2(20) not null,age number(3),addr varchar2(50),idcard number(18)); create table course(cno number(4)primary key,cname varchar2(20),cscore number(2)); 1.创建外键约束的第一种方式 12345create table score(stuno number(4) references student(sno), --创建第一个外键约束couno number(4) references course(cno), --创建第二个外键约束score number(5,2),constraint pk_score primary key(stuno,couno)); --创建一个主键约束 2.创建外键约束的第二种方式 12345create table score(stuno number(4) constraint fk_stuno references student(sno), --创建第一个外键约束couno number(4) constraint fk_couno references course(cno), --创建第二个外键约束score number(5,2),constraint pk_score primary key(stuno,couno)); 3.创建外键约束的第三种方式 123456create table score(stuno number(4),couno number(4),score number(5,2),constraint fk_stuno foreign key(stuno) references student(sno),constraint fk_couno foreign key(couno) references course(cno),constraint pk_score primary key(stuno,couno)); 外键约束总结 –总结1：在一张表中只能有一个主键，但是可以有多个外键。 –总结2：作为外键的字段名，不一定必须和被参考表一致。 –总结3：定义了外键约束之后，往表中插入一条记录，外键值会参考其父表中主键的值，只有父表中存在该值才能插入成功 –往student表中插入3条记录 123insert into student values(1001,'zhangsan',19,'henanluoyang',98765432123456789);insert into student values(1002,'lisi',19,'henanluoyang',98765432123456789);insert into student values(1003,'wangwu',19,'henanluoyang',98765432123456789); 查看student表中所有内容 1select * from student; 查看course表中所有记录 1select * from course; –思考：insert into score values(1003,9997,89);能成功吗？不能，因为course表中不存在课程号为9997的课程 –思考：insert into score values(1003,9998,89);能成功吗？可以，因为1003在student表中存在，9998在course表中存在 –总结4：定义外键约束之后，删除父表中的记录，需要先将相关子表的记录删除 1234delete from student where sno=1003; --删除不掉，提示： 违反完整约束条件 (SYS.SYS_C0010808) - 已找到子记录--正确的做法：delete from score where stuno=1003; --先删子记录delete from student where sno=1003; --后删父记录 2.5 check 检查，用户自定义约束条件（CHECK ）约束：表中每行都要满足该约束条件。条件约束既可以在表一级定义也可以在列一级定义。在一列上可以定义任意多个条件约束 12345举例：create table user4(id number primary key,sal number check(sal&gt;=1000 and sal&lt;=2000),sex char(2) check(sex in('男','女')));insert into user4 values(1,1000,' 男');//sal 列的值不满足 1000 至 至 2000 用户自定义约束(检查约束)check(约束条件) 123456create table student(sno number(4) primary key,sname varchar2(20) not null,age number(3) default 18 check(age between 10 and 45), ---定义学生年龄默认为18，自定义约束条件为在10到45岁之间addr varchar2(50),idcard number(18) unique); ------身份证号唯一性约束条件 定义学生性别必须为男或者女 1234567create table student(sno number(4) primary key,sname varchar2(20) not null,gender char(2) check(gender in('男','女'))， -------定义学生性别必须为男或者女age number(3) default 18 check(age between 10 and 45),addr varchar2(50),idcard number(18) unique); 总结：定义了完整性约束之后，表中记录的插入，删除，修改必须符合表的完整性约束条件， 如果违反了完整性约束条件，则不允许操作 二、Oracle修改表结构修改表结构 –问题：给student表添加字段regdate类型是date; 12alter table student add regdate date;alter table student add province varchar2(350); 删除刚才添加的字段 12alter table student drop column regdate;alter table student drop(province,regdate); –修改字段类型和长度 12alter table student modify idcard char(18);alter table student modify idcard char(20); 修改表名 1alter table student rename to stu; 修改字段名 1alter table stu rename column gender to sex; 4.给表添加约束知识点4：如果建表的时候，没有添加约束，那么建好表之后，如何给表添加约束？drop table stu cascade constraints; 1234567create table student(sno number(4),sname varchar2(20),gender char(2)，age number(3),addr varchar2(50),idcard number(18)); –添加主键约束 alter table student add constraint pk_sno primary key(sno);–添加唯一约束 alter table student add constraint uk_idcard unique(idcard);–添加检查约束 alter table student add constraint ck_age check(age between 18 and 50);–添加非空约束 alter table student modify sname not null;–添加默认约束 alter table student modify age default 18; create table score(sno number(4),score number(5,2));–添加外键约束alter table score add constraint fk_sno foreign key(sno) references student(sno); –禁止某个约束 alter table score disable constraint fk_sno;–启用某个约束 alter table score enable constraint fk_sno;–删除约束 alter table score drop constraint fk_sno;–删除student表的主键约束： alter table student drop primary key;5.序列–序列是什么？有序的数字组成的一个排列 1 2 3 4 5 6 7–做什么用？序列是一个独立的数据库对象，主要用来生成主键–怎么用? –创建序列： create sequence seq01 --seq01序列名 start with 3 --序列的起始值 increment by 1 --步长 maxvalue 9999 --序列的最大值 minvalue 0 --序列的最小值 nocycle --nocycle(表示序列不循环)|cycle(表示序列循环使用) cache 20; --cache 20(为了加快序列的生成速度，每次生成20个值，放到缓存中)|nocache（不往缓存中存放序列值，使用一次，生成一次）–currval:返回序列的当前值，不会引起序列自增–nextval：返回序列的下一个值，会引起序列自增–查看序列的下一个值，会引起序列自增select seq01.nextval from dual;–第一次使用序列的时候，必须使用 序列名.nextval –查看序列的当前值 select seq01.currval from dual; –序列的使用： 1insert into student values(seq01.nextval,'zhang','男',18,'河南信阳','123456789987654321'); 如果下一个表还要引用这个序列则接着这个序列自动增加。 –注意事项：一个sequence可以供多张表使用的。可能造成主键值的不连续。 –删除序列：drop sequence seq01; 整理不易，转载请注明出处。","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle数据库中的高级查询以及表连接/内连接/外连接","slug":"2018-02-18-Oracle数据库中的高级查询以及表连接内连接外连接","date":"2018-02-18T05:56:32.000Z","updated":"2021-05-16T11:04:06.704Z","comments":true,"path":"2018/02/18/2018-02-18-Oracle数据库中的高级查询以及表连接内连接外连接/","link":"","permalink":"http://yoursite.com/2018/02/18/2018-02-18-Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%86%85%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%BF%9E%E6%8E%A5/","excerpt":"主要针对以下问题进行讲解：1.列别名和表别名2.select…from where…group by….having….order by…3.order by 排序 正序，逆序，单列排序，多列排序4.rownum rowid Oracle的伪列5.函数：单行函数（日期函数，字符函数，数学函数，转换函数，其他），多行函数6.聚合函数（max ,min avg,sum,count）7.group by 分组8.having关键字","text":"主要针对以下问题进行讲解：1.列别名和表别名2.select…from where…group by….having….order by…3.order by 排序 正序，逆序，单列排序，多列排序4.rownum rowid Oracle的伪列5.函数：单行函数（日期函数，字符函数，数学函数，转换函数，其他），多行函数6.聚合函数（max ,min avg,sum,count）7.group by 分组8.having关键字 1.列别名和表别名加类别名 语法： 字段名 as 字段别名 select ‘dear ‘||ename from emp; 针对表中字段的别名称为列别名 第一种写法： select ‘dear ‘||ename as 姓名 from emp; as 是可以省略的 第二种写法：别名可以加双引号 select ‘dear ‘||ename “姓名” from emp; 双引号可以省略 有一种情况双引号不能省略：别名中有空格，双引号不能省略 表别名语法 ： 表名 表别名–查询10部门的员工的姓名和工作 select ename,sal,job from emp where deptno=10; –给emp表一个别名 语法 ： 表名 表别名 select e.ename,e.sal,e.job from emp e where e.deptno=10; select ename,sal,job from emp e where deptno=10; 一张表可以这样不会出问题，但是多张表后就不可以了。 --规则：一旦给了表别名后，所有字段的使用都要：表别名.字段名 -- 注意 ：表别名是没有as的2.select…from where…group by….having….order by…注意事项：（1）select ...from...必不可少的 eg：select sysdate from dual; （2）该语句的执行顺序，按照这样的顺序where...group by...having...order by... （3）这些关键字不能掉换顺序，可以没有，但是如果有的话，是不能掉换顺序的3.order by 排序 正序，逆序，单列排序，多列排序 单列排序 问题：查询emp表中员工的姓名，工资，按照工资降序排序 select ename,sal from emp order by sal desc; 问题：查询emp表中员工的姓名，工资，按照工资升序排序 select ename,sal from emp order by sal asc; asc可以省略，默认情况下就是升序排列 --总结：语法结构：select....from...order by 字段名 asc/desc --ASC是升序，desc是降序 如果不写默认是升序123456问题：查询部门20的员工的姓名和工资，并且按照工资进行降序排序select ename,sal from emp where deptno=20 order by sal desc;多列排序--问题：查询emp表中的员工的姓名，部门编号，工资，先按照部门进行升序排列，同部门内部按照工资进行降序排列 select ename,deptno,sal from emp where deptno=20 order by deptno asc,sal desc; 多列排序总结： （1）多列排序语法 order by 字段名1 asc|desc 字段名2 asc|desc （2）多列排序的执行顺序，先按照字段1排序，然后在字段1排序的基础上，然后再按照字段2排序，，，，以此往下 4.rownum rowid Oracle的伪列rownum 主要是用来做分页过程（web开发中）** select *from emp; select rownum,emp.*from emp; （emp.* 别名） --rownum 相当于给查询结果的每一行编一个序列，并没有存储在emp表中 select rownum ，e.* from emp e where deptno=30; --可以看出rownum是动态变化的12345678问题1：查询emp表的前五条记录 select *from emp where rownum&lt;=5; 问题2：查询emp表中的3-5条记录 select *from emp where rownum&gt;=3 and rownum&lt;=5; 这样是查询不出来的，因为&gt;在rownum是无法使用的 select rownum ro,e.*from emp e where ro&gt;=3 and ro&lt;=5;同样解决不了。 select * from(select rownum ro,e.*from emp e) where ro&gt;=3 and ro&lt;=5; 这样就可以使用了（子查询） &gt; &gt;=符号是是不管用的 总结：（1）rownum&lt;2 rownum&lt;=2 rownum=1 这样是可以使用的 --不能是rownum&gt;2或者是rownum&gt;=2 rownum=2​ –重点 12345678问题3：查询emp表中工资最高的前五名的员工姓名，工作，工资 select ename,job,sal from emp where rownum&lt;=5 order by sal desc; //查询结果是不正确的，因为只对先进行取前五条，再进行了排序 select *from (select ename,job,sal from emp order by sal desc)x where rownum&lt;=5; 这样是正确的要先排序，再取前五行问题4：查询emp表中工资最高的3-5名员工的姓名，工作，工资 --分析 --（1）select ename ,job,sal from emp order by sal desc --记为x --（2）取x得3-5行:select *from (select rownum ro,x.* from x) where ro&gt;=3 and ro&lt;=5; --（3）替换 select *from (select rownum ro,x.* from (select ename ,job,sal from emp order by sal desc)x) where ro&gt;=3 and ro&lt;=5;​ rowid **:表示的记录的物理地址，不随记录的在查询结果中的顺序的改变而改变，唯一的且固定的 --并没有写在表结构中** select rowid,e.*from emp e; select rowid ,e.* from emp e where ename=&apos;CLARK&apos;;​ 聚合函数（max ,min avg,sum,count）问题1：求emp表中员工的总数 select count(*) from emp; 求记录的总数 也可以是这种形式 select count(empno) from emp; 问题2：求emp表中工资最高的那个员工的工资 select max(SAL) FROM EMP; 问题3：求emp表中工资最低的员工的工资 select min(sal) from emp; 问题4：求该公司员工的平均工资 select avg(sal) from emp; 问题5：求该公司每个月一个总开支（工资和奖金） select sum(sal+comm) from emp; //此处结果有问题 null和数值不能直接相加 select sum(sal+nvl(comm,0)) from emp; —补充：nvl(comm,0) :判断comm是否为null 要是null 返回为0，要不是null 返回comm sum语法：sum(distinct|all)参数：all表示对所有的值 (缺省),distinct只对不同的值解释：求总和 示例： select sum(distinct sal) from emp; select sum(all sal) from emp;avg语法：avg(distinct|all)参数：all表示对所有的值 (缺省),distinct只对不同的值解释：求平均值 示例： select avg(distinct sal) from emp; select avg(all sal) from emp;max语法：max(distinct|all) 参数：all表示对所有的值 (缺省),distinct只对不同的值解释：求最大值 示例： select max(distinct sal) from emp;min语法：min(distinct|all)参数：all表示对所有的值 (缺省),distinct只对不同的值解释：求最小值 示例： select min(all sal) from emp;count语法：count(distinct|all) 参数：all表示对所有的值 (缺省),distinct只对不同的值(相同值只取一次)解释：求记录、数据个数。 示例： select count(sal) from emp; select count(distinct sal) from emp;.group by 分组1234问题1：求emp表中每个部门的员工的总人数，请列出部门的编号和总人数,和平均工资select deptno,count(*),agv(sal) from emp group by deptno;问题2：求部门10的员工的个数，员工的平均工资，请列出部门的编号和总人数，以及平均工资 --group by 使用规则： --出现在select后面的字段，除了聚合函数之外，其他字段内容必须出现在group by之后 --如果不按照上述规则写，报错，不是单组分组函数，使用会出错。报错，不是单组函数或者不是group by表达式​ 问题3：查询部门10的员工人数和平均工资​ select count(*),avg(sal) from emp where deptno=10;​ –多字段分组的一个问题 问题4:查询emp表中每个部门，每个职位的员工人数； select deptno,job,count(*) from emp group by deptno,job; –注意：多字段分组，分组的顺序是按照字段的先后顺序来的 问题5：查询emp表中，每个部门的编号，并且按照部门人数进行降序排序 select deptno,count() from emp group by deptno order by count() desc; 8.having关键字，主要是和group连用，并且针对聚合函数条件进行二次条件限定的 问题6：查询emp表中每个部门的人数，找出人数大于3的部门，并按照总人数降序排列 select deptno,count() from emp group by deptno having count()&gt;3 order by count(*) desc; 注意事项： 注意事项：（1）聚合函数的条件，不能出现在from ，where子句，不能出现在group by 后面， 聚合函数可以出现在select子句，having子句 order by 子句 （2）where子句中放的是普通条件，不涉及到聚合函数的条件 （3）having 子句中不能放普通条件，涉及聚合函数的条件高级查询2主要针对以下问题进行说明：1.表连接（内连接，外连接（左外连接，右外连接，全外连接））2.表连接：两表连接，三表连接，四表连接3.子查询：单行子查询，多行子查询4.子查询：any all5.视图：什么是视图？视图的作用？怎么创建和删除视图？6.索引：什么是索引？索引的作用？怎么创建合适的索引？创建删除和维护索引语法？ 等值连接--1.问题：查询每个员工的部门名称，列出员工姓名和部门名称 select e.ename,d.dname from emp e,dept d where e.deptno=d.deptno–表连接中别名的使用：为了避免出现“未明确定义列”的错误，建议使用表别名.字段名的方式引用字段 总结：select…from 表1，表2，表3,… where 连接条件1 and 连接条件2 and …连接条件：e.deptno=d.deptno等值连接的条件，所以这种连接成为等值连接 不等值连接非等值连接是指在多个表之间使用非等号连接,查询在多个表中有非等值关联关系的数据。非等值连接操作符包括&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;以及between…and、like、in等。 例：查找每个员工的薪水等级 2. 问题：查询员工表中，每个员工的工资等级，列出员工姓名，工资和工资等级 select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal;自连接：自连接是一种特殊的连接，数据的来源是一个表，即关联关系来自于单表中的多个列。比如职员表中的经理列，就参照了本表中职员编码列，即经理也是机构下的职员之一。自连接是通过将表别名虚拟成两个表的方式实现，可以是等值的或不等值的连接。例：查询每个职员经理的名字以及经理的员工编号 --3. 查询所有比自己领导入职早的员工的姓名和上级领导的姓名 select w.ename as 员工姓名,m.ename as 上级领导姓名 from emp w,emp m where w.mgr=m.empno and w.hiredate&lt;m.hiredate;内连接：--1.问题：查询每个员工的部门名称，列出员工姓名和部门名称 select e.ename,d.dname from emp e inner join dept d on e.deptno=d.deptno;–总结：select…from 表1 inner join 表2 on 连接条件 where 查询条件 –问题：查询部门10中每个员工的工资等级 select e.ename,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal --连接条件 where e.deptno=10; --查询条件 --问题：查询emp表中部门名称为ACCOUNTING的员工的姓名，和部门位置 select e.ename,d.loc from emp e,dept d where e.deptno=d.deptno and d.dname=&apos;ACCOUNTING&apos;; select e.ename,d.loc from emp e inner join dept d on e.deptno=d.deptno where d.dname=&apos;ACCOUNTING&apos;;–查询高于自己部门平均工资的员工的信息，列出部门平均工资 --（1）获得每个部门的平均工资 select deptno,avg(sal) avg_sal from emp group by deptno; --x --(2) 将x表和emp表做表连接 select e.*,x.* from emp e,x where e.deptno=x.deptno and e.sal&gt;x.avg_sal; --(3)替换x select e.*,x.* from emp e,(select deptno,avg(sal) avg_sal from emp group by deptno)x where e.deptno=x.deptno and e.sal&gt;x.avg_sal;内连接和外连接针对内连接和外链接，我们通过图表进行详细说明 A表（父母表）：","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"数据库SQL语言以及常见操作","slug":"2018-02-16-数据库SQL语言以及常见操作","date":"2018-02-16T05:56:32.000Z","updated":"2021-05-16T11:04:06.704Z","comments":true,"path":"2018/02/16/2018-02-16-数据库SQL语言以及常见操作/","link":"","permalink":"http://yoursite.com/2018/02/16/2018-02-16-%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E8%AF%AD%E8%A8%80%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"SQL语言1.sql简介SQL：Structured Query LanguageOracle ： C/S 客户端发起请求，通过网络传递给服务器，服务器对请求进行响应","text":"SQL语言1.sql简介SQL：Structured Query LanguageOracle ： C/S 客户端发起请求，通过网络传递给服务器，服务器对请求进行响应 2.sql组成DDL（数据定义语言）：数据定义语言 DDL( Data Definition Language ) , 是 SQL 语言集中负责数据结构定义及数据库对象定义的语言 , 主要有 create、alter、drop 和 truncate 四种常用语句。对数据结构起作用。 例如 create alter drop 主要针对数据库对象的操作 注意：DDL语言使用的时候不需要提交，系统会自动提交 create 数据库对象的创建 alter 修改数据库对象 drop 删除数据库对象 truncate 清空表数据 DML（数据操纵语言）数据操纵语言 DML( Data Manipulation Language ) , 用户通过它可以实现对数据表的基本操作 ,即对表中数据的增、删、改。DML对数据起作用。 insert 插入操作 update 更新操作 delete 删除操作 select 查询操作DCL（数据控制语言）： 控制存取权限 grant revoke数据控制语言DCL（Data Control Language），用来控制存取许可、存取权限等。 grant 权限分配 revoke 权限回收TCL（事务控制语言）： commit rollback savepoint 主要针对的是DML操作的事务控制语言TCL（Transaction Control Language）是用来对 DML操作进行确认的。 commit 提交数据 rollback 回滚 下面针对每一种语言进行讲解： 3.DML语言1）insert 插入第一种插入方式 12345678910111213**第一种插入方式**--创建一张emp01表，复制emp表的结构。create table emp01 as select * from emp where 1=2;--往emp01中插入记录--给全部字段插入值insert into emp01 values(1001,'shelly','MANAGER',7839,date'1989-12-08',3000,NULL,10); 第二种插入方式 123给其中几个字段插入值，没有显示的字段默认nullinsert into emp01(empno,ename,sal,job,deptno)values(1002,'ellen',4000,'salseman',20); 第三种插入方式 123456789insert into emp01(empno,ename,job,sal,deptno)select 3001,'LILY','ANALYST',3000,30 from dual; 注：select 和 from 成对出现，如果from后面没有内容就用虚表dual--等价于：insert into emp01(empno,ename,job,sal,deptno)values(3001,'LILY','ANALYST',3000,30); 12345678--问题：从emp表中复制20部门员工信息，放入到emp01表中insert into emp01 select * from emp where deptno=20;--问题：往emp01表中插入一条ellen的记录，其余内容跟emp01表一致，empno在原来的基础上加1000insert into emp01(empno,ename,job,sal,deptno)select empno+1000,ename,job,5000,deptno from emp01 where ename=&apos;ellen&apos;; –一条insert语句插入多条记录 –问题：一条insert语句插入多条记录 1234567insert into emp01(empno,ename,sal,job)select 9999,'LILEI',3500,'MANAGER' from dual unionselect 9998,'Lucy',4500,'MANAGER' from dual unionselect 9997,'hanmeimei',5500,'MANAGER' from dual –union：Oracle的集合运算并运算，求并集,使用的时候会去重–union all:求并集运算，不去重 1234567891011select 9999,&apos;LILEI&apos;,3500,&apos;MANAGER&apos; from dual unionselect 9999,&apos;LILEI&apos;,3500,&apos;MANAGER&apos; from dual unionselect 9999,&apos;LILEI&apos;,3500,&apos;MANAGER&apos; from dualselect 9999,&apos;LILEI&apos;,3500,&apos;MANAGER&apos; from dual union allselect 9999,&apos;LILEI&apos;,3500,&apos;MANAGER&apos; from dual union allselect 9999,&apos;LILEI&apos;,3500,&apos;MANAGER&apos; from dual 需要注意的是： 注意事项： 1.插入记录时，字段的数据类型，长度 小数的精度 都要符合表的结构要求 2.插入数据的个数应该与字段个数一致 3.插入数据时，注意日期的处理格式 第一种 处理格式 date声明字符串是一个日期 第二种 使用默认日期格式 第三种 to_date函数将字符串转换为日期insert into emp01 values( , , , , , ,) 如果插入的自定义日期 前面要用date修饰一下 说明此处是一个日期 12345insert into emp01 values(1001,'shelly','MANAGER',7839,date'1989-12-08',3000,NULL,10);--使用默认日期格式insert into emp01 values(1001,'shelly','MANAGER',7839,'08-12月-1989',3000,NULL,10);--使用to_date将字符串转换为日期insert into emp01 values(1001,'shelly','MANAGER',7839,to_date('1989-12-08','yyyy-mm-dd'),3000,NULL,10); （2）delete删除 –删除表中所有数据 1delete from emp01； 但是表还是存在的 删除表是drop 语句 –删除表中符合条件的记录 –问题：删除emp01表中部门编号为10的记录–问题：删除emp01表中部门编号为10的员工的信息 1delete from emp01 where deptno=10; 注意事项： 1、如果不使用where子句，将删除表中所有的数据。(特别注意) 2、delete语句不能删除某一列的值(可使用update) 3、使用delete语句仅删除记录，不删除表本身。如要删除表，使用drop table语句。 4、同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题（主外键关联关系），在修改数据库数据时，头脑中应始终不要忘记这个潜在的问题。删除的几种方法比较：| delete from student where xh=’A001’; 删除一条记录 || ———————————————————— || delete from 表名; 删除所有记录，表结构还在，写日志，可以恢复的，速度慢 | truncate table 表名; 删除表中的所有记录，表结构还在，不写日志，无法找回删除的记录，速度快。 drop table 表名; 删除表的结构和数据 —- （3）update更新 –问题：更新emp01表中员工工资，如果工资小于1500，那么给员工涨1000； update emp01 set sal=sal+1000 where sal&lt;1500;语法： 12345update tableNameset 字段1=值1，字段2=值2，…字段n=值nwhere 条件; 注意事项： 1、update语法可以用新值更新原有表行中的各列； 2、set子句指示要修改哪些列； 3、where子句指定应更新哪些行。如没有where子句，则更新所有的行。示例： --对students中的数据进行修改 --将张三的性别改成女 SQL&gt;update students set sex=&apos;女&apos; where name=&apos;张三&apos;; --把张三的年级改为2 SQL&gt;update students set gradeid=2 where name=&apos;张三&apos;; --把所有人的成绩都提高10% SQL&gt;update students set score = score *1.1;（4）select 简单查询 查询所有列 select * from tableName; 12查询所有员工信息select * from emp; 查询指定列 12345select col1,col2,… from tableName;查询所有员工的员工号，姓名和工资select empno,ename,sal from emp; 去重查询（使用关键字distinct） 123查询所有员工所在的部门号。select distinct deptno from emp; 使用算术表达式 算术运算符用于执行数值计算，可以在SQL语句中使用算术表达式，算术表达式由数值数据类型的列名、数值常量和连接它们的算术操作符组成。算术操作符包括加(+)、减(-)、乘()、除(/)。查询员工的年薪select empno,ename,sal12 from emp; ** 使用列的别名** 123select ename \"姓名\",sal*13+nvl(comm,0)*13 \"年收入\" from emp; select ename 姓名,sal*13+nvl(comm,0)*13 年收入 from emp;select ename as \"姓名\",sal*13+nvl(comm,0)*13 as \"年收入\" from emp; PS：oracle在使用别名时，可以用双引号、不使用、使用as来表明别名。但不能使用单引号。 使用nvl函数来处理nullnvl是oracle提供的函数，是用于处理null值使用的。语法：nvl(值1,值2)解释：nvl值1为null时则取值2，值1不为null时则取值1原值。select empno,ename,(sal+nvl(comm,0))*13 from emp; 使用连接运算符 连接运算符（||），用于将多个字符串或数据值合并成一个字符串select ename||’年收入’||(sal13+nvl(comm,0)13) “雇员的年收入” from emp;select ename,’部门编号是’||deptno 部门编号 from emp; 使用where子句如果希望只查询一部分行，那么可以通过WHERE子句指定条件。WHERE子句的作用是通过指定条件，使SELECT语句仅仅查询符合条件的行。 在更多情况下，都需要根据指定的条件对数据进行查询。 WHERE子句指定的条件是一个关系表达式，如果关系表达式的结果为真，则条件成立，否则条件不成立。 关系表达式用于比较两个表达式的大小，或者进行模糊匹配，或者将一个表达式的值与一个集合中的元素进行匹配。 比较运算符 比较运算符用于比较两个表达式的值，操作符包括 =、!=、&lt;、&gt;、&lt;=、&gt;=、BETWEEN…AND、IN、LIKE 和IS NULL等 12345678（1）查询工资高于3000的员工信息。select * from emp where sal&gt;3000;（2）查询部门号是10的员工信息。 select * from emp where deptno=10;（3）查询工资在2000至3000之间的员工 select * from emp where sal between 2000 and 3000; 说明：between是指定区间内取值，如：between 2000 and 2500，取2000至2500内的值，同时包含2000和2500 like模糊查询在模糊查询中需要使用通配符。 查询员工姓名以S开头的员工信息select * from emp where ename like ‘S%’; 查询员工姓名第三个字符为大写O的所有员工的姓名和工资select ename,sal from emp where ename like ‘__O%’; 在where条件中使用in in运算符用来与一个集合中的元素进行比较。查询部门10,20的员工姓名及工资。select ename,sal from emp where deptno in (10,20); 在where条件中使用is null 在Oracle中使用IS NULL和IS NOT NULL来判断是否为空了。查询没有上级的员工信息select * from emp where mgr is null; 使用order by排序查询 Oracle中使用order by子句，对查询结果按照某一列进行排序查询，排序结果有升序（asc）和降序（desc）之分。默认排序结果是升序，即从小到大排序。 单一列排序按照工资的从低到高的顺序显示员工信息 select * from emp order by sal asc;PS：asc写或不写都是升序排序即从小到大排序，desc则是降序排序从大到小排序。 多列排序按照部门号升序而雇员的入职时间降序排列select * from emp order by deptno,hiredate desc; 使用列的别名排序select ename,sal*12 年薪 from emp order by 年薪 asc; TCL语言commit savepoint rollback 事务是对数据库操作的逻辑单位，在一个事务中可以包含一条或多条DML （数据操纵语言）、DDL （数据定义语言）和DCL （数据控制语言）语句，这些语句组成一个逻辑整体。 事务具有四个属性，这四个属性的英文单词首字母合在一起就是ACID 。这四个属性是： 原子性（ Atomicity ）：事务要么全部执行，要么全部不执行，不允许部分执行。 一致性（ Consistency ）：事务把数据库从一个一致状态带入另一个一致状态。 独立性（ Isolation ）：一个事务的执行不受其他事务的影响。 持续性（ Durability ）：一旦事务提交，就永久有效，不受关机等情况的影响。 一个事务中可以包含多条DML语句，或者包含一条DDL语句，或者包含一条DCL语句。 用于事务控制的语句有： COMMIT - 提交并结束事务处理 ROLLBACK - 撤销事务中已完成的工作 SAVEPOINT – 标记事务中可以回滚的点创建一个保存点： savepoint mark1 rollback to mark1； -----回滚到mark1保存点 commit ---提交 提交后不能再回滚。commit操作 示例：银行转账，小明给小红转账500元。 update custom set balance=balance-500 where name=’小明’; update custom set balance=balance+500 where name=’小红’; commit;rollback操作回滚事务有两种方式：完全回滚，即回滚到事务的开始；部分回滚事务，即可以将事务有选择地回滚到中间的某个点。部分回滚是通过设置保存点（ SAVEPOINT ）来实现的。 --部分回滚 … savepoint 保存点名称;//设置保存点 … rollback to [savepoint] 保存点名称;//回滚到保存点特别注意：设置保存点及回滚操作是配合delete语句使用，用来找回使用delete删除的数据。而通过truncate删除的表数据是无法通过此方法找回的。 建议： 在使用delete删除表数据前使用savepoint设置保存点，防止数据误删除。例子： 123456789--创建保存点：savepoint mark1 update emp01 set sal=sal+500 where comm is null;rollback to mark1;--回滚到mark1保存点commit; --提交 1234567SQL&gt; UPDATE students SET score = score + 5 WHERE score &lt;= 30;SQL&gt; SAVEPOINT mark1;SQL&gt; DELETE FROM students WHERE id= ‘100001’;SQL&gt; SAVEPOINT mark2;SQL&gt; ROLLBACK TO mark1;SQL&gt; COMMIT; PS：（1）在一个事务中可以保存多个保存点。（2）一旦回退后，该保存点就消失了，不能再次回退。（3）设置保存点是有资源开销的。（4）一旦提交了事务，则不能回退到任何保存点。 oracle的运算符算术运算符：+ - * / update emp01 set sal=sal+500 where comm is null;连接运算符:|| 123--问题：查询emp01中员工姓名，在员工姓名前面加上dearselect 'Dear '||ename from emp01; –问题：查询每个员工的工资，显示为：ellen的工资是：800 select ename||’的工资是：’||sal from emp01; 比较运算符: &gt; &gt;= &lt; &lt;= &lt;&gt;(!=) = is null between...and... inlike --问题：查询工资大于3000的员工的信息 select * from emp01 where sal&gt;3000; --问题：查询工资小于2000的员工的信息 select * from emp01 where sal&lt;2000; --问题：查询部门编号不为20的员工的信息 select * from emp where deptno&lt;&gt;20; select * from emp where deptno!=20;is null用来做空值的比较 1234567--问题：查询奖金为空的员工的信息select * from emp where comm is null;--问题：查询奖金不为空的员工的信息select * from emp where comm is not null; –注意：0和null不是一回事 between…and…:包含边界 --问题：查询工资在2000-5000之间的员工的信息 select * from emp where sal between 2000 and 5000; --等价于： select * from emp where sal&gt;=2000 and sal&lt;=5000;in：后面加的是一个集合 --问题：查询部门10或部门20中的员工的信息 select * from emp where deptno in(10,20); select * from emp where deptno=10 or deptno=20;like：用来进行模糊查询 通配符： _:表示匹配任意一个字符，必须有一个字符 %：表示匹配0个或者多个字符 []：表示匹配【】中的任意一个字符 1234567891011--问题：查询姓名中带有LLEN的员工信息select * from emp where ename like '%LLEN%';--问题：查询姓名以A开头，以N结束的员工的信息；select * from emp where ename like 'A%N';--查询员工姓名长度为5的员工的信息select * from emp where ename like '_ _ _ _ _'; 逻辑运算符:not and or 123456789--查询emp表中部门10中的MANAGER或者部门20中的CLERK，显示其详细信息select * from emp where deptno=10 and job='MANAGER'or deptno=20 and job='CLERK';--查询部门10或者20中MANAGERselect * from emp where (deptno=10 or deptno=20) and job='MANAGER';select * from emp where deptno in(10,20) and job='MANAGER'; 8.运算符的优先级:算术运算符&gt;连接运算符&gt;比较运算符&gt;not&gt;and&gt;or++++++++转载请注明出处++++++++++","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"使用Ajax同步请求增加页面等待提示","slug":"2018-02-16-使用Ajax同步请求增加页面等待提示","date":"2018-02-16T05:56:32.000Z","updated":"2021-05-16T11:04:06.703Z","comments":true,"path":"2018/02/16/2018-02-16-使用Ajax同步请求增加页面等待提示/","link":"","permalink":"http://yoursite.com/2018/02/16/2018-02-16-%E4%BD%BF%E7%94%A8Ajax%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%A2%9E%E5%8A%A0%E9%A1%B5%E9%9D%A2%E7%AD%89%E5%BE%85%E6%8F%90%E7%A4%BA/","excerpt":"使用Ajax同步请求增加页面等待提示最近在做项目时，有一个需求是批量打印好多个合同，使用AJAX向后台传送数据，等待后台执行后，需要把生成之后的文件地址传送过来。 后台的处理时间比较长，根据合同的多少可能等待时间比较长，会达到10s左右，这个时候如果不加任何的提示，会导致用户因为没有看到是否执行而导致重复的操作，为了增加用户的体验感，，以及项目的完善性， 这个时候就需要增加一个等待页面进行提示。","text":"使用Ajax同步请求增加页面等待提示最近在做项目时，有一个需求是批量打印好多个合同，使用AJAX向后台传送数据，等待后台执行后，需要把生成之后的文件地址传送过来。 后台的处理时间比较长，根据合同的多少可能等待时间比较长，会达到10s左右，这个时候如果不加任何的提示，会导致用户因为没有看到是否执行而导致重复的操作，为了增加用户的体验感，，以及项目的完善性， 这个时候就需要增加一个等待页面进行提示。 我们先来看一个Ajax同步请求与异步请求的区别： 异步和同步： ajax中 async属性是设置同步和异步，async:false,时表示此时ajax为同步请求，如果不写或者设置成true表示异步请求 123456$.ajax(&#123; type : \"get\", async:true, url : success : function(targetPath)&#123; &#125;, 当设置成同步时，意味着执行完当前的程序段，才能执行下一段，它属于阻塞模式，其表现在网页上面就是会出现页面假死现象，也就是暂停当前的页面，用户不能操作其它的，必须等待当前请求返回数据，在这个过程中用户看不到任何的提示以及等待提醒。 而使用异步方式请求，页面后再次段程序等待的时候，继续的向下执行，等待执行结束再返回结果，页面不会出现假死现象。 我现在遇到的问题是：点击一个按钮，使用Ajax向后台传送数据，等待后台的执行，由于后台执行时间过长，这个时候页面出现所谓的假死现象，容易引发误操作。 我的思路是：在ajax返回结果之前，增加一个遮罩层的函数显示效果，在执行之后，显示隐藏效果，于是我写了一个遮罩层的函数，准备放到ajax中。 我通过查阅各种帖子发现有类似的描述，说是可以使用ajax的一个属性进行设置 beforeSend: function(){)，类似： 1234567$.ajax(function()&#123;//省略了一些参数，这里只给出async 和 beforeSendasync: false, //同步请求，默认情况下是异步（true）beforeSend: function()&#123;$('#warning').text('正在处理，请稍等！');&#125;&#125;); 但是设置成这样效果是出不来的，因为beforeSend只有在ajax设置成异步请求时，才会显示出beforeSend中函数的效果。 在这里根据业务需要，ajax是不能改为异步的，因为必须等待文件地址返回后才能继续后面的操作。 除此之外，loading也使用过，还有各种加提示的方法，但是sys为异步时，效果都会无法显示。 在这个时候就需要引入一个JQuery中一个对象deferred，来对ajax进行封装异步函数。 主要使用的是deferred中 $.when的方法使用，主要是对多个deferred对象进行并行化操作，当所有deferred对象都得到解决就执行后面添加的相应回调 具体使用如下： 使用之前需要先进行声明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var defer = $.Deferred(); function toGetData() &#123; var defer = $.Deferred(); var checkedIds=$(\"input[name='backEntrust']:checked\"); if(checkedIds.length==0)&#123; alert(\"请选中要打印的合同\"); return false; &#125; var r=confirm(\"确定打印吗？\"); if (r==true)&#123; var enIds=new Array(checkedIds.length); for(var i=0; i&lt;checkedIds.length; i++)&#123; enIds[i] = checkedIds[i].value; &#125; $.ajax(&#123; type : \"get\", async:true, url :\"$&#123;pageContext.request.contextPath&#125;/renWuFenPeiService_mergerSample.action?entrustIds=\"+enIds, success : function(targetPath)&#123; defer.resolve(targetPath) &#125;, error : function() &#123; alert(\"样品检测委托单合并失败，请重试。\"); &#125; &#125;); &#125;else &#123; window.location.reload(); &#125; return defer.promise(); &#125; $('#batchPrint').on('click', function() &#123; loading(); 显示遮罩层函数 $.when(toGetData()).done(function(targetPath)&#123; $(\".shodow\").hide() $(\"#batchPrinttwo\").attr(\"href\",\"/file/\"+targetPath); document.getElementById(\"batchPrinttwo\").click(); loaded(); 取消遮罩层函数 &#125;); &#125;); 在这段代码中，我们可以看到ajax设置的是异步请求，但是我们需要的是同步请求啊，在这使用了JQuery中的deferred之后，我们想要的显示效果就出来了，我们就可以使用ajax的异同请求，达到同步的效果。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Oracle数据库 sqlplus常用命令","slug":"2018-02-10-Oracle数据库-sqlplus常用命令","date":"2018-02-10T05:56:32.000Z","updated":"2021-05-16T11:04:06.701Z","comments":true,"path":"2018/02/10/2018-02-10-Oracle数据库-sqlplus常用命令/","link":"","permalink":"http://yoursite.com/2018/02/10/2018-02-10-Oracle%E6%95%B0%E6%8D%AE%E5%BA%93-sqlplus%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Oracle学习思维导图 sql*plus常用命令（1）conn[ect]:切换用户（2）disc[onnect]:断开某个用户和数据库的连接（3）passw[ord]:修改用户密码（4）show user:查看当前用户（5）exit:退出数据库（6）desc[ribe] 表名：查看表结构 交互式命令：（1）&amp;:可以替代变量，而在变量执行的时候，需要用户输入 Select * from emp where deptno=’&amp;deptno’; 注意：Oracle中字符串用单引号 （2）ed[it]:编辑指定的.sql文件的 edit C:\\a.sql （3）spool:可以将sqlplus屏幕上的内容输出到指定的文件中 Spool d:\\a.sql Select * from emp; 。。。查询结果Spool off 解锁用户和修改密码：（1）sqlplus连接到数据库：sqlplus sys/123456 as sysdba（2）输入解锁语句：alter user scott account unlock;（3）修改密码：alter user scott identified by 654321; passw【ord】用户名:可以去修改其他用户的密码。 passw:表示修改自己的密码。","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle中用户权限管理 数据类型和表的创建","slug":"2018-02-10-Oracle中用户权限管理-数据类型和表的创建","date":"2018-02-10T05:56:32.000Z","updated":"2021-05-16T11:04:06.701Z","comments":true,"path":"2018/02/10/2018-02-10-Oracle中用户权限管理-数据类型和表的创建/","link":"","permalink":"http://yoursite.com/2018/02/10/2018-02-10-Oracle%E4%B8%AD%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"一，Oracle的用户管理1. 创建用户在 oracle 中要创建一个新的用户使用 create user 语句，一般是具有 dba(数据库管理员)的权限才能使用。","text":"一，Oracle的用户管理1. 创建用户在 oracle 中要创建一个新的用户使用 create user 语句，一般是具有 dba(数据库管理员)的权限才能使用。 1） 创建用户 命令：create user 用户名 identified by 密码;12345--创建用户：--语法结构：create user 用户名 identified by 密码 【default tablespace 表空间名】【temporary tablespace temp】create user hope identified by 123456;create user hope1 identified by 123456 default tablespace users;create user hope2 identified by 123456 default tablespace users temporary tablespace temp; 2） 给用户修改密码 如果给别人修改密码则需要具有 dba 的权限，或是拥有 alter user 的系统权限命令：alter user 用户名 identified by 新密码 123--修改用户密码：--语法结构：alter user 用户名 identified by 密码alter user hope identified by 654321; 3） 修改自己的密码 如果给自己修改密码可以直接使用命令：password 用户名问题：创建好的用户无法正常登录？ oracle 中用户建立后是无法正常登录的，只有在数据库管理员(DBA)对用户分配相应的权限后，用户才可以登录。 2 删除用户概述：一般以 dba 的身份去删除某个用户，如果用其它用户去删除用户则需要具有 drop user 的权限。命令：drop user 用户名 [cascade]可选参数 cascade 在删除用户时， 注意： 如果要删除的用户，已经创建了表， 那么就需要在删除的时候带一个参数 cascade; Cascade 有级联的作用 1234--删除用户：--drop user 用户名【cascade】drop user hope;drop user hope cascade; 3. oracle 用户分配权限和角色概述：创建的新用户是没有任何权限的，甚至连登录的数据库的权限都没有，需要为其指定相应的权限。给一个用户赋权限使用使令 grant，回收权限使用命令 revoke 赋权限基本语法：grant 权限/角色 to 用户名;回收权限基本语法：revoke 权限/角色 from 用户名; --权限和角色 --权限指执行特定类型SQL命令或访问其他对象的权利 --系统权限：允许用户执行某些数据库操作 --对象权限：允许用户对某一特定对象执行特定的操作 --角色是具有名称的一组权限的组合 --常用系统预定义角色 --CONNECT：临时用户 --RESOURCE：更为可靠和正式的用户 --DBA：数据库管理员角色，拥有管理数据库的最高权限 --一般情况下，普通用户，有connect和resource的角色就够了。3.1 分配权限语法：grant create 权限 to 用户名;例如：给小明赋予会话的权限sql&gt; grant create session to xiaoming;–给hope2赋予查询scott的emp表的权限 12grant select on scott.emp to hope2;grant select,update on scott.emp to hope2; 3.2 分配角色也可以按 角色对用户分配权限语法：grant 角色名 to 用户名;例如：授予小明 resource 角色 12345sql&gt; grant resource to xiaoming;--赋予权限和角色--语法结构：grant 角色1,角色2，。。。 to 用户grant connect to hope2grant connect,resource to hope2; 撤销角色和权限： 123--语法结构：revoke 角色1，角色2，。。。from 用户revoke resource from hope2;revoke connect,resource from hope2; 3.3 oracle 中权限的概念权限分为系统权限与对象权限。 系统权限 ：是数据库管理相关的权限： create session(登录权限) create table(创建表权限) create index(创建索引权限) create view(创建视图权限) create sequence(创建序列权限) create trriger(创建触发器权限) 对象权限： 是用户操作数据对象相关的权限。 比如对表的增删改查（insert 增、delete 删、update 改、select 查）； 3.4 角色在 oracle 中角色分为：预定义角色和自定义角色； 预定义角色：把常用的权限集中起来，形成角色。常见的角色有：dba、connect、resource等； connnect 角色 ：是授予用户的最基本的权利，能够连接到 oralce 数据库中，并在对其他用户的表有访问权限时，做 SELECT、UPDATE、INSERTT 等操作。Create session–建立会话；Alter session–修改会话；Create view–建立视图。Create sequence–建立序列等权限 resource 角色 ：具有创建表、序列、视图等权限。Create table–建表；Create trigger–建立促发器；Create procedure–建立过程；Create sequence—建立序列；Create type–建立类型等权限； dba 角色 ：是授予系统管理员的，拥有该角色的用户就能成为系统管理员了，它拥有所有的系统权限。自定义角色：按需定制一定权限形成角色，可以作为预定义角色的补充。来满足用户的需求。 二，Oracle 数据类型1 、 char(size)存放字符串，它最大可以存放 2000 个字符，是定长。可以存储定长的字符串 1例子：create table test1(name char(32)); 说明： test1 表中的 name 字段最多存放 32 个字符， 不足 32 个字符 oracle 会用空格补齐,如果超过会报错。2 、 varchar 可以存储变长的字符串（不太常用）2—— varchar2(size)存放字符串，它最大可以存放 4000 个字符，是变长。举例说明： 12create table test2(name varchar2(16));//test2 表中的 name 字段最多存放 16 个字符，实际有几个字符就占几个字符的空间，如果超过会报错。 注意：如果我们的数据的长度是固定的，比如编号(8 位)，最好使用 char 来存放，因为这样存取的速度 区别：：： 什么时候用char 什么时候用varchar(2); ？？ 当已知字符串的长度的时候用char比较合适，不确定字符串长度时，用varchar2比较合适 -----nchar和nvarchar2可以存储Unicode字符集3 、 number 型存放整数，也可存放小数，是变长。number(p,s)//p 代表整个位数，s 代表小数位说明： number(5,2)： 表示一个小数有 5 位有效数，2 位小数。范围-999.99～999.99 如果数值超出了位数限制就会被截取多余的位数。但在一行数据中的这个字段输入 575.316，则真正保 存到字段中的数值是 575.32。 number(5) ： 等价于 number(5,0) 表示一个五位整数，范围-99999～99999。 输入 57523.316，真正保存的数据是 57523 –number 等价于number(38,0) –number(15)表示可以存储一个15位的整数 –number(22,7)表示可以浮点数，整数部分有15位，小数点后有7位 注意：不建议使用varchar，interger，float，double4，日期数据类型，date 类型date类型，用于表示时间，( 年/ 月/ 日/ 时/ 分/ 秒) ，是定长。 sysdate：日期函数；显示当前日期 select systate from dual； //显示当前日期 systimestamp:比Date更精确的一个时间 Date：日期类型，存储日期和时间 TimeStamp：比Date更精确的一种日期类型。 默认的日期格式 ---中文的oracle：日-月-年 比如：‘1998年7月1日’ 默认日期格式-&gt; ‘01-7月-1998’ ---英文的oracle：day-mon-year 比如1998年7月1日 默认日期格式-&gt;&apos;01-JUL-1998&apos;与日期相关的函数 to_date(字符串，格式) :将一个oracle不认识的日期格式转成oracle认识的日期格式返回的是一个日期类型select to_date(‘2018-01-05’,yyyy-mm-dd); 1234567举例说明：create table test5(birthday date);//添加时个要使用默认格式 insert into test5 values('11-11 月-11');如使用 insert into test5 values('2011-11-11');则报错。说明：oracle 日期有默认格式为：DD-MON-YYYY,日-月-年；如果我们希望使用自己习惯的日期添加，也可以，但是需要借助 oracle 函数来添加。insert into test5 values(to_date('2015-5-3','yyyy-mm-dd')) 5 、 clob 型字符型大对象，它最大可以存放 8TB ，是变长。（nvarchar(4000) 满足不了需求）与字符型的 char/varchar2/nchar/nvarchar2 的使用方式一样。 6 、 blob 型二进制数据，可存放图片、声音，它最大可以存放 8TB ，是变长。与字符型的 char/varchar2/nchar/nvarchar2 的使用方式一样。 说明：一般情况下很少使用数据库来存放媒体类文件，一般只使用数据库来记录媒体类文件的 URL 地址。如果考虑到文件的安全性，可以存放到数据库中来保存。 三、表的操作1.创建表： 实际上解决的是表结构的问题，表有几个字段，每个字段的长度是多少。语法： create table 表的名称（字段名称 1 数据类型, 字段名称 2 数据类型）; 12345678举例：创建学生表，字段和类型如下所示： 字段 字段类型 说明 id 整型 number name 字符型 varchar2 sex 字符型 char（2） brithday 日期型 date score 小数型 number(3,1) resume（简历） 大文本型 clob 代码 12345678910create table students(id number,name varchar2(64),sex char(2),brithday date,score number(3,1),resume clob)create table student(stuno number(4) primary key,stuname varchar2(10),age number(2),addr varchar(50));insert into student values(1001,'zhang',18,'luoyang'); 删除表： 1drop table student; 2.6. 案例：（ 掌握创建约束 ）（商店售货系统 ）举例说明：商店售货系统表设计案例 ： 1234567891011现有一个商店的数据库，记录客户及其购物情况，由下面三个表组成：商品 goods 表： 商品号 goodsId（主键），商品名 goodsName（非空）， 单价 price（大于零），商品类别 category，供应商 provider；客户 customer: 客户号 customerId（主键），姓名 name（非空），住址 address， 邮箱 email，性别 sex（默认男，check），身份证 cardId（唯一）；购买 purchase ： 客户号 customerId（外键），商品号 goodsId（外键）， 购买数量 nums（1 到 30 个）；请用 SQL 语言完成下列功能： 建表，在定义中要求声明：(1).每个表的主外键；(2).客户的姓名不能为空值；(3).单价必须大于 0，购买数量必须在 1 到 30 之间；(4).邮箱不能够重复；(5).客户的性别必须是 男 或者 女，默认是男；  商品表： 1234567891011商品 goods 表：商品编号：goodsId 商品名称：goodsName单价：price 商品类别：category供应商：provider代码：create table goods(goodsId number primary key,goodsName varchar2(36),price number check(price&gt;0),category varchar2(64),provider varchar2(64));  客户 表： 123456789101112 客户 customer 表： 客户编号：customerId 姓名：name ， 住址：address 邮箱：email ， 性别：sex 身份证：idCard代码：create table customer(customerId number primary key,name varchar2(32) not null,address varchar2(64),email varchar2(64) unique,sex char(2) default' 男' check(sex in(' 男',' 女')),idCard varchar2(20));  购买表： 123456789购买 purchase 表：客户 编 号 ：customerId 商品编号：goodsId购买数量 ：nums代码：create table purchase(customerId number references customer(customerId),goodsId number references goods(goodsId),nums number check(nums&gt;=1 and nums&lt;=30),primary key(customerId,goodsId));","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle 11g安装步骤与卸载步骤","slug":"2018-02-10-Oracle-11g安装步骤与卸载步骤","date":"2018-02-10T05:56:32.000Z","updated":"2021-05-16T11:04:06.700Z","comments":true,"path":"2018/02/10/2018-02-10-Oracle-11g安装步骤与卸载步骤/","link":"","permalink":"http://yoursite.com/2018/02/10/2018-02-10-Oracle-11g%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E6%AD%A5%E9%AA%A4/","excerpt":"1.安装步骤首先先下载好Oracle安装包（这个就不用说了，上Oracle官网自己找下载入口），将下载好后的两个压缩文件解压至同一文件夹下，","text":"1.安装步骤首先先下载好Oracle安装包（这个就不用说了，上Oracle官网自己找下载入口），将下载好后的两个压缩文件解压至同一文件夹下， 解压提供的压缩包，看到如下目录： 第一个目录是Oracle的安装文件目录第二个目录是32位的PLsql链接64的Oracle需要的客户端文件第三个目录是PLSQL的安装文件，其中包括中文扩展包等 1、Oracle的安装步骤一：双击datebase目录下的setup.exe文件，打开安装程序 步骤二：不用填写任何东西，直接点击“下一步”。如果有提示，点击“继续”即可步骤三：安装选项按照默认的不变，直接点击“下一步”按钮步骤四：默认选择“桌面类”，点击“下一步”按钮步骤五：查看Oracle的安装目录，可以默认不用修改。这里主要输入全局数据库的管理口令和确认口令。这里密码统一输入orcl。下面的警告可以不用处理，点击“下一步”按钮，直到点击“完成”按钮，Oracle开始安装步骤六：安装成功后，不要急着点击弹出的框的“确定”按钮。因为数据库中某些用户处于锁定状态，需要解锁。因此点击“口令管理”按钮，对下列用户进行解锁，设置口令选择口令管理，主要观察一下几个用户： 普通用户：Scott用户的密码：tiger 普通管理员：system用户的密码：orcl 超级管理员：sys用户的密码：orcl 步骤七：激活账户设置过口令后，点击确定按钮，关闭窗口。整个安装过程结束。打开cmd运行框，输入sqlplus，打开数据库登录窗口。用户名输入scott，密码输入tiger。回车登录进入到数据库，表明数据库一切正常 2、Oracle服务介绍Oracle安装成功后，因此启动了多个服务，占用内存比较大，因此需要关闭某些不必要的服务。Oracle11g安装后，一共有以下几个服务： 具体操作是右键“我的电脑”–“管理”–“服务和应用程序”—“服务”，可以看到上图的Oracle服务。具体每个服务的介绍如下：| Oracle ORCL VSS Writer Service默认手动操作–Oracle卷映射拷贝写入服务，VSS(Volume Shadow Copy Service)能够让存储基础设备(比如磁盘，阵列等)创建高保真的时间点映像，即映射拷贝(shadow copy)。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。(非必须启动) ||–|| 默认开启启动 Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager(企业管理器OEM)的时候，需要启动这个服务。(非必须启动) ||- OracleJobSchedulerORCL默认自动禁止 Oracle作业调度(定时器)服务，ORCL是Oracle实例标识。(非必须启动) -||- OracleMTSRecoveryService默认开机启动 服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。(非必须启动) -||- OracleOraDb11g_home1ClrAgent默认手动操作 Oracle数据库.NET扩展服务的一部分。 (非必须启动)-||-OracleOraDb11g_home1TNSListener 默认开机启动 监听器服务，服务只有在数据库需要远程访问的时候才需要。|- OracleServiceORCL 默认开机启动 数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。(必须启动)-| -| 通过以上内容，将除了OracleOraDb11g_home1TNSListener和OracleServiceORCL设置为自动启动外，其他的都设置为手动启动。这样可以给电脑剩下很多的内存空间。 3、PLSQL的安装和链接我们这里用的是Oracle 64位，而PLSQL是32位的。下面是我们的操作步骤步骤一：安装PLSQL且破解成功步骤二：假设Oracle的安装目录是D:\\app\\hp，将installclient_11_2目录拷贝到Oracle安装的目录：D:\\app\\hp\\product中。如下图；步骤三：在目录D:\\app\\hp\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN中找到两个文件listener.ora和tnsnames.ora，将此两个文件拷贝到D:\\app\\hp\\product\\instantclient_11_2\\NETWORK\\ADMIN（注意NETWORK和ADMIN目录需要自己新建） 步骤四：打开PLSQL客户端后，取消登陆，进入主界面点击工具—首选项—连接。将其中的”注销“更改为”提交“；Oracle主目录名写入：D:\\app\\hp\\product\\instantclient_11_2OCI库的目录写入：D:\\app\\hp\\product\\instantclient_11_2\\OCI.DLL应用–确定–关闭PLSQL_Developer重新运行 步骤五：关闭PLSQL，重新打开PLSQL，然后输入用户名密码scott/tiger，选择数据库为orcl，点击登陆就可以操作数据库了 数据库的三个常用的用户及默认密码sys:change_on_installsystem:managerscott:tiger （本机在安装时对初始密码进行更改为123456，scott密码仍未tiger） Oracle客户端：sqlplus：Oracle自带的sqlplus的启用：(1)Oracle的安装目录中找到sqlplus(2)命令行中输入：sqlplus username/password@ip:port/database sid(3)开始菜单-&gt;运行:输入sqlplus username/password@ip:port/database sid注意：(1)@ip:port：登录远程数据库使用，登录本地数据库可以省略，可以写成：sqlplus username/password(2)database sid:选择数据库的意思。(3)问题:登陆本地数据库：sqlplus username/password@ORCL 注意：在口令管理中，，忘记解锁怎么办？解锁用户和修改密码：（1）sqlplus连接到数据库：sqlplus sys/123456 as sysdba（2）输入解锁语句：alter user scott account unlock;（3）修改密码：alter user scott identified by 654321; passw【ord】用户名:可以去修改其他用户的密码。 passw:表示修改自己的密码。 4 Oracle的卸载步骤：1.我的电脑右键管理－＞服务停止所有Oracle服务。或者控制面板－＞管理工具－＞服务停止所有Oracle服务2.开始－＞程序－＞Oracle －＞Oracle Installation Products－＞ Universal Installer 卸装所有Oracle产品，但Universal Installer本身不能被删除3.点击卸载产品，选择需要卸载的产品，点击删除按钮4.卸载完成后重启计算机5.运行regedit，删除HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLEHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services，滚动这个列表，删除所有Oracle入口。HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application， 删除所有Oracle入口。 注意，最主要的是最后一步，删除注册表中得在内容。","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Servlet中读取txt文本文件路径问题","slug":"2018-02-10-Servlet中读取txt文本文件路径问题","date":"2018-02-10T05:56:32.000Z","updated":"2021-05-16T11:04:06.702Z","comments":true,"path":"2018/02/10/2018-02-10-Servlet中读取txt文本文件路径问题/","link":"","permalink":"http://yoursite.com/2018/02/10/2018-02-10-Servlet%E4%B8%AD%E8%AF%BB%E5%8F%96txt%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","excerpt":"在进行javaweb开发中，遇到了一个问题，就是Servlet读取webcontent下的文本文件路径问题，会出现系统找不到文件的各种错误，经过查找问题，发现原来是由于这个项目部署在tomcat上之后，文件的目录结构会发生相应的一些变化，所以说使用常规的获取相对或绝对路径的方式在这个照常使用会导致运行之后，系统提示找不到文件路径的一些错误提示。下面对如何在servlet中读取WEB-INF下的我存放的txt文件进行记录。","text":"在进行javaweb开发中，遇到了一个问题，就是Servlet读取webcontent下的文本文件路径问题，会出现系统找不到文件的各种错误，经过查找问题，发现原来是由于这个项目部署在tomcat上之后，文件的目录结构会发生相应的一些变化，所以说使用常规的获取相对或绝对路径的方式在这个照常使用会导致运行之后，系统提示找不到文件路径的一些错误提示。下面对如何在servlet中读取WEB-INF下的我存放的txt文件进行记录。 下图为项目路径，而这里要实现的便是使用teacherProduce这一个Servlet来读取WEB-INF目录下的teacher1.txt文件。在这里说明一些获取文件路径的问题常规的相对路径在这里无效，在tomcat上部署后目录结构变了要使用getServletContext().getRealPath 来获取文件的路径。 1String pathname = this.getServletContext().getRealPath(\"/txt/teacher1.txt\"); 需要注意的是：getServletContext().getRealPath只能在servlet中使用。 完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class teacherProduce extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"UTF-8\"); //读取文件 String content = null; String pathname = this.getServletContext().getRealPath(\"/txt/teacher1.txt\"); String encoding = \"UTF-8\"; File file = new File(pathname); System.out.println(file); BufferedReader br = null; try &#123; InputStreamReader reader = new InputStreamReader(new FileInputStream(file)); br = new BufferedReader(reader); String line = \"\"; while ((line = br.readLine()) != null) &#123; System.out.println(line); content = content +line; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; request.setAttribute(\"content\", content); request.getRequestDispatcher(\"/personProduce/personProduce.jsp\").forward(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"plsql中如何创建函数，触发器以及包和变量的使用","slug":"2018-02-10-plsql中如何创建函数，触发器以及包和变量的使用","date":"2018-02-10T05:56:32.000Z","updated":"2021-05-16T11:04:06.702Z","comments":true,"path":"2018/02/10/2018-02-10-plsql中如何创建函数，触发器以及包和变量的使用/","link":"","permalink":"http://yoursite.com/2018/02/10/2018-02-10-plsql%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%8C%85%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"在数据库的操作中，在编写sql语句的时候，我们可能会用到函数以及触发器等的操作来简化我们的工作。在这片文章中，也和我以前的博文一样，不是纯粹的理论讲解，而是采用的是案例的方式进行笔记的记录说明。还是用到的以前博文中的员工表emp","text":"在数据库的操作中，在编写sql语句的时候，我们可能会用到函数以及触发器等的操作来简化我们的工作。在这片文章中，也和我以前的博文一样，不是纯粹的理论讲解，而是采用的是案例的方式进行笔记的记录说明。还是用到的以前博文中的员工表emp 1.认识plsql的函数问题1 输入雇员姓名返回年薪 123456create or replace function sp_func(spName varchar2) return number is yearSal number(7,2); begin select sal*12+nvl(comm,0)*12 into yearSal from emp where ename=spName; return yearSal; end; 总结： 语法： create 【or replace】 function 函数名（参数1 类型1，参数2 类型2） return 返回值类型 is 变量、常量和游标的定义； begin 执行部分 exception 异常处理部分（可选） end;调用函数的第一种方式 var income number; --定义全局变量var 变量名 变量类型 call sp_func(&apos;SCOTT&apos;) into:income; --全局变量赋值：call 函数into：全部变量名 print income; --打印全局变量 print 全局变量名调用函数的第二种方式 select sp_func(&apos;SCOTT&apos;) from dual;2,包 包: 主要是一种用来组织和管理过程和函数的一种机制，主要由两部分组成，包规范和包体 包里面主要是声明一下过程和函数，过程和函数的实现放在包体里面 –创建包：包里面只是声明过程和函数 问题：创建一个包，包含一个过程，包含一个函数， 过程：输入员工姓名，新的工资，更新员工工资。 函数：输入员工的姓名，计算该员工的收入 1234createor replace package sp_package is procedure update_sal(name emp.ename%type,newSal emp.sal%type); function annual_income(name emp.ename%type) return number; end; 总结 语法：创建包 12345678create 【or replace】 package 包名 is 过程1声明 过程2声明 ....... 函数1声明 函数2声明 .... end; 过程的实现放在包体里面，包里面只是声明过程和函数 –创建包体: 12345678910111213create or replace package body sp_package is procedure update_sal(name emp.ename%type,newSal emp.sal%type) is begin update emp set sal=newSal where ename=name; end; function annual_income(name emp.ename%type) return number is yearSal number(7,2); begin select sal*12+nvl(comm,0)*12 into yearSal from emp where ename=name; return yearSal; end; end; 创建包体的语法 create 【or replace】 package body 包名 is 过程1实现体 过程2实现体 .... 函数1实现体 函数2实现体 end;​包中的过程和函数的调用 通过 包名.过程名或者 包名.函数名 来调用的​ 123456exec sp_package.update_sal(&apos;SCOTT&apos;,4500); var income number;call sp_package.annual_income(&apos;SCOTT&apos;) into:income;print income;select sp_package.annual_income(&apos;SCOTT&apos;) from dual; PL/SQL变量：标量类型，复合类型，参照类型lob（large object）类型–标量类型： 变量名【constan】 数据类型【not null】【：=值】|【default 值】; 案例： 定义一个变长的字符串：v_ename varchar2(20); 定义一个小数：v_vearsal number(7,2); 定义一个小数，给初始值为3.14：v_sal number(3,2):=3.14; 定义一个常量PI给默认值为3.14：PI constant number(3,2):=3.14; 定义一个日期类型；v_hiredate date 定义一个布尔类型 v_invid boolean not null default false; 编写一个PL/sql块，输入员工编号，显示雇员的姓名和工资，以及个人所得税（税率为0.05） 12345678910 declare v_tax_rate constant number(3,2):=0.05; v_ename emp.ename%type; v_sal emp.sal%type; v_personal_tax number(7,2); begin select ename,sal into v_ename,v_sal from emp where empno=&amp;no;v_personal_tax=v_sal*v_tax_rate; dbms_output.put_line('姓名：'||v_ename||'工资是'||v_sal||'个人所得税'||v_personal_tax); end; %type :输入标量类型一种，比较灵活 v_ename emp.ename%type;表示v_ename 和emp表中的ename类型一样​复合类型： （1）PL/SQL的记录类型： （2）pl/sql的表类型 （3）嵌套表类型 （4）varray类型 （1）PL/SQL记录类型：%rowtype1234567案例：输入一个员工编号，显示该员工的所有信息 declare v_emp emp%rowtype; begin select *into v_emp from emp where empno=&amp;no; dbms_output.put_line('姓名:'||v_emp.ename||'工作:'||v_emp.sal||'奖金:'||v_emp.comm) end; 记录类型（自定义的） 1234567declare type emp_record_type is record(name emp.ename%type,salary emp.sal%type,dept emp.deptno%type); sp_record emp_record_type; begin select ename,sal,deptno into sp_record from emp where empno=&amp;no; dbms_output.put_line('姓名：'||sp_record.name||'工资'||sp_record.salary||'部门'||sp_record.dept); end; ​记录类型的语法：​ type 类型名 is record(变量1 数据类型1 ,变量2 数据类型2,….)​ 变量名 类型名;​ PL/SQL的表类型--表类型（类似于高级语言中的数组） --定义表类型时，不定义表的大小 --定义表类型时，需要指定表中的每个数据的类型 --表类型的下标可以为正，可以为负。12345declare type emp_table_type is table of emp.ename%type index by binary_integer; sp_table emp_table_type; begin select ename into sp_table(-1)from emp where empno=&amp;no; 参照类型：游标 案例：输入一个部门名称，显示该部门所有员工的姓名和工资 1234567891011121314declaretype sp_emp_cursor is ref cursor;test_cursor sp_emp_cursor;v_ename emp.ename%type;v_sal emp.sal%type;begin open test_cursor for select ename,sal from emp where deptno=&amp;no; loop fetch test_cursor into v_ename,v_sal; exit when test_cursor%notfound; dbms_output.put_line('姓名：'||v_ename||'；工资：'||v_sal); end loop; close test_cursor;end; --总结： --（1）定义：type 类型名 is ref cursor: 表明sp_cursor 是一个游标类型 --（2）test_cursor sp_emp_cursor;定义一个游标变量test_cursor，是sp_emp_cursor类型 --（3）open test_cursor for 查询语句； --（4）fetch 游标变量名into 变量1，变量2； --（5）exit when test_cursor%notfound; 定义循环退出的条件 --（6）close test_cursor ：游标使用完要关闭游标，关闭游标写法2（建议使用这一种写法） 12345678910111213declarecursor v_cursor is select ename,sal from emp where deptno=&amp;no;v_ename emp.ename%type;v_sal emp.sal%type;begin open v_cursor; loop fetch v_cursor into v_ename,v_sal; exit when v_cursor%notfound; dbms_output.put_line('姓名：'||v_ename||'；工资：'||v_sal); end loop; close v_cursor;end; /*cursor 游标变量名is select 语句 open 游标变量 fetch 游标变量into 变量1，变量2，….close 游标变量 */ –写法3：用for循环使用游标 1234567891011declarecursor v_cursor is select ename,sal from emp where deptno=&amp;no;v_ename emp.ename%type;v_sal emp.sal%type;begin for v_cursors in v_cursor loop v_ename:=v_cursors.ename; v_sal:=v_cursors.sal; dbms_output.put_line('姓名：'||v_ename||'；工资：'||v_sal); end loop;end; –for循环会自动打开游标和关闭游标 触发器：当用户登录、退出或者是对对象进行操作的时候，或者是进行ddl操作的时候，引起某个存储过程的执行，我们把这样一个隐含调用的存储过程称之为触发器1）我们在开发中，可能会提出这样的问题：–当用户登录的时候，我们希望能够自动记录用户的名字和登录的时间–当用户在周四或非工作日对表进行修改的时候，不允许这样做。–当用户去删除一条记录的时候，希望能够将删除记录自动的备份到另外一张表中 解决方法：触发器触发器分类：dml触发器（insert，update，delete）,ddl触发器，系统事件触发器（登录、退出等操作） 下面我们通过例子，来具体的讲解案例1：创建一张my_emp表，给该表添加记录，提示“添加一条数据” 12345678--语句级的触发器：针对update,insert,select只触发一次操作create table my_emp(id number(3),name varchar2(10)); create or replace trigger tri1after insert on scott.my_empbegin dbms_output.put_line('添加一条数据');end; –执行3次 insert into my_emp values(101,&apos;ellen&apos;)–案例2：在my_emp表中，修改id为101的员工信息的时候，修改一次提示一次–for each row表明这是一个行级触发器：修改一行，触发一次输出操作 123456create or replace trigger tri2after update on scott.my_empfor each rowbegin dbms_output.put_line('修改一条记录');end; –创建触发器的语法结构/*create [or replace] trigger trigger_name{befor|after]} {insert|update|delete}on table_name[for each row][when condition]begin –触发的操作end;*/ –案例3：在删除my_emp表中的记录的时候，提示’删除一条记录’ 123456create or replace trigger tri3after delete on scott.my_empfor each rowbegin dbms_output.put_line('删除一条记录');end; –案例4：在删除my_emp表中的记录的时候，触发报错操作，不让删除 12345create or replace trigger tri4before delete on scott.my_empbegin raise_application_error(-20001,'不能删除');end; /*raise_application_error是oracle给我们提供的存储过程，可以传入两个参数，第一个参数是错误号，-20000–20999之间，第二个参数是报错信息*/ –案例5：为了禁止工作人员在周四删除my_emp表中的员工信息，创建一个触发器完成这个操作 1234567create or replace trigger tri5before delete on scott.my_empbegin if to_char(sysdate,'day')='星期四' then raise_application_error(-20002,'对不起，周四不允许删除员工信息'); end if;end; –案例6：禁止工作人员在周四修改员工信息（insert update delete）,不同操作报错信息不同 12345678910111213create or replace trigger tri6before insert or update or delete on scott.my_empbegin case when inserting then dbms_output.put_line('请不要添加'); raise_application_error(-20003,'请不要添加'); when updating then raise_application_error(-20004,'请不要修改'); when deleting then raise_application_error(-20005,'请不要删除'); end case;end; –当触发器中同时包含多个触发事件时，为了区分触发事件，可以使用三个条件：updating,deleting,inserting –案例7：修改员工工资的时候，要求新工资必须比原来工资高，创建一个触发器来解决这个问题，输出新工资和老工资 12345678910create or replace trigger tri7before update on scott.empfor each rowbegin if :new.sal&lt;:old.sal then raise_application_error(-20006,'新工资不能低于原来工资'); else dbms_output.put_line('原来的工资是：'||:old.sal||'新的工资：'||:new.sal); end if;end; –:new：update操作完成之后的列的值–:old：update操作完成前的列的值 –案例8：编写一个触发器，当用户删除my_emp的记录的时候，自动将删除的id和name备份到另外一张表中 12345678create table my_emp_bak as select * from my_emp where 1=2; create or replace trigger tir8before delete on scott.my_empfor each rowbegin insert into my_emp_bak values(:old.id,:old.name);end; –禁用触发器 alter trigger trigger_name disable;–启用触发器 alter trigger trigger_name enable;–删除触发器 drop trigger trigger_name;–编写一个触发器，控制员工的新工资不能低于原来的工资，但是也不能高于原来工资的20% 12345678create or replace trigger tri9before update on scott.empfor each rowbegin if :new.sal&lt;:old.sal or :new.sal&gt;:old.sal*1.2 then raise_application_error(-20007,'工资范围不对'); end if;end; –作业：创建一张学生表stu（id,name,birthdate）,编写一个触发器，要求是：如果学生年龄小于18岁，则不允许插入 –Oracle的系统触发器：主要是针对oracle的系统事件的一个触发器–Oracle定义的常用的系统事件：–ora_client_ip_address:返回客户端的ip–ora_database_name:返回数据库名–ora_login_user:返回登录用户名–ora_sysevent:返回触发器的系统事件名–ora_des_encrypted_password:返回加密后的密码 –案例：为了记录用户登录和退出的时间，可以建立登录和退出的触发器 create table log_table(username varchar2(10),logon_time date,logoff_time date,address varchar2(20));–创建登录触发器 12345create or replace trigger logonafter logon on databasebegin insert into log_table(username,logon_time,address)values(ora_login_user,sysdate,ora_client_ip_address);end; –创建退出触发器 12345create or replace trigger logoffbefore logoff on databasebegin insert into log_table(username,logoff_time,address)values(ora_login_user,sysdate,ora_client_ip_address);end; –系统触发器需要时系统管理员身份才能创建 –ddl触发器：–编写一个触发器，可以记录用户所进行的ddl操作 1234567create table my_ddl_event(event varchar2(20),username varchar2(10),time date); create or replace trigger ddl_triafter ddl on scott.schemabegin insert into my_ddl_event values(ora_sysevent,ora_login_user,sysdate);end; –禁用一张表上所有的触发器： alter table 表名 disable all triggers;–激活一张表上所有的触发器： alter table 表名 enable all triggers;","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"oracle数据库忘记sys(或system)账户密码","slug":"2018-02-10-oracle数据库忘记sys(或system)账户密码","date":"2018-01-12T05:56:32.000Z","updated":"2021-05-16T11:04:06.702Z","comments":true,"path":"2018/01/12/2018-02-10-oracle数据库忘记sys(或system)账户密码/","link":"","permalink":"http://yoursite.com/2018/01/12/2018-02-10-oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%98%E8%AE%B0sys(%E6%88%96system)%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81/","excerpt":"一、忘记除SYS、SYSTEM用户之外的用户的登录密码。 用SYS (或SYSTEM)用户登录: sqlplus sys/password as sysdba 使用如下语句修改用户的密码: alter user user_name identified by newpassword; 注意：密码不能全是数字。并且不能是数字开头。否则会出现：ORA-00988: 口令缺失或无效","text":"一、忘记除SYS、SYSTEM用户之外的用户的登录密码。 用SYS (或SYSTEM)用户登录: sqlplus sys/password as sysdba 使用如下语句修改用户的密码: alter user user_name identified by newpassword; 注意：密码不能全是数字。并且不能是数字开头。否则会出现：ORA-00988: 口令缺失或无效 二、忘记SYS用户，或者是SYSTEM用户的密码。 如果是忘记SYSTEM用户的密码，可以用SYS用户登录。然后用ALTER USER 命令修改密码： CONN SYS/PASS_WORD AS SYSDBA; ALTER USER SYSTEM IDENTIFIED BY “newpass”; 如果是忘记SYS用户的密码，可以用SYSTEM用户登录。然后用ALTER USER 命令修改密码。 CONN SYSTEM/PASS_WORD ; ALTER USER SYSTEM IDENTIFIED BY newpass; 三、如果SYS,SYSTEM用户的密码都忘记或是丢失。 可以使用ORAPWD.EXE 工具修改密码。 开始菜单-&gt;运行-&gt;输入‘CMD’,打开命令提示符窗口，输入如下命令： orapwd file=D:\\oracle10g\\database\\pwdctcsys.ora password=newpass 这个命令重新生成了数据库的密码文件。密码文件的位置在ORACLE_HOME目录下的\\database目录下。 这个密码是修改sys用户的密码。除sys其他用户的密码不会改变。不过Oracle提供了两种验证方式，一种是OS验证，另一种密码文件验证方式，如果是第一种方式用以下方法修改密码： sqlplus /nolog; connect / as sysdba alter user sys identified by ; alter user system identified by ; 如果是第二种方法就用上述方式修改，也可以下方法修改密码： orapwd file=pwdxxx.ora password=你设定的新密码 entries=10 设定完后，重新启动服务，再次登陆就可以了。 oracle 11g在本机安装完Oracle以后，不记得sys用户的密码了，采用如下方法可以修改密码：1.打开cmd，输入sqlplus /nolog，回车；输入“conn / as sysdba”;输入“alter user sys identified by 新密码”，注意：新密码最好以字母开头，否则可能出现错误Ora-00988。有了这个方法后，只要自己对oracle服务器有管理员权限，不记得密码的时候就可以随意修改密码了。2.在命令行执行如下命令：sqlplus “/@服务名 as sysdba”,然后在sqlplus中alter user sys identified by 新密码;alter user system identified by 新密码;3.运行到C盘根目录1)输入：SET ORACLE_SID = 你的SID名称2)输入：sqlplus/nolog3)输入：connect/as sysdba4)输入：alert user sys identified by sys5)输入：alert user system identified by system6)更改完成，密码是Oracle数据库初始密码4.首先,在CMD下输入SQLPLUS/NOLOG然后再在出来的界面中打入CONN/AS SYSDBA,这样就会以本地系统登录的用户为信任用户进入数据库的操作.解决这个问题的方式有两种,一个是：ALTER USER （USERNAME） IDENTIFIED BY “密码”;这个是可以改变USERNAME的密码.当然这个USERNAME必须已经存在的另一种是：CREATE USER (USERNAME) IDENTIFIED BY “密码”;改变用户权限的命令是：GRANT ROLES TO （USERNAME）;以上2种方法都是针对ORACLE 9I的版本 。5.用orapwd.exe命令，可以修改命令。orapwd file=’/oracle/pwdsid.ora’ password=123456这个命令是修改sys用户的密码。你把生成的文件覆盖原来的密码文件。除sys其他用户的密码不会改变。6.su - oraclesqlplus /nologconn / as sysdbastartup (如果数据库不是处于启动状态则启动)alter user sys identified by 123456 然后就可以使用sys用户密码登陆了操作系统认证方式conn / as sysdbaalter user sys identified by xxx 一、遇到的问题：1.、忘记除SYS、SYSTEM用户之外的用户的登录密码。 2.、忘记SYS用户，或者是SYSTEM用户的密码。 3.、如果SYS,SYSTEM用户的密码都忘记或是丢失。 二、解决方案： 忘记除SYS、SYSTEM用户之外的用户的登录密码。 用SYS (或SYSTEM)用户登录，使用如下语句修改用户的密码。 CONN SYS/PASS_WORD AS SYSDBA; ALTER USER SYSTEM IDENTIFIED BY newpass; 注意：密码不能全是数字。并且不能是数字开头。否则会出现：ORA-00988: 口令缺失或无效 忘记SYS用户，或者是SYSTEM用户的密码。 （1）如果是忘记SYSTEM用户的密码，可以用SYS用户登录。然后用ALTER USER 密令修改密码。 12CONN SYS//PASS_WORD AS SYSDBA;ALTER USER SYSTEM IDENTIFIED BY newpass; （2）如果是忘记SYS用户的密码，可以用SYSTEM用户登录。然后用ALTER USER 密令修改密码。 12CONN SYSTEM//PASS_WORD ;ALTER USER SYSTEM IDENTIFIED BY newpass; 如果SYS,SYSTEM用户的密码都忘记或是丢失。这一项尤其重要。可以使用ORAPWD.EXE 工具修改密码。 开始菜单-&gt;运行-&gt;输入‘CMD’,打开命令提示符窗口，输入如下命令： 1orapwd file=D:\\oracle\\product\\10.2.0\\db_1\\database\\pwdctcsys.orapassword=newpass 这个命令重新生成了数据库的密码文件。密码文件的位置在ORACLE_HOME目录下的\\database目录下。这个密码是修改sys用户的密码。除sys和system其他用户的密码不会改变。","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://yoursite.com/categories/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]}]}